{"meta":{"title":"Mario","subtitle":"📌好前端才分对错，成年人只分利弊","description":"好前端才分对错，成年人只分利弊","author":"Codding","url":"http://mariogogogo.github.io"},"pages":[{"title":"👨🏻‍💻 关于我","date":"2017-09-10T16:00:00.000Z","updated":"2019-11-05T05:50:48.000Z","comments":false,"path":"about/index.html","permalink":"http://mariogogogo.github.io/about/index.html","excerpt":"","text":"联系方式 手机：137****0892 Email：148373644@qq.com QQ/微信号：148373644 个人信息 Mario/男/1986 本科/树人大学 工作年限：11 年 微博：被和谐具体原因不详 😂 技术博客：http://h5web.cc Github：http://github.com/MarioGogogo 期望职位：Web 前端高级程序员 期望薪资：税前月薪 15k~20k，特别喜欢的公司可例外 期望城市：杭州 工作经历ABC 公司 （ 2012 年 9 月 ~ 2014 年 9 月 ）DEF 项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI 项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL 公司 （ 2010 年 3 月 ~ 2012 年 8 月 ）MNO 项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR 项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比 Show me the code 能有说服力了） STU：项目的简要说明，Star 和 Fork 数多的可以注明 WXYZ：项目的简要说明，Star 和 Fork 数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自 HeroKu 的 HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014 架构师大会演讲：如何通过 Docker 优化内部开发 9 月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web 开发：PHP/Hack/Node Web 框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/Mogoodb 版本管理、文档和自动化部署工具：Svn/Git/ 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"归档","date":"2017-09-20T12:49:56.000Z","updated":"2019-11-05T05:49:56.000Z","comments":false,"path":"archives/index.html","permalink":"http://mariogogogo.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-04T16:00:00.000Z","updated":"2021-06-17T03:29:06.749Z","comments":false,"path":"categories/index.html","permalink":"http://mariogogogo.github.io/categories/index.html","excerpt":"","text":""},{"title":"搜索","date":"2021-02-20T01:52:21.083Z","updated":"2019-11-05T05:50:10.000Z","comments":true,"path":"search/index.html","permalink":"http://mariogogogo.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T16:00:00.000Z","updated":"2021-06-17T03:29:22.919Z","comments":false,"path":"tags/index.html","permalink":"http://mariogogogo.github.io/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2020-05-13T06:16:07.000Z","updated":"2021-06-17T03:30:50.170Z","comments":true,"path":"links/index.html","permalink":"http://mariogogogo.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树的层序遍历","slug":"算法-二叉树的层次遍历","date":"2021-02-20T16:00:00.000Z","updated":"2021-02-21T13:51:32.000Z","comments":true,"path":"2021/02/21/算法-二叉树的层次遍历/","link":"","permalink":"http://mariogogogo.github.io/2021/02/21/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","excerpt":"学会二叉树的层序遍历，可以一口气撸完leetcode上八道题目: 107.二叉树的层次遍历II 199.二叉树的右视图 637.二叉树的层平均值 429.N叉树的前序遍历 515.在每个树行中找最大值 116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针II","text":"学会二叉树的层序遍历，可以一口气撸完leetcode上八道题目: 107.二叉树的层次遍历II 199.二叉树的右视图 637.二叉树的层平均值 429.N叉树的前序遍历 515.在每个树行中找最大值 116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针II 二叉树的层次遍历 II题目链接:https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ 给定一个二叉树，返回其节点值自底向上的层次遍历。 (即按从叶子节点所在层到根节点所在的层，逐 层从左向右遍历) 思路1.前面都是层次遍历套路 2.最后结果再用数组reverse方法 图解 代码1234567891011121314151617var levelOrderBottom = function(root) &#123; if(!root) return [] const q = [[root,0]] const res = [] while(q.length &gt; 0)&#123; const [n,level] =q.shift() if(!res[level])&#123; res.push([n.val]) &#125;else&#123; res[level].push(n.val) &#125; if(n.left) q.push([n.left,level+1]) if(n.right)q.push([n.right,level+1]) &#125; //反转 return res.reverse()&#125;; 199.二叉树的右视图题目链接:https://leetcode-cn.com/problems/binary-tree-right-side-view/ 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 思路 层序遍历的时候， 判断是否遍历到单层的最后面的元素 (重点分析 对每一层q的数组进行while len–操作) 如果是，就放进result数组中，随后返回result 就可以了。 图解 代码12345678910111213141516171819var rightSideView = function(root) &#123; if(!root) return [] const q = [root] const res = [] while(q.length &gt; 0)&#123; let len = q.length //对每一层进行遍历 [1] [2,3 ] [4,5,6] [7] while(len)&#123; let n = q.shift() //每一层最后一位 if(len === 1) res.push(n.val) if(n.left) q.push(n.left) if(n.right) q.push(n.right) len-- &#125; &#125; return res&#125;; 637.二叉树的层平均值题目链接:https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/ 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 12345678910输入： 3 / \\ 9 20 / \\ 15 7输出：[3, 14.5, 11]解释：第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。 思路 用层序遍历的方法。维护一个队列去遍历节点。 用 for 循环控制一层的节点逐个出列，节点值累加求和。 节点出列的同时，下一层的子节点加入队列，在 for 循环结束时，队列中就全是下一层的节点。 此时当前层的求和也好了，除以当前层的节点个数，就是当前层的平均值，加入结果数组。 接着处理下一层的节点，重复以上步骤，就构建好了结果数组。 图解 代码1234567891011121314151617181920var averageOfLevels = function(root) &#123; if(!root) return [] const p = [root] const res = [] while(p.length&gt;0)&#123; let size = p.length //每一层的长度 let sum = 0 for(let i = 0; i&lt;size;i++)&#123; const n = p.shift() //每一层的总和 sum += n.val if(n.left) p.push(n.left) if(n.right) p.push(n.right) &#125; res.push(sum/size) &#125; return res&#125;; 429.N叉树的层序遍历题目链接:https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。 思路图解代码12345678910111213141516var levelOrder = (root)=&gt;&#123; if(!root) return const p = [root] const res = [] while(p.length &gt; 0)&#123; const size = p.length const temp = [] for(let i = 0; i&lt; size;i++)&#123; const n = p.shift() temp.push(n.val) p.push(...n.children) &#125; res.push(temp) &#125; return res&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树的先中后层序遍历","slug":"算法-二叉树的先中后遍历","date":"2021-02-19T16:00:00.000Z","updated":"2021-02-21T05:38:28.000Z","comments":true,"path":"2021/02/20/算法-二叉树的先中后遍历/","link":"","permalink":"http://mariogogogo.github.io/2021/02/20/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/","excerpt":"二叉树的四种遍历方式：先序遍历、中序遍历、后序遍历、层序遍历。","text":"二叉树的四种遍历方式：先序遍历、中序遍历、后序遍历、层序遍历。 模拟一棵二叉树1234567891011121314151617181920212223242526272829exports.root = &#123; val: 1, left: &#123; val: 2, left: &#123; val: 4, left: null, right: null, &#125;, right: &#123; val: 5, left: null, right: null, &#125;, &#125;, right: &#123; val: 3, left: &#123; val: 6, left: null, right: null, &#125;, right: &#123; val: 7, left: null, right: null, &#125;, &#125;,&#125;; 先序遍历算法口诀 访问根节点 对根节点左子树进行先序遍历 对根节点右子树进行先序遍历 图解 先序遍历（递归版本）12345678const preorder = (root)=&gt;&#123; if(root)&#123; //遍历左节点 preorder(root.left) //遍历右节点 preorder(root.right) &#125;&#125; 先序遍历（迭代版本） 思路：我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同 图解 思路 前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中， 然后将右节点加入栈，再加入左节点。 为什么要先加入 右节点，再加入左节点呢？ 因为这样出栈的时候才是中左右的顺序。 12345678910const preorder = (root)=&gt;&#123; if(!root) return const stack = [root] while(stack.length &gt; 0)&#123; const n = stack.pop() //拿到n.val if(n.right) stack.push(n.right) //为什么要先存right值 因为数组后进先出 if(n.left) stack.push(n.left) &#125;&#125; 中序遍历算法口诀 对根节点左子树进行中序遍历 访问根节点 对根节点右子树进行先序遍历 图解 中序遍历（递归版本）12345678910const inorderTraversal = (root)=&gt;&#123; const midSort = (root)=&gt;&#123; if(!root) return midSort(root.left) res.push(root.val) midSort(root.right) &#125; return midSort(root)&#125; 中序遍历（迭代版本）图解 思路中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问。 直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 1234567891011121314151617const inorderTraversal = (root)=&gt;&#123; if(!root) return let stack = [] //设置一个空栈 let p = root //设置指 while(stack.length || p)&#123; /*****一直找左节点****/ while(p)&#123; stack.push(p) //每当左子树有值 [root left left left] p = p.left &#125; /*****一直找左节点****/ //找完所有左节点 推出栈 [root left1 left2 left3] ==&gt; [left3 left2 left1 root ] const n = stack.pop() //拿n.val p = n.right &#125;&#125; 后序遍历算法口诀 对根节点左子树进行中序遍历 对根节点右子树进行先序遍历 访问根节点 图解 后序遍历（递归版本）1234567let res = []const postorderTraversal = (root)=&gt;&#123; if(!root) return postorderTraversal(root.left) postorderTraversal(root.right) res.push(root.val)&#125; 后序遍历（迭代版本）思路（这是一个讨巧的办法） 如果我们把前序遍历的 list.push(node.val) 变更为 list.unshift(node.val) （遍历结果逆序）， 那么遍历顺序就由 根左右 变更为 右左根。 然后我们仅需将 右左根 变更为 左右根 即可完成后序遍 图解 123456789101112const postorderTraversal = (root)=&gt;&#123; let list = [] //遍历结果 let stack = [root] // if(!root) return while(stack.length &gt;0)&#123; const n = stack.pop() // [n.left,n.right] list.unshift(n.val) //根是最后加的 最里面 [ n.left n.right n.val] if(n.left) stack.push(n.left) if(n.right) stack.push(n.right) &#125; return list&#125; 层序遍历 题目来源：LeetCode：102 二叉树的层序遍历 👑类似广度优先遍历二叉树。 👑遍历工程中，记录每一个节点的层级，并将其添加到不同的数组中。 图解 思路先写一个广度优先遍历 加入层级计算 12345678910111213141516171819var levelOrder = function (root) &#123; if(!root) return [] const q = [[root,0]] //把顶层加入栈中 const res = [] while(q.length &gt; 0)&#123; //推出每一个栈中顶层节点 const [n,level]= q.shift() if(!res[level])&#123; res.push([n.val]) &#125;else&#123; res[level].push(n.val) &#125; //如果左右节点都存在则层级+1 if(n.left) q.push([n.left,level+1]) if(n.right) q.push([n.right,level+1]) &#125; return res&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"深度广度优先遍历","slug":"算法-深度广度优先遍历","date":"2021-02-18T16:00:00.000Z","updated":"2021-02-20T15:27:38.000Z","comments":true,"path":"2021/02/19/算法-深度广度优先遍历/","link":"","permalink":"http://mariogogogo.github.io/2021/02/19/%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/","excerpt":"先来学一下树的深度与广度优先","text":"先来学一下树的深度与广度优先 深度优先遍历算法口诀1.访问根节点 2.对根节点chilidren挨个进行深度优先遍历（递归） 1234567891011121314151617181920212223242526272829303132// dfs.jsconst root = &#123; val: &#x27;a&#x27;, children: [ &#123; val: &#x27;b&#x27;, children: [ &#123; val: &#x27;c&#x27;, children: [], &#125;, &#123; val: &#x27;d&#x27;, children: [], &#125;, ], &#125;, &#123; val: &#x27;e&#x27;, children: [ &#123; val: &#x27;f&#x27;, children: [], &#125;, &#123; val: &#x27;g&#x27;, children: [], &#125;, ], &#125;, ],&#125;; dfs123const dfs = (root)=&gt;&#123; root.chilidren.forEach(dfs)&#125; 一行代码 是不是很简单 广度优先遍历算法口诀 bfs123456789101112const bfs = (root)=&gt;&#123; //新建队列 入队 const q = [root] while(q.length &gt; 0)&#123; //把队头出队后 q就空了 const n = q.shift() //这里可以拿到n.val,继续遍历children n.children.forEach(child =&gt;&#123; q.push(child) &#125;) &#125;&#125; 树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）； 常见的 DFS ： 先序遍历、中序遍历、后序遍历；常见的 BFS ： 层序遍历（即按层遍历）。","categories":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法入门指南","slug":"算法入门","date":"2021-02-17T16:00:00.000Z","updated":"2021-02-20T09:26:04.465Z","comments":true,"path":"2021/02/18/算法入门/","link":"","permalink":"http://mariogogogo.github.io/2021/02/18/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/","excerpt":"最常用的数据结构预算法: 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire 树算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法","text":"最常用的数据结构预算法: 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire 树算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法 算法复杂度复杂度分析法则1）单段代码看高频：比如循环。2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3）嵌套代码求乘积：比如递归、多重循环等4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 时间复杂度O(1)123let i = 0;i += 1;//每次执行一次 O(n)123for (let i = 1; i &lt; n; i++) &#123; console.log(i);&#125; O(n^2)12345for (let i = 1; i &lt; n; i++) &#123; for (let j = 1; j &lt; n; j++) &#123; console.log(i, j); &#125;&#125; O(logN)123456let i = 1while(i&lt; n)&#123; console.log(i) i*=2&#125;2的多少次方 === N 空间复杂度 算法在运行过程中临时占用存储空间大小的量度 0(1)123let i = 0;i += 1;//声明了单个变量 占用内存就是1 O(n)12345let res = [];for (let i = 1; i &lt; n; i++) &#123; res.push(i);&#125;//res的空间占用 取决于 n O(n^2)12345678let res = [];for (let i = 1; i &lt; n; i++) &#123; res.push(i); for (let j = 1; j &lt; n; j++) &#123; res[i].push(j); &#125;&#125;类似于一个矩阵---- - 多维数组; 其他概念什么是线性线性表: 线性表就是数据排成像一条线一样的结构.每个现行表上的数据最多只有前和后两个方向.常见的线性表结构：数组，链表、队列、栈等。 什么是非线性递归：比如二叉树遍历就是典型的非线性遍历结构 刷题指南 数据结构是工具，算法是通过合适的工具解决特定问题的办法 先刷二叉树，先刷二叉树，先刷二叉树， 为什么呢？ 因为二叉树是最容易培养框架思维的，而且大部分常考算法本质上都是树的遍历问题","categories":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Vue-nextTick原理","slug":"Vue-nextTick原理","date":"2020-12-14T16:00:00.000Z","updated":"2021-01-05T05:15:35.000Z","comments":true,"path":"2020/12/15/Vue-nextTick原理/","link":"","permalink":"http://mariogogogo.github.io/2020/12/15/Vue-nextTick%E5%8E%9F%E7%90%86/","excerpt":"1.了解nextTick的实现原理 2.了解数据变化到DOM的变化是异步过程","text":"1.了解nextTick的实现原理 2.了解数据变化到DOM的变化是异步过程 先了解下宏任务和微任务 常见**宏任务** setTimeout setInterval setImmediate script MessageChannel 常见**微任务** Promise MutationObserver Object.observe(废弃) process.nextTick（node） 12345Vue.nextTick = nextTick; //赋值给大Vue的静态方法//全局挂载 Vue.prototype.$nextTick = function (fn) &#123; return nextTick(fn, this)&#125;; 首先查看是否浏览器支持setImmediate还有Promise 123456789101112131415161718192021222324252627282930313233343536373839if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve(); timerFunc = function () &#123; p.then(flushCallbacks); if (isIOS) &#123; setTimeout(noop); &#125; &#125;; isUsingMicroTask = true;&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) var counter = 1; var observer = new MutationObserver(flushCallbacks); var textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true &#125;); timerFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125;; isUsingMicroTask = true;&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Technically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = function () &#123; setImmediate(flushCallbacks); &#125;;&#125; else &#123; // Fallback to setTimeout. timerFunc = function () &#123; setTimeout(flushCallbacks, 0); &#125;;&#125; nextTick123456789101112131415161718192021222324 callbacks = [] //缓存进数组function nextTick (cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125; //如果没有传cb 则返回promise 可以接.then（）方法 if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve) &#123; _resolve = resolve; &#125;) &#125; 通过判断 pending 来确定是否需要注册宏微任务 。 当第一次注册的时候，把 pending 设置为 true，表示任务队列已经在开始了，同一时期内无需注册了 然后在 任务队列 执行完毕之后，再把 pending 设置为 false（在 flushCallbacks 中） flushCallbacks1234567891011var callbacks = [];var pending = false;function flushCallbacks () &#123; pending = false; var copies = callbacks.slice(0); callbacks.length = 0; for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; 宏任务和 微任务 的回调，都是执行这个 flushCallbacks，这个方法作用： 1、复制一遍 callbacks 2、把 原来 callbacks 清空 3、遍历 复制的 callbacks ，然后逐个执行 一个有意思的小测试123456789101112131415161718192021222324252627data()&#123; retrun &#123; msg: &quot;This is NextTick Page&quot; &#125;&#125;change () &#123; this.msg = &quot;hello vue&quot; console.log(&#x27;sync:&#x27;,this.$refs.msg.innerText) // &#x27;This is NextTick Page&#x27; this.$nextTick(()=&gt;&#123; console.log(&#x27;nextTick&#x27;,this.$refs.msg.innerText) // &#x27;hello vue&#x27; &#125;) this.$nextTick().then(()=&gt;&#123; console.log(&#x27;promise&#x27;,this.$refs.msg.innerText) // &#x27;hello vue&#x27; &#125;) &#125;, change1 () &#123; this.$nextTick(()=&gt;&#123; console.log(&#x27;nextTick&#x27;,this.$refs.msg.innerText) // &#x27;This is NextTick Page&#x27; &#125;) this.msg = &quot;hello vue&quot; console.log(&#x27;sync:&#x27;,this.$refs.msg.innerText) // &#x27;This is NextTick Page&#x27; this.$nextTick().then(()=&gt;&#123; console.log(&#x27;promise&#x27;,this.$refs.msg.innerText) // &#x27;hello vue&#x27; &#125;) &#125;, 为什么会这样呢，因为callback函数会优先push进去$nextTick的cb函数，但这时候this.msg才开始重新赋值加入flushSchedulerQueue函数，重新渲染是再后面。所以第一个nextTick拿到的还是旧的值 总结nextTick是要把执行的任务推入到一个队列中，再下一个tick同步执行 数据改变后触发了渲染watcher的update，但是watcher的flush是再nexttIck后，所以重新渲染是异步的","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue-数组劫持监听原理","slug":"Vue-数组劫持监听原理","date":"2020-12-10T16:00:00.000Z","updated":"2021-01-05T05:07:36.000Z","comments":true,"path":"2020/12/11/Vue-数组劫持监听原理/","link":"","permalink":"http://mariogogogo.github.io/2020/12/11/Vue-%E6%95%B0%E7%BB%84%E5%8A%AB%E6%8C%81%E7%9B%91%E5%90%AC%E5%8E%9F%E7%90%86/","excerpt":"响应式数据中对于对象新增删除属性及数组的下标访问修改核添加数据等变化是观察不到的 通过Vue.set以及数组的Api可以解决这些问题本质上他们内部手动做了依赖更新的派发","text":"响应式数据中对于对象新增删除属性及数组的下标访问修改核添加数据等变化是观察不到的 通过Vue.set以及数组的Api可以解决这些问题本质上他们内部手动做了依赖更新的派发 为什么监听不了 从上面代码里，首先监听了model数组里所有的属性，然后通过各种数组的方法来修改当前数组，得出以下几个结论。 1、==直接修改数组中已有的元素是可以被监听的==。 2、数组的操作方法如果是操作已经存在的被监听的元素也是可以触发setter被监听的。 3、只有push、length、pop一些特殊的方法确实不能触发setter，这跟方法的内部实现与Object.defineProperty的setter钩子的触发实现有关系，是语言层面的原因。 4、==改变超过数组长度的下标的值时，值变化是不能监听到的==。这个其实很好理解，不存在的属性当然是不能监听到，因为绑定监听操作在之前已经执行过了，后添加的元素属性在绑定当时都还没有存在，当然没有办法提前去监听它了。 所以综上，Object.defineProperty不能监听到数组内的值变化的说法是错误的，同时也得出了a问题的答案，语言层面不支持用Object.defineProperty监听不存在的数组元素，并且通过一些能造成数组的方法造成数组改变也不能监听到。 Vue监听Array三步曲第一步：先获取原生 Array 的原型方法，因为拦截后还是需要原生的方法帮我们实现数组的变化。 第二步：对 Array 的原型方法使用 Object.defineProperty 做一些拦截操作。 第三步：==把需要被拦截的 Array 类型的数据原型指向改造后原型==。8888 123456789101112131415161718192021222324252627282930313233343536373839 const arrayProto = Array.prototype // 获取Array的原型function def (obj, key) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, value: function(...args) &#123; console.log(key); // 控制台输出 push console.log(args); // 控制台输出 [Array(2), 7, &quot;hello!&quot;] // 获取原生的方法 let original = arrayProto[key]; // 将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变 const result = original.apply(this, args); // do something 比如通知Vue视图进行更新 console.log(&#x27;我的数据被改变了，视图该更新啦&#x27;); this.text = &#x27;hello Vue&#x27;; return result; &#125; &#125;);&#125;// 新的原型let obj = &#123; push() &#123;&#125;&#125;// 重写赋值def(obj, &#x27;push&#x27;);let arr = [0];// 原型的指向重写arr.__proto__ = obj;// 执行pusharr.push([1, 2], 7, &#x27;hello!&#x27;);console.log(arr); 那必须想个办法–拦截器覆盖Array.prototype。 通过Vue.set可以解决这个问题，本质上内部手动去做了==依赖更新的派发== 拦截器 Array在getter中收集依赖，在拦截器中触发依赖 最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法： 1Object.setPrototypeOf(arr, injackingPrototype) 数组是一种特殊的对象，其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象。 但是 Vue 并没有采用上述方法劫持数组对象，笔者猜测主要由于以下两点：（读者有更好的见解，欢迎留言。） 1、特殊的 length 属性 数组对象的 length 属性的描述符天生独特： 12const arr = [1, 2, 3]Object.getOwnPropertyDescriptor(arr, &#x27;length&#x27;).configurable // false 这就意味着无法通过 Object.defineProperty() 方法劫持 length 属性的读取和设置方法。 相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。 2、数组的操作场景 数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。 3、数组方法的劫持 最终 Vue 选择劫持一些常用的数组操作方法，从而知晓数组的变化情况： 1const methods = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;] 数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 Array.prototype 对象。 但是这里不能直接篡改 Array.prototype 对象，这样会影响所有的数组实例，为了避免这种情况，需要采用原型继承得到一个新的原型对象： 1const arrayProto = Array.prototypeconst injackingPrototype = Object.create(arrayProto) 拿到新的原型对象之后，再重写这些常用的操作方法： 12345678910111213141516171819202122methods.forEach(method =&gt; &#123; const originArrayMethod = arrayProto[method] injackingPrototype[method] = function (...args) &#123; const result = originArrayMethod.apply(this, args) let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) &#123; // 对于新增的元素，继续劫持 // ob.observeArray(inserted) &#125; // 通知变化 return result &#125;&#125;) 最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法： 1Object.setPrototypeOf(arr, injackingPrototype) 顺便提一下，采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新。 12345678910111213141516171819202122232425//api:数组set方式数据改变function set (target, key, val) &#123; ............. //isValidArrayIndex 判断数组是有效的下标 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); // debugger return val &#125; ............. var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; return val &#125; if (!ob) &#123; target[key] = val; return val &#125; // 变成响应式对象 defineReactive(ob.value, key, val); // 通知依赖更新 ob.dep.notify(); return val&#125; defineReactive123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function defineReactive ( obj, key, val, customSetter, shallow) &#123; var dep = new Dep(); var property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return &#125; var getter = property &amp;&amp; property.get; var setter = property &amp;&amp; property.set; if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key]; &#125; var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; // debugger 如果下面没有依赖收集 则久不会更新 // ❤️❤️❤️❤️很关键 依赖收集 childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); &#125; &#125;);&#125; methodsToPatch1234567891011121314151617181920212223242526272829// 记录原始Array未重写之前的API原型方法const arrayProto = Array.prototype// 拷贝一份上面的原型出来const arrayMethods = Object.create(arrayProto)// 将要重写的方法const methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27; ]methodsToPatch.forEach(function (method) &#123; def(arrayMethods, method, function mutator (...args) &#123; // 原有的数组方法调用执行 const result = arrayProto[method].apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; // 如果是插入的数据，将其再次监听起来 if (inserted) ob.observeArray(inserted) // 触发订阅，像页面更新响应就在这里触发 ob.dep.notify() return result &#125;)&#125;) 手动调用:star::star::star: 1ob.dep.notify(); 为什么数组变化内部用splice 外部可以用push都可以改变 12target.splice(key, 1, val);this.array.push(100) //数组的添加 最后看看尤大的回答 12月更新–扩展一下Vue3.0的数组监听12345678910111213141516171819202122232425262728293031323334353637383940let model = &#123; name: &#x27;vue&#x27;, data: &#123; val: 1, &#125;, list: [1]&#125;function isObj (obj) &#123; return typeof obj === &#x27;object&#x27;;&#125;// 监控器function observe(data) &#123; // 将属性都做监控 Object.keys(data).map(key =&gt; &#123; if (isObj(data[key])) &#123; // 对象类型的继续监听它的属性 data[key] = observe(data[key]); &#125; &#125;) return defineProxy(data);&#125;// 生成Proxy代理function defineProxy(obj) &#123; return new Proxy(obj, &#123; set(obj, key, val) &#123; console.log(`属性$&#123;key&#125;变化为$&#123;val&#125;`); compile(obj, key, val); return Reflect.set(...arguments); &#125; &#125;)&#125;// 解析器，响应页面变化function compile(obj, id, val) &#123; if (Array.isArray(obj)) &#123; // 数组变化 document.querySelector(&#x27;#list&#x27;).value = model.list; &#125; else &#123; document.querySelector(`#$&#123;id&#125;`).value = val; &#125;&#125;model= observe(model);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue—Watch原理","slug":"Vue-Watch原理","date":"2020-12-08T16:00:00.000Z","updated":"2020-12-18T01:58:29.000Z","comments":true,"path":"2020/12/09/Vue-Watch原理/","link":"","permalink":"http://mariogogogo.github.io/2020/12/09/Vue-Watch%E5%8E%9F%E7%90%86/","excerpt":"今天分析下Watch的内部原理","text":"今天分析下Watch的内部原理 带着问题看源码 1、监听的数据改变的时，watch 如何工作 2、设置 immediate 时，watch 如何工作 3、设置了 deep 时，watch 如何工作 常见的api使用情况12345678910111213141516171819watch: &#123; //函数 useless(newValue) &#123; console.log(&#x27;useless&#x27;,newValue) &#125;, //对象 name:&#123; immediate:true, handler(newValue)&#123; console.log(&#x27;name&#x27;,newValue) &#125; &#125;, nestect:&#123; deep:true, handler(newValue)&#123; console.log(&#x27;nestect&#x27;,newValue) &#125; &#125; &#125;, 什么时候初始化12345678function initState (vm) &#123; vm._watchers = []; var opts = vm.$options; .... if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch); &#125;&#125; opts.watch !== nativeWatch的意思是不等于浏览器原生的watch，为什么要这样写？ 因为Firefox浏览器中Object.prototype中有个watch方法，如果用户没有设置watch，则opts.watch 将是Object.prototype.watch initWatch1234567891011121314function initWatch (vm, watch) &#123; for (var key in watch) &#123; //handler 类型是不确定的 可以是 对象 方法 字符串 数组 var handler = watch[key]; if (Array.isArray(handler)) &#123; //如果是数组遍历每一项来创建watcher for (var i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]); &#125; &#125; else &#123; createWatcher(vm, key, handler); &#125; &#125;&#125; createWatcher123456789101112131415function createWatcher ( vm, //vue实例 expOrFn, //表达式 或者 计算属性函数 handler, //回调函数 或者 字符串 options //传递给vm.$watch选项对象) &#123; if (isPlainObject(handler)) &#123; options = handler; handler = handler.handler; &#125; if (typeof handler === &#x27;string&#x27;) &#123; handler = vm[handler]; &#125; return vm.$watch(expOrFn, handler, options)&#125; watch 在一开始初始化的时候，会 读取 一遍 监听的数据的值，于是，此时 那个数据就收集到 watch 的 watcher 了 然后 你给 watch 设置的 handler ，watch 会放入 watcher 的更新函数中 当 数据改变时，通知 watch 的 watcher 进行更新，于是 你设置的 handler 就被调用了 $watch1234567891011121314151617181920212223 Vue.prototype.$watch = function ( expOrFn, cb, options ) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125;; options.user = true; // 代表watcher 为 userWatcher //创建watcher实例 这是一个 user watcher，因为 options.user = true var watcher = new Watcher(vm, expOrFn, cb, options); //immediate = true 则函数立即执行 if (options.immediate) &#123; cb.call(vm, watcher.value); &#125; return function unwatchFn () &#123; //销毁watcher函数 watcher.teardown(); &#125; &#125;;&#125; 1、判断是否立即执行监听回调 如果你设置了 immediate 的话，表示不用等我数据变化，初始化时马上执行一遍，执行的代码就是直接调用 回调，绑定上下文，传入监听值 2、每个 watch 配发 watcher new Watcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Watcher = function Watcher ( vm, expOrFn, cb, options, isRenderWatcher) &#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; this.user = !!options.user; this.computed = !!options.computed; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.computed = this.sync = false; &#125; this.cb = cb; this.id = ++uid$1; // uid for batching this.active = true; this.dirty = this.computed; // for computed watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = process.env.NODE_ENV !== &#x27;production&#x27; ? expOrFn.toString() : &#x27;&#x27;; // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = function () &#123;&#125;; ... &#125; &#125; if (this.computed) &#123; this.value = undefined; // 依赖收集 this.dep = new Dep(); &#125; else &#123; this.value = this.get(); &#125;&#125;; this.getter 的函数进行理解，他的本质是为了获取对象的key值. 当 watch.getter 执行，而读取了 vm.name 的时候，==name的依赖收集器就会收集到 watch-watcher== 1234567891011121314151617181920212223Watcher.prototype.get = function get () &#123; pushTarget(this); var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (&quot;getter for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;; Watch 在结尾会立即执行一次 watcher.get，其中便会执行 getter，便会根据你监听的key，去实例上读取并返回，存放在 watcher.value 上 deep深度监听12345678910111213141516171819202122232425262728293031323334 if (this.deep) &#123; traverse(value);&#125;function traverse (val) &#123; _traverse(val, seenObjects); seenObjects.clear();&#125;function _traverse (val, seen) &#123; var i, keys; var isA = Array.isArray(val); if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) &#123; return &#125; //判断值是否已经响应式 if (val.__ob__) &#123; var depId = val.__ob__.dep.id; if (seen.has(depId)) &#123; return &#125; seen.add(depId); &#125; //是否是数组 if (isA) &#123; i = val.length; while (i--) &#123; _traverse(val[i], seen); &#125; &#125; else &#123; //递归遍历对象 keys = Object.keys(val); i = keys.length; while (i--) &#123; _traverse(val[keys[i]], seen); &#125; &#125;&#125; 如果是深层级的对象，其中的每个属性也都是响应式的，每个属性都有自己的依赖收集器 通过不断深入的读取每个属性，这样每个属性就都可以收集到 watch-watcher 了 这样不管对象内多深的属性变化，都会通知到 watch-watcher 回调更新123456789101112131415161718192021222324252627282930313233343536373839Watcher.prototype.update = function update () &#123; if()&#123;&#125; else if (this.sync) &#123; this.run(); //同步执行 &#125; else &#123; queueWatcher(this); //先执行这里 &#125;&#125;Watcher.prototype.run = function run () &#123; if (this.active) &#123; this.getAndInvoke(this.cb); &#125;&#125;;//对比计算属性返回值Watcher.prototype.getAndInvoke = function getAndInvoke (cb) &#123; var value = this.get(); if ( value !== this.value || isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; this.dirty = false; if (this.user) &#123; try &#123; //执行回调函数 cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError(e, this.vm, (&quot;callback for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; &#125; else &#123; cb.call(this.vm, value, oldValue); &#125; &#125;&#125;; 总结watcher属性本质就是user watcher，它还支持deep，sync，immediate等配置，监听属性适合观察某个值得变化去完成一段复杂的业务逻辑。 如何实现watch监听？正是因为watch对应key是被数据拦截的属性，在选项watch下： 每一个key都会对应一个watcher对象 watcher对象的getter函数就是获取当前key对应的值，从而建立key对应Dep对象与当前watcher对象建立联系 当key改变时就会触发视图更新，从而执行key对应的回调函数","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"各种移动端Bug解决方案","slug":"各种移动端Bug解决方案","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-08T07:01:08.000Z","comments":true,"path":"2020/12/08/各种移动端Bug解决方案/","link":"","permalink":"http://mariogogogo.github.io/2020/12/08/%E5%90%84%E7%A7%8D%E7%A7%BB%E5%8A%A8%E7%AB%AFBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"各种移动端Bug解决方案持续更新各种移动端Bug解决方案","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"Vue—props原理","slug":"Vue-props原理","date":"2020-12-05T16:00:00.000Z","updated":"2020-12-17T06:42:26.000Z","comments":true,"path":"2020/12/06/Vue-props原理/","link":"","permalink":"http://mariogogogo.github.io/2020/12/06/Vue-props%E5%8E%9F%E7%90%86/","excerpt":"今天分析下props的内部原理","text":"今天分析下props的内部原理 带着问题看源码 1、父组件 怎么传值给 子组件的 props 2、子组件如何读取props 3、父组件 data 更新，子组件的props 如何更新 123456789101112131415161718192021222324252627//parent.vue&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;分析props&lt;/h1&gt; &lt;hello-world :msg=&quot;parentMsg&quot;&gt;&lt;/hello-world&gt; &lt;/div&gt;&lt;/template&gt;//child.vue&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;HelloWorld&#x27;, props: &#123; msg:&#123; type:String, default:&#x27;&#x27; &#125; &#125;&#125;&lt;/script&gt; 模板解析过程中，如果某个标签的名字是组件名，虚拟DOM渲染过程中会将子组件实例化，模板解析时候从标签属性上解析出数据当做参数传递给子组件，其中就包括props数据 123456789//解析父组件(function() &#123; with(this)&#123; return _c(&#x27;div&#x27;,&#123;staticClass:&quot;parent&quot;&#125;,[ _c(&#x27;h1&#x27;,&#123;attrs:&#123;&#125;&#125;) _c(&#x27;hello-world&#x27;,&#123;attrs:&#123;&quot;msg&quot;:parentMsg&#125;&#125;) ],1) &#125;&#125;) withwith 的作用是，绑定大括号内代码的 变量访问作用域 1234function test()&#123; with(this)&#123; console.log(parentName) &#125;&#125;test.call(&#123;parentName:&quot;测试名字&quot;&#125;) //测试名字 props的实现原理简单的理解：父组件提供数据，子组件通过props字段选择组件需要哪些内如，通过子组件props选项将需要的数据筛选出来添加到子组件的上下文中 normalizePropsVue.component()注册组件的时候会调用Vue.extend()生成一个Vue基础构造器，内部会调用mergeOptions函数合并属性， mergeOptions又会调用normalizeProps对props的属性进行一些规范化的修饰 1234567891011121314151617181920212223242526272829303132function normalizeProps (options, vm) &#123; var props = options.props; if (!props) &#123; return &#125; var res = &#123;&#125;; var i, val, name; //如果props是个数组 if (Array.isArray(props)) &#123; i = props.length; while (i--) &#123; val = props[i]; if (typeof val === &#x27;string&#x27;) &#123; name = camelize(val); //保存到res里面 例如:&#123; msg: &#123;type: null&#125; &#125; res[name] = &#123; type: null &#125;; &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; //...错误处理 &#125; &#125; //如果props是个对象 &#125; else if (isPlainObject(props)) &#123; for (var key in props) &#123; val = props[key]; name = camelize(key); res[name] = isPlainObject(val) ? val : &#123; type: val &#125;; &#125; &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; //...错误处理 &#125; options.props = res;&#125; 经过normalizeProps规范后，props被修饰为一个对象格式，例子里的执行到这里等于:&#123; msg: &#123;type: null&#125; &#125; 初始化123456789function Vue()&#123; initState(this)&#125;function initState(vm) &#123; var opts = vm.$options; if (opts.props) &#123; initProps(vm, opts.props); &#125;&#125; initPropsinitProps接受2个参：vm propsOptions。 第一个参是 vm实例。 第二个参是 规格化后的props选项。 12345678910111213141516171819202122232425262728293031function initProps (vm, propsOptions) &#123; var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; //缓存props的key var keys = vm.$options._propKeys = []; var isRoot = !vm.$parent; //如果不是根组件则变成响应式 if (!isRoot) &#123; toggleObserving(false); &#125; var loop = function ( key ) &#123; keys.push(key); var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; var hyphenatedKey = hyphenate(key); //...错误处理 defineReactive(props, key, value, function () &#123; //...错误处理 &#125; else &#123; defineReactive(props, key, value); &#125; if (!(key in vm)) &#123; //设置代理 把vm.x 访问 vm._props.x proxy(vm, &quot;_props&quot;, key); &#125; &#125;; for (var key in propsOptions) loop( key ); toggleObserving(true);&#125; 每一个 实例都会有 一个 _props 的同时，也会把属性直接放在 实例上。 propsData 保存通过父组件传入或者用户通过propsData传入的props数据 props 指向vm._props指针。所有设置到props变量中的属性保存到vm.props keys 指向 vm.$options._propskeys isRoot 判断是否是根组件 123function toggleObserving (value) &#123; shouldObserve = value;&#125; 上面的代码主要做了三件事 1、遍历 props 2、给 props 设置响应式 3、给 props 设置代理 (把vm.x 访问 vm._props.x) validateProp调用这个函数得到的props数据通过defineReactive函数设置到vm._props中，目的就是校验，就是检查一下我们传递的数据是否满足 prop的定义规范 123456789101112131415161718192021222324252627282930313233343536373839404142434445//执行validateProp检查propsData里的key值是否符合propsOptions里对应的要求，并将值保存到value里面function validateProp ( key, propOptions, propsData, vm) &#123; var prop = propOptions[key]; var absent = !hasOwn(propsData, key); var value = propsData[key]; // boolean casting var booleanIndex = getTypeIndex(Boolean, prop.type); if (booleanIndex &gt; -1) &#123; if (absent &amp;&amp; !hasOwn(prop, &#x27;default&#x27;)) &#123; value = false; &#125; else if (value === &#x27;&#x27; || value === hyphenate(key)) &#123; // only cast empty string / same name to boolean if // boolean has higher priority var stringIndex = getTypeIndex(String, prop.type); if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123; value = true; &#125; &#125; &#125; //✅✅✅检测如果 prop 没有定义 default 属性，那么返回 undefined，通过这块逻辑我们知道除了 Boolean 类型的数据，其余没有设置 default 属性的 prop 默认值都是 undefined。 if (value === undefined) &#123; value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy, // make sure to observe it. var prevShouldObserve = shouldObserve; toggleObserving(true); observe(value); toggleObserving(prevShouldObserve); &#125; if ( process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; // skip validation for weex recycle-list child component props !(false &amp;&amp; isObject(value) &amp;&amp; (&#x27;@binding&#x27; in value)) ) &#123; assertProp(prop, key, value, vm, absent); &#125; return value&#125; 主要就做 3 件事情： 处理 Boolean 类型的数据。 处理默认数据。 prop 断言，并最终返回 prop 的值。 proxy代理123456789101112function proxy( target, sourceKey, key) &#123; Object.defineProperty(target, key, &#123; get() &#123; return this[sourceKey][key] &#125;, set(val) &#123; this[sourceKey][key] = val; &#125; &#125;);&#125; 这段代码做了2 个事 1、使用 props 在 vm 上占位，使得可以通过 vm.xxx 的形式访问到 props 2、设置 [Object.defineProperty] 的 get 和 set ，间接获取和赋值 vm._props defineReactive响应式在 defineReactive 的时候会添加一个自定义 setter，当我们直接对 prop 赋值的时候会输出警告。 prop 的响应式有一点不同的是当 vm 是非根实例的时候，会先执行 toggleObserving(false)，它的目的是为了响应式的优化 Props 更新 如果是基本类型，是这个流程 父组件数据改变，只会把新的数据传给子组件 子组件拿到新数据，就会直接替换到原来的 props 替换就是直接等哈，看下源码，重要语句标红 123456789101112131415function updateChildComponent( vm, propsData) &#123; if (propsData &amp;&amp; vm.$options.props) &#123; // 保存 props 的地方，用于访问转接，具体看文章下面 var props = vm._props; // 所有子组件上设置的 props 的 key var propKeys = vm.$options._propKeys || []; for (var i = 0; i &lt; propKeys.length; i++) &#123; var key = propKeys[i]; props[key] = propsData[key] &#125; vm.$options.propsData = propsData; &#125;&#125; 如果是对象，是这个流程 父组件传 对象 给 子组件，并且父子组件 页面都使用到了这个数据 结果那么这个对象，会收集到 父子组件的 watcher 所以当 对象内部被修改的时候，会通知到 父和子 更新。 总结1、父组件 data 的值 和 子组件的 props 没有任何联系，更改 props 不影响父组件 data （其实也影响如果data是个对象） 2、props 也是响应式的，跟 data 本质 差不多 3、props 会访问转接，赋值转接 ，其实操作的是 vm._props 的属性","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue—响应式对象","slug":"Vue-响应式对象","date":"2020-12-03T16:00:00.000Z","updated":"2020-12-17T02:22:36.000Z","comments":true,"path":"2020/12/04/Vue-响应式对象/","link":"","permalink":"http://mariogogogo.github.io/2020/12/04/Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1/","excerpt":"被Object.defineProperty绑定过的对象，会变成「响应式」化。也就是改变这个对象的时候会触发get和set事件。进而触发一些视图更新","text":"被Object.defineProperty绑定过的对象，会变成「响应式」化。也就是改变这个对象的时候会触发get和set事件。进而触发一些视图更新 带着问题看源码 1、Vue 是怎么知道数据改变？ 2、Vue 在数据改变时，怎么知道通知哪些视图更新？ 3、Vue 在数据改变时，视图怎么知道什么时候更新？ Object.defineProperty123456789101112131415161718192021222324252627function defineReactive (obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; console.log(&#x27;我被读了，我要不要做点什么好?&#x27;); return val; &#125;, set: newVal =&gt; &#123; if (val === newVal) &#123; return; &#125; val = newVal; console.log(&quot;数据被改变了，我要把新的值渲染到页面上去!&quot;); &#125; &#125;)&#125;let data = &#123; text: &#x27;hello world&#x27;,&#125;;// 对data上的text属性进行绑定defineReactive(data, &#x27;text&#x27;, data.text);console.log(data.text); // 控制台输出 &lt;我被读了，我要不要做点什么好?&gt;data.text = &#x27;hello Vue&#x27;; // 控制台输出 &lt;hello Vue &amp;&amp; 数据被改变了，我要把新的值渲染到页面上去!&gt; Observer 「响应式」Vue中用Observer类来管理上述响应式化Object.defineProperty的过程。我们可以用如下代码来描述，将this.data也就是我们在Vue代码中定义的data属性全部进行「响应式」绑定。 1234567891011121314class Observer &#123; constructor() &#123; // 响应式绑定数据通过方法 observe(this.data); &#125;&#125; export function observe (data) &#123; const keys = Object.keys(data); for (let i = 0; i &lt; keys.length; i++) &#123; // 将data中我们定义的每个属性进行响应式绑定 defineReactive(obj, keys[i]); &#125;&#125; 源码中1234567891011121314151617181920212223242526272829303132333435var shouldObserve = true;function toggleObserving (value) &#123; shouldObserve = value;&#125;/** * 尝试为一个值创建一个观察者实例； * 如果成功观察到，则返回新观察者； * 如果该值已经具有一个观察者，则返回现有观察者。 */function observe (value, asRootData) &#123; // value是不是object 不能是vnode实例 if (!isObject(value) || value instanceof VNode) &#123; return &#125; var ob; //判断带不带 ob标识 if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; //全局控制 shouldObserve === false !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; //可扩展属性 !value._isVue //不是vue实例 ) &#123; ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++; &#125; return ob&#125; Observer1234567891011121314151617181920212223242526272829303132/** 附加到每个观察对象的观察者类。附加后， 观察者会将目标对象的属性键转换为用于收集依赖项并调度更新的getter / setter。 */var Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); //创建dep实例 后面再说先跳过 this.vmCount = 0; //目的 为valu添加ob标识 变成响应式 并且this指向当前实例 //下一次执行上面的hasOwn(value, &#x27;__ob__&#x27;) 直接true了 def(value, &#x27;__ob__&#x27;, this); if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods); &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys); &#125; this.observeArray(value); //遍历数组每一个元素 递归把他们都观察起来 &#125; else &#123; this.walk(value);//遍历对象每一个属性 &#125;&#125;; //enumerable 是不可枚举 如果不传则是 undefinedfunction def (obj, key, val, enumerable) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, //false 代表不可枚举 不能加入for循环 writable: true, configurable: true &#125;);&#125; 123456789101112131415161718 /** * 观察数组项的列表。 */ Observer.prototype.observeArray = function observeArray (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125; &#125;;/** * 遍历所有属性并将它们转换为* getter / setter。 * 仅当*值类型为Object时，才应调用此方法。 */ Observer.prototype.walk = function walk (obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive$$1(obj, keys[i]); &#125; &#125;; defineReactive$$1就是把对象变成响应式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Define a reactive property on an Object. */ function defineReactive$$1 ( obj, key, val, customSetter, shallow ) &#123; var dep = new Dep(); ... // 如果有childe 则递归调用observe var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); //依赖收集 if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (customSetter) &#123; customSetter(); &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); dep.notify(); //派发更新 &#125; &#125;); &#125; 响应式对象就是给它对象上的属性添加getter/setter,无论访问还是修改它都有一定的逻辑需要执行 总结1、data 中每个声明的属性，都会有一个 专属的依赖收集器 subs 2、当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue—DOM挂载机制","slug":"Vue-DOM挂载机制","date":"2020-12-02T16:00:00.000Z","updated":"2020-12-15T02:16:39.000Z","comments":true,"path":"2020/12/03/Vue-DOM挂载机制/","link":"","permalink":"http://mariogogogo.github.io/2020/12/03/Vue-DOM%E6%8C%82%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"Vue 中我们是通过 $mount 实例方法去挂载 vm 的","text":"Vue 中我们是通过 $mount 实例方法去挂载 vm 的 123456789101112131415import Temp from &#x27;./Temp.vue&#x27;;window.vm = new Vue(&#123; // el是实例挂载点，会将根组件替换掉原文档中id为 app 标签 el: &#x27;#app&#x27;, // 通过render函数渲染 render: h =&gt; &#123; // 这里App是根组件 h(App) &#125;&#125;)//Temp.vue&lt;div&gt; 这是消息：&#123;&#123;message&#125;&#125;&lt;/div&gt; initMixin1234567891011121314151617181920212223242526function initMixin (Vue) &#123; Vue.prototype._init = function (options) &#123; var vm = this; // a uid vm._uid = uid$3++; // a flag to avoid this being observed vm._isVue = true; // expose real self 初始化 vm._self = vm; /******************/ initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props /**************************/ callHook(vm, &#x27;created&#x27;); if (vm.$options.el) &#123; //跳转 10976行 vm.$mount(vm.$options.el); &#125; &#125;; $mount12345678910111213141516171819202122232425Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating)&#125;;var mount = Vue.prototype.$mount;Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; query(el); ... var options = this.$options; ... //如果没有render函数，那么获取模板将模板编译成渲染函数 if (!options.render) &#123; ... &#125; return mount.call(this, el, hydrating)&#125;; 我们将vue原型上的$mount方法保存在mount中。 然后Vue原型上$mount方法上被一个新的方法覆盖了。新方法会调用原始的方法，这种方法通常被称为函数劫持。通常函数劫持可以在原有功能的基础上新增其他功能 1234567891011121314function query () &#123; if (typeof el === &#x27;string&#x27;) &#123; var selected = document.querySelector(el); if (!selected) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;Cannot find element: &#x27; + el ); return document.createElement(&#x27;div&#x27;) &#125; return selected &#125; else &#123; return el &#125;&#125; query的主要作用是获取DOM元素 mountComponent$mount方法将id转换为dom元素后，使用mountComponent函数将Vue.js实例挂载到DOM上。 实例挂载到DOM上实际就是将模板渲染到指定DOM元素中。而且是持续性的，当状态发生改变，可以重新触发渲染到指定DOM元素中 12345678910111213141516171819202122232425262728293031323334353637383940414243function mountComponent ( vm, el, hydrating) &#123; vm.$el = el; if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; //开发环境会发出⚠️警告 &#125; &#125; // 执行生命周期beforeMount方法 callHook(vm, &#x27;beforeMount&#x27;); //定义方法 var updateComponent; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; ... &#125; else &#123; //挂载 updateComponent = function () &#123; //vm._render() ==&gt; 生成vnode 传入update vm._update(vm._render(), hydrating); &#125;; &#125; new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); hydrating = false; if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm //返回vm实例&#125; vm._update的作用调用虚拟DOM中patch方法去执行节点对比与渲染操作 vm._render()执行渲染函数得到一份最新的VNode节点树 ==先执行渲染函数得到一份最新的node节点，然后通过_update方法对最新的Vnode和旧Vnode进行对比并更新dom节点。== new Watcher1234567new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125;&#125;, true /* isRenderWatcher */); 在new Watcher中很重要的一步就是将updateComponent 赋值给watcher.getter 123456789101112131415var Watcher = function Watcher ( vm, expOrFn, cb, options, isRenderWatcher)&#123; if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); .....&#125; 挂载是持续性的，这个关键在于用new watcher，当它的第二个参数updateComponent 支持函数，它会同时观察函数中读取所有vue实例上的响应式数据 挂载完毕后还有执行mounted钩子函数 总结","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue-初始化原理","slug":"Vue-初始化原理","date":"2020-11-30T16:00:00.000Z","updated":"2020-12-15T02:12:32.000Z","comments":true,"path":"2020/12/01/Vue-初始化原理/","link":"","permalink":"http://mariogogogo.github.io/2020/12/01/Vue-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E7%90%86/","excerpt":"Vue的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。","text":"Vue的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。 12345678910111213function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125;initMixin(Vue);stateMixin(Vue);eventsMixin(Vue);lifecycleMixin(Vue);renderMixin(Vue); 构造函数中首先进行安全检查，然后进行_init初始化 _init1234567891011121314151617181920212223242526function initMixin (Vue) &#123; Vue.prototype._init = function (options) &#123; var vm = this; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ... vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // 在数据/道具之前解决注入问题 initState(vm); initProvide(vm); // 解决提供数据/道具后的问题 callHook(vm, &#x27;created&#x27;); //如果没有el选项，它就处于未挂载状态，没有关联的dom， if (vm.$options.el) &#123; //调用mount挂载vm，渲染成真实dom vm.$mount(vm.$options.el); &#125; &#125;&#125; 当函数initMixin被调用，会向vue构造函数的prototype属性添加init方法，当执行new Vue(),就会调用_init方法，该方法实现一系列初始化操作，包括生命周期，及响应式系统流程的启动等 mergeOptions这个函数的目的将用户传递的options,与当前构造函数的options及==父级实例==构造函数的options合并成一个新的options 赋值给$options属性， 为什么会有父级？ 因为vue.js可能是一个子组件 初始化事件与属性后触发生命周期beforeCreate， 随后初始化provide/inject和state后触发created callHook函数原理12345678910111213141516171819function callHook (vm, hook) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget(); var handlers = vm.$options[hook]; if (handlers) &#123; for (var i = 0, j = handlers.length; i &lt; j; i++) &#123; //捕获钩子函数发生的错误 js单线程如果错误了就会停止往下执行 try &#123; handlers[i].call(vm); &#125; catch (e) &#123; handleError(e, vm, (hook + &quot; hook&quot;)); &#125; &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook); &#125; popTarget();&#125; callHook的作用是触发用户设置生命周期钩子，而用户设置的生命周期钩子会在new Vue（）通过参数传递给vue，可以通过options参数得到用户设置的生命周期钩子（vm.$options.created获取到的是一个数组，数组包含钩子函数） 为什么生命周期函数钩子转换成数组？我们知道在Vue.mixin中也可以写入生命周期钩子，如果与一个组件一起混用，需要同时触发2个生命周期函数，而转成数组后，可以在同一个生命周期钩子列表中保存多个生命周期钩子 123456789101112131415161718192021var mixin = &#123; created: function () &#123; console.log(&#x27;混入对象的钩子被调用&#x27;) &#125;&#125;export default mixinimport mixin from &#x27;./mixin&#x27;export default &#123; mixins:[mixin], name:&quot;temp&quot;, data()&#123; return &#123; msg:&quot;hello vue&quot; &#125; &#125;, created() &#123; console.log(&#x27;created&#x27;) &#125;,&#125; 总结 各种初始化逻辑我们先不看。在初始化的最后，检测到如果有el属性，则调用vm.$mount方法挂载vm，挂载的目标就是==把模板渲染成最终的 DOM==","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"为什么要有一个好的架构","slug":"为什么要有一个好的架构","date":"2020-11-14T16:00:00.000Z","updated":"2020-12-09T05:37:59.000Z","comments":true,"path":"2020/11/15/为什么要有一个好的架构/","link":"","permalink":"http://mariogogogo.github.io/2020/11/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%9E%B6%E6%9E%84/","excerpt":"1、为什么要有一个好的架构 首先明确一点，架构是为需求服务的。","text":"1、为什么要有一个好的架构 首先明确一点，架构是为需求服务的。 前端架构存在的目的，就我个人理解来说，有以下几点： 1、提高代码的可读性。一个好的架构，代码的可读性一定是很强的。简单来说，假如有一个新人加入团队，那么他接手这个项目，一定是容易上手的，能简单轻松的了解整个前端部分的相互关系，从而找到自己需要重点关注的点。而不是需要花很多时间去熟悉这个项目的很多细节，才能开始上手做东西。就文件来说，可以从文件名上，分清哪些是页面、哪些是逻辑、哪些是样式、哪些是可以复用的组件、哪些是图标组、又有哪些是移动端或是PC端专享的样式/逻辑等。就代码来说，包括统一的命名风格，封装在同一个文件里的代码的相关性足够强等。 2、提高代码的可维护性。一个好的架构，一定是易于维护的，例如在新增需求、更改需求、修正bug，都不会造成意料之外的变化，比如说修改了一个页面组件的内容，却导致另外一个页面组件发生变化（这也太坑了）。因此，要低耦合，高内聚，以及输入和输出是可预期的。 3、提高代码的可扩展性。一个好的架构，一定扩展性要强，不能写死。需求变更太TM正常了，新增需求也太TM正常了。因此好的架构，必须要考虑到这些情况的发生，因为他们是一定会发生的。所以，一定要避免把代码写死。比如页面组件A里需要有一个日历组件，而这个日历组件引用的是别人的（比如从github上找的）。那么尽量不要直接在页面组件A里面直接引用这个日历组件，而是将写一个日历组件B，在这个日历组件B里封装你引用的日历组件C，然后通过这个日历组件B来进行操作。原因很简单，假如某天产品经理说，这个日历组件太丑了，我们换一个吧。如果你直接在页面组件A里内嵌这个引用的日历组件C，你很可能就要改很多代码（因为不同日历组件的使用方法和暴露的接口可能不同）。假如你还在其他多个地方引用了这个日历组件，那就更糟糕了！每个地方都要改。而若是将引用的日历组件C封装到自己写的日历组件B之中，那么你只需要改日历组件B里的相应代码即可，而因为日历组件B暴露的接口是不变的，那么自然不用修改页面中的代码了。 附图，以日历组件为例，是否考虑到扩展性的结果 未考虑到扩展性 考虑到扩展性： 4、便于协同。包括前端和后端的协同，前端和前端之间的协同。具体来说，前后端的协同通常是以ajax为交互，那么应至少有一个用于专门封装了所有ajax请求的文件，所有ajax请求都封装在这里。在开发时，这里封装的方法应该可以模拟发送和接收约定好的交互内容，方便开发联调。而前端和前端的协同，主要体现在同时在更改代码时，不会影响对方代码的正常运行。因此要求封装、解耦以及低干扰度是必须的。 5、自动化自动打包，压缩，混淆，如果有必要，再加上自动单元测试。 总结：总结来说，一个好的架构的目的是，让前端写代码写的舒服，让后端联调的舒服，让产品经理改需求改的舒服。 2、我如何设计架构 我不敢说自己的架构是好的架构（显然不是啦），只能分享自己最近做的一个项目，它的架构的如何做的。 首先，确定需求： 1、一个中小型网站，同时面向移动端和PC端（单端大概15个页面，算上弹窗大约20个）。2、预算有限（给的钱少），开发时间有限（一个月）。3、可能存在一定程度上的需求变更（比如增加页面或修改某些页面内容）。4、客户可能不太在乎优化（但是我自己在乎啊！）5、要求兼容IE9以上。 其次开始决定： 1、兼容IE9以上说明可以使用主流框架，而无需必须使用jquery。因此我采用了vue，版本是2.0；2、预算有限，时间有限，因此PC端和移动端共html和js，独立css。3、页面有限，因此无需将架构层级划分的比较细，只需要按其类型划分即可；4、根据原型图来看，页面复杂程度有限，复用部分不是很多，因此可以确定哪些东西需要封装复用，哪些比较复杂需要独立封装，哪些比较简单为了简化开发难度可以直接耦合。5、自己比较熟练单页面网站，因此采用以单页面为主，异步加载其他页面的形式。 于是使用相关配套的东西，比如webpack，vue-router等，另外为了开发和生产的方便性，采用以下模式进行开发。 第三，划分功能。 首先有一个根html，用户需要通过访问它来加载我们的js逻辑，因此js逻辑的代码被写在main.js之中。 在main.js之下，我们的前端代码可以被划分为三部分： 组件树； 功能模块； 各种资源； 如下图： 功能划分好之后，相同功能的放在同一个文件夹下，命名风格应该类似。 具体来说，组件树相关的东西，通常是以.vue结尾，放置在components文件夹下；资源，有图片或者国际化资源等，以.png或者.js或.json结尾，放置在resources文件夹下；而功能插件、服务等，因为可能被多处引用，因此为了方便引用，放在src文件夹下，并且该文件夹是components文件夹和resources文件夹的上级文件夹； 第四、细化功能模块 功能、组件树以及资源，我们已经明确了有哪些东西，那么接下来，我们要明确这些东西该如何以文件的形式来划分。 如下图： 1、项目构建相关 因为要使用vue.js，也要使用es6语法，因此babel是必须的；又因为要自动化混淆打包，因此webpack也是必须的；最后因为要方便多人协同，因此npm的package.json的配置，方便不同人可以快速自动化通过npm install来安装依赖，也是必须的； 2、CDN相关 而又因为我们要采用外部字体（需求要求引入非常见字体），因此CDN加速是必须的，该字体文件放在html中来配置引用即可； 3、配置和插件 我们需要直接引入一些插件和配置文件；为了使用vue，我们需要一个根组件，那么就是App.vue；使用vue-router，我们需要配置路由文件，因此router-config.js这个路由配置也是必须的；然后我们还需要以插件形式引入一些功能和服务，因此有了Plugin-开头的若干个vue插件，这些都是根据需要封装好的低耦合高内聚方法； 4、需要的npm依赖 当然，要使用vue肯定要引入vue.js；类似的还有vue-router.js和各种兼容性polyfill和全局插件； 5、抽离出的功能模块 除了直接引用的这些插件，我们还有一些和项目高度耦合的功能服务，我认为不能作为插件，但依然需要抽离出来封装好，方便使用和修改；如封装ajax请求的ajax.js，所有的ajax请求都放置其中，只对外暴露接口，方便管理和使用；又如实时国际化功能的组件LanguageManager.js，他需要引入国际化资源和管理国际化资源的加载；又例如实现跨组件通信的event-bus.js又比如管理用户信息的user.js 6、总结 而这些划分，都体现在上图之中。这就是src目录下的功能模块文件，我们需要的绝大多数功能都可以包括在其中，我们只需要按照实际开发中的需要，将对应的功能写入在这些文件中并引用即可； 第五、组件树 之前谈了功能模块的划分，接下来是组件树； 因此是中小型页面，因此组件树的层级无需太深，但该抽离出来的依然还是要抽离，尽量保证抽离出来的组件解耦以及一个页面组件的逻辑不要太多； 如下图： 0、根组件 所有组件最终往上找，都会找到共同的根组件App.vue，根组件只负责管理他的直接子组件；每个组件都只负责管理自己的直接子组件，不跨级管理，并且不依赖于自己的子组件（否则可能因为子组件的未加载或错误而导致父组件错误），做到解耦和内聚； 1、弹窗dialog和弹窗tips 因为弹窗dialog和弹窗提示tips可能同时存在，因此将其划分为2个组件，方便管理； 2、未登录页面和登录页面 因为页面存在登录和未登录状态，而为了加载速度考虑，当未登录时，不加载已登录页面，因此需要划分出来，并进行异步加载处理； 3、未登录页面 未登录页面又分为三种情况：1、初始页面：毫无疑问要直接加载2、登录弹窗：点击登录时加载（异步）3、注册弹窗：点击注册时加载（异步）之所以分拆开，是因为根据需求，已登录用户刷新页面，可以直接进入登录后页面，因此无需登录和注册，这种处理可以减少流量消耗，提升加载页面加载速度（特别是注册弹窗需要加载的内容还比较多）； 4、已登录页面 已登录页面有较多页面，采用默认加载初始页，然后异步加载其他页面（访问时）； 5、弹窗dialog 由于逻辑较少，代码量不多，因此为了方便管理，统一将其合并在一个vue文件中，共同相同的打开逻辑，根据传递的key决定打开哪一个。这样在新增弹窗时，无需再去写弹窗的打开、关闭逻辑。假如有较复杂的弹窗，可以以子组件的形式引入到当前vue文件中，如此也方便管理； 6、国际化管理 和页面高耦合，负责加载对应的国际化资源，并进行切换管理； 7、页面组件 可能有子页面和复用的组件，按照正常方式引用即可。 8、样式文件 可以独立写为.css文件，但因为我的公共样式文件比较少，因此我还是将其放在一个.vue文件中，并在App.vue里来引用 8、页面组件起名 通常以.vue为结尾，除了国际化LanguageManager.js因为高耦合度，因此以.js结尾并是一个单独的vue实例，表示他更像是一个功能模块，而不是一个vue的页面组件； 基础页面，如登录和未登录页面，公共组件（并且是header和footer这种），以**base-**开头；弹窗统一以**box-**为开头;可复用的组件以**extend-**开头；引入的外部组件以**import-**开头；普通页面组件以**page-**开头（这些页面往往是一个独立的页面，并且挂靠在登录或未登录页面下）；注册弹窗因为逻辑比较复杂，并且同类较多，因此以register-为开头； 通过以文件名来划分，不同的页面组件之间的区分可以说是一目了然，同时也方便管理； 3、还没有谈到的内容 想了想，目前还没有谈到的内容有以下几点： 1、路由：以路由为驱动来写页面，似乎是一种不错的选择；好处是只需要通过查看路由的配置文件router-config.js，就可以了解页面组件的架构；不过我自己关于vue-router的实践经验比较少，因此就略过不谈了； 2、单元测试：按道理说，单元测试是非常有必要的，因此在进行架构设计时，必须考虑到这一点；不过作者我目前在的公司关于前端方面都不太正规，实在没这方面的经验，又因为作者我本人转行做前端的时间也比较短，虽然周周9.12.7，但也没来得及学习这方面的知识（没有需求驱动，这方面动力不足哈哈） 3、自动化配置：关于webpack的自动化，是前端架构的重要组成部分，因此配置也是蛮重要的；不过一是这方面需要很多笔墨的，二是网上也有一些别人分享的文章（肯定比我的好），所以我这里就不细说了； 4、一些自动化工具：依然尴尬，没有大厂经验，路子比较野，所以大厂专有的一些工具是木有的，而自己找的话又嫌麻烦，所以没有优化到极致，只做到了基本满足目前项目需求的程度，见谅见谅；等以后有这方面经验的话我再写博客来分享吧~","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"记一次服务器数据被黑 😂","slug":"数据Moogose被黑","date":"2020-09-16T07:13:48.000Z","updated":"2021-02-18T06:13:36.000Z","comments":true,"path":"2020/09/16/数据Moogose被黑/","link":"","permalink":"http://mariogogogo.github.io/2020/09/16/%E6%95%B0%E6%8D%AEMoogose%E8%A2%AB%E9%BB%91/","excerpt":"幸亏这次丢失的数据不多，也只是自己个人的测试数据，如果是公司的商用数据库数据，那被勒索多少 BTC 也得给啊 😁","text":"幸亏这次丢失的数据不多，也只是自己个人的测试数据，如果是公司的商用数据库数据，那被勒索多少 BTC 也得给啊 😁 服务器又一次被恶意攻击，MongoDB 被删库 查看版本信息12345678910mongo --versionMongoDB shell version v4.0.6git version: caa42a1f75a56c7643d0b68d3880444375ec42e3OpenSSL version: OpenSSL 1.0.1f 6 Jan 2014allocator: tcmallocmodules: nonebuild environment: distmod: ubuntu1404 distarch: x86_64 target_arch: x86_64 重新卸载1234567停止服务：sudo service mongod stop删除软件包：sudo yum erase $(rpm -qa | grep mongodb-org) 删除数据和日志目录：sudo rm -r /var/log/mongodb（日志）sudo rm -r /var/lib/mongo（数据） 安装重启服务1234567891011#安装sudo apt-get install -y mongodb-org# 开启服务sudo service mongod start# 停止服务sudo service mognod stop# 重启服务sudo service mongod restart 连接1mongo; 配置文件信息123456dbPath=。。。 #数据文件存放目录path=。。。 #日志文件存放目录port=27017 #端口号fork=true #以守护程序的方式启用,即在后台运行logappend = true #日志以追加的形式添加bind_ip = 0.0.0.0 #可以访问的地址. 127.0.0.1表示自己访问, 0.0.0.0 表示所有人都能访问 修改端口1234567891011121314修改etc/mongod.conf文件内的配置信息net: port: 12345 //端口号 bindIp: 127.0.0.1,1**.16*.1**.18 //内网 # 重启服务sudo service mongod restart提示mongod stop/waitingmongod start/running, process 19206//连接MongoDB并指定端口mongo 192.168.1.100:12345 限制端口访问想要实现： 限制外网访问 mongo，只允许特定的 IP 进来访问 mongo 的话，则： Mongo 的配置中，是无法实现这个效果的。 只能换用其他办法，比如： 通过设置防火墙，添加： 只允许某些 IP，入网方向，能够访问 mongo 的对应的端口 从而禁止掉其他的 IP 访问 mongo 而此处的阿里云的 ECS 服务器中，可以通过设置安全组，实现和防火墙一样的效果。 具体设置办法： 进去阿里云控制后台-》云服务器 ECS-》安全组-〉你的 ECS 服务器所在的区域-》对应的 ECS 服务器-〉配置规则： 增加 2 个规则： （1）规则 1： 允许特定的 IP（单个 IP，某个 IP 地址段（内的所有的 IP），某几个 IP）允许访问某端口 （2）规则 2：禁止掉，其他的 IP 访问该端口 配置管理员账号12345678910111213141516171819202122232425# 切换到 admin 数据库use admin# 创建用户db.createUser(&#123;user: &#x27;tanya&#x27;, pwd: &#x27;tanya&#x27;, roles: [&#123;role: &#x27;userAdminAnyDatabase&#x27;, db: &#x27;admin&#x27;&#125;]&#125;)# 授权db.auth(&#x27;tanya&#x27;, &#x27;tanya&#x27;)# 切换到其他数据库use dream-wall# 创建用户db.createUser(&#123;user: &#x27;tanya_dream-wall_runner&#x27;, pwd: &#x27;tanya&#x27;, roles: [&#123;role: &#x27;readWrite&#x27;, db: &#x27;dream-wall&#x27;&#125;]&#125;)db.createUser(&#123;user: &#x27;tanya_dream-wall_wheel&#x27;, pwd: &#x27;tanya&#x27;, roles: [&#123;role: &#x27;read&#x27;, db: &#x27;dream-wall&#x27;&#125;]&#125;)# 修改配置，开启授权sudo vi /etc/mongod.confsecurity: authorization: &#x27;enabled&#x27;# 重启 mongo 服务，使配置生效sudo service mongod restart 需要注意的是：每次要进行数据库操作都需要先进行授权 db.auth(‘tanya’, ‘tanya’) 123456# 登录到指定数据库，无需授权mongo 127.0.0.1:xx/dream-wall -u tanya_dream-wall_runner -p tanya# 验证一下show tablesdb.dreams.find() 总结安全事故猛于虎这里给再次给自己也给大家提个醒，安全事故猛于虎，安全责任重于山。 一定不要为了图方便，就忽略某些安全配置，平时做什么都要有安全意识。 重要数据及时备份。 服务器设置 IP 黑白名单，关闭一切可以关闭的端口 如果跟我似的，访问服务的 ip 经常变，可以考虑修改一些服务的默认端口，增加被扫到的概率 一定要设置密码，为了防止被爆，最好是无规则的强密码 参考https://blog.csdn.net/dandanfengyun/article/details/95497728 https://www.crifan.com/mongodb_add_restrict_ip_access/ https://www.bbsmax.com/A/x9J238pM56/ https://github.com/savoygu/blog/blob/master/博客/Node.js项目线上服务器部署与发布/Node.js项目线上服务器部署与发布.md#52-修改-mongodb-默认端口","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"},{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"前端自动化部署之Shell","slug":"前端自动化部署之Shell","date":"2020-05-31T16:00:00.000Z","updated":"2020-12-08T07:00:49.000Z","comments":true,"path":"2020/06/01/前端自动化部署之Shell/","link":"","permalink":"http://mariogogogo.github.io/2020/06/01/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B9%8BShell/","excerpt":"众所周知前端是一个不善言辞并不会使用cmd的的一类人，开个玩笑！！！","text":"众所周知前端是一个不善言辞并不会使用cmd的的一类人，开个玩笑！！！ 前端项目发布流程 开发新功能啦 -&gt; 切新分支 git ck -b newBranch 开发完成后 -&gt; 提交代码 git add . git commit -m &#39;msg&#39; 合并到内外侧分支 -&gt; 合并到 Rel 内外侧分支 git marge rel 就拿 Vue React 项目来说，发布测试之前我们还需要将之前生产的代码给删除，不然体积会越来越大 rm -rf /linux目录路径~当前项目/* 发布内外侧（还有个预发布），build - FileZilla | ZOC7 - 上传 不管你是拖拽，还是linux命令都可以，开心就好嘛 上面就是发布一个新功能的流程，可想而知，你让我一天做一次还能接受，要是隔几分钟来一次谁受得了？当然现实就是这样的操作隔几分钟就会来一次！！！并且同时改几个项目也是存在的，所以，这种操作要把人整神… 说个故事有一天我开发了一个功能，按照上面流程把代码发布到了内外侧，这时候测试姐姐测试了，发现我把登录写成登陆了，通知到我，你有一个超级严重的bug，需要现在改，改好就传，我收到这条指令，菊花不由得一紧，我当机立断切换分支，改起我的代码来，时间一分一秒过去，在一分钟的时间内我就改完bug，毕竟拧螺丝非常简单。 该上传代码了，上传操作用了我10分钟，在测试姐姐看来，我修改这个代码用了11分钟，测试姐姐心里肯定就在想这个菜逼，改个字要这么久？我等着这么烦，后面给他打分往低了打，哼~~，让某某前端崽儿拿不到奖金。 我也很无奈啊！！！ Shell神器其实有很多后端在用的东西，前端都能拿来减少自己平时开发的重复工作，Shell就是其中一种。 关于Shell知识的话，很多教程啦，去学习吧，我把我的脚本拿出来和大家交流交流。 我的自动化脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/bin/bash# 在&quot;set -e&quot;之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出，那么就可以避免一些脚本的危险操作。set -eecho &quot;shell脚本本身的名字: $0&quot;echo &quot;传给shell的第一个参数: $1&quot;echo &quot;传给shell的第二个参数: $2&quot;#获取当前分支branch=$(git symbolic-ref --short HEAD)#获取当前分支完整路径echo -e $(git symbolic-ref HEAD)# refs/heads/masterecho -e $(git symbolic-ref --short HEAD)# masterif [ &quot;$1&quot;x != &quot;devx&quot; ] &amp;&amp; [ &quot;$1&quot;x != &quot;testx&quot; ] &amp;&amp; [ &quot;$1&quot;x != &quot;prex&quot; ]&amp;&amp; [ &quot;$1&quot; != &quot;master&quot; ];then echo -e &quot;\\\\033[41;37m 不存在 $1 环境 只有 -&gt; dev(内测) test(外侧) pre(预发布) \\\\033[0m&quot; exitfi# 链接服务器function devFn() &#123; ssh -p 22 root@120.27.2x0.xxx rm -rf /home/chan/koa2/* echo -e &quot;\\\\033[32m 连接成功，开始上传代码....... \\\\033[0m&quot; #rsync 三种模式：本地模式、ssh 模式、rsync 模式。 #rsync -e &quot;ssh -p 1876&quot; --exclude=storage -a /Users/lovewcc/Documents/04_Vue/easy-vue/dist/* root@120.27.220.173:/home/chan/koa2/ rsync -avz -e ssh /Users/lovewcc/Documents/04_Vue/easy-vue/dist/* root@120.27.220.173:/home/chan/koa2/ echo -e &quot;\\\\033[32m 上传成功,预览试试吧 \\\\033[0m\\\\n&quot;&#125;function testFn() &#123; ssh -p 端口 root@ip rm -rf 服务器项目路径/* echo -e &quot;\\\\033[32m 连接成功，上传代码中... \\\\033[0m&quot; rsync -e &quot;ssh -p 873&quot; --exclude=storage -a 本地代码路径/dist/* root@ip:服务器项目路径/ echo -e &quot;\\\\033[32m 外侧上传成功 \\\\033[0m\\\\n&quot;&#125;function preFn() &#123; echo &quot;执行链接预发布服务器&quot;&#125;function build() &#123; # cd source if [ &quot;$1&quot; == &quot;master&quot; ];then echo -e &quot;\\\\033[32m&quot;$1&quot;支打包开始 \\\\033[0m&quot; yarn run build else [ &quot;$1&quot;x == &quot;testx&quot; ] yarn run build:$1 fi echo -e &quot;\\\\033[32m 打包完毕 \\\\033[0m&quot; echo -e &quot;\\\\033[32m 连接 $1 服务器 \\\\033[0m&quot; if [ &quot;$1&quot; == &quot;master&quot; ];then devFn elif [ &quot;$1&quot;x == &quot;devx&quot; ];then devFn elif [ &quot;$1&quot;x == &quot;testx&quot; ];then testFn elif [ &quot;$1&quot;x == &quot;prex&quot; ];then preFn else echo -e &quot;\\\\033[41;37m 应该不会走到这里来吧... \\\\033[0m&quot; exit fi&#125;#判断是否是rel分支if [ $&#123;branch&#125; == &quot;master&quot; ];then echo -e &quot;\\\\n\\\\033[32m 当前在rel分支\\\\n 不出意外应该刚发布过内测\\\\n 所以无需执行git操作\\\\n 所以是否直接发布 $1 环境\\\\033[0m&quot; read -p $&#x27;\\\\n\\\\033[31m是否直接打包上传？y or n: \\\\033[0m&#x27; isbuild if [ &quot;$isbuild&quot; != &#x27;y&#x27; ];then exit fi build $1else #此sh脚本只适用于单子发布rel环境,提醒 echo -e &quot;\\\\n\\\\033[31m dev(内测) test(外侧) pre(预发布) \\\\033[0m&quot; echo -e &quot;\\\\033[31m 当前需要发布 $1 环境 \\\\033[0m&quot; #询问是否继续发布当前环境 read -p $&#x27;\\\\n\\\\033[31m是否继续操作？y or n: \\\\033[0m&#x27; isVersion if [ &quot;$isVersion&quot; != &#x27;y&#x27; ];then exit fi echo -e &quot;\\\\n\\\\033[32m 已确认环境 \\\\033[0m\\\\n&quot; echo -e &quot;\\\\033[31m $1 环境，当前分支为： $&#123;branch&#125; \\\\033[0m&quot; #确认当前分支，是否继续 read -p $&#x27;\\\\n\\\\033[31m请确认分支，是否继续操作？y or n: \\\\033[0m&#x27; isContinue if [ &quot;$isContinue&quot; != &#x27;y&#x27; ];then exit fi echo -e &quot;\\\\n\\\\033[32m 已确认分支，分支为 -&gt; $&#123;branch&#125; \\\\033[0m\\\\n&quot; echo -e &quot;\\\\033[32m 开始提交 $&#123;branch&#125; 分支代码，执行 add commit \\\\033[0m\\\\n&quot; git add . read -p $&#x27;\\\\n\\\\033[31m请输入本次commit信息：\\\\033[0m&#x27; commitInfo git commit -m $&#123;commitInfo&#125; echo -e &quot;\\\\033[32m 开始切换分支 \\\\033[0m\\\\n&quot; git checkout rel echo -e &quot;\\\\033[32m 开始拉取 rel origin \\\\033[0m\\\\n&quot; git pull origin rel echo -e &quot;\\\\033[32m 开始 merge 修改至 rel \\\\033[0m\\\\n&quot; git merge $&#123;branch&#125; #判断merge是否成功 if [ $? == 0 ];then echo -e &quot;\\\\033[32m merge $&#123;branch&#125; -&gt; rel 成功 \\\\033[0m\\\\n&quot; echo -e &quot;\\\\n\\\\033[32m 开始推送 rel 至远端 origin \\\\033[0m\\\\n&quot; git push origin rel echo -e &quot;\\\\n\\\\033[32m 推送 rel 至远端 origin 成功 \\\\033[0m\\\\n&quot; echo -e &quot;\\\\n\\\\033[32m 执行打包 \\\\033[0m\\\\n&quot; build $1 else echo -e &quot;\\\\033[31m merge失败，请检查 \\\\033[0m&quot; exit fifi 使用1./shell.sh","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"vue中设置页面切换时的过渡动画","slug":"vue中设置页面切换时的过渡动画","date":"2020-04-14T16:00:00.000Z","updated":"2020-12-09T07:59:10.000Z","comments":true,"path":"2020/04/15/vue中设置页面切换时的过渡动画/","link":"","permalink":"http://mariogogogo.github.io/2020/04/15/vue%E4%B8%AD%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E6%97%B6%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/","excerpt":"vue中设置页面切换时的过渡动画","text":"vue中设置页面切换时的过渡动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 页面切换动画transitionName --&gt; &lt;transition :name=&quot;transitionName&quot;&gt; &lt;!-- 缓存数据 &lt;router-view&gt; --&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;transition :name=&quot;transitionName&quot;&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; name: &quot;App&quot;, data() &#123; return &#123; transitionName: &quot;&quot; &#125;; &#125;, create() &#123;&#125;, mounted() &#123; if (document.body.scrollHeight &gt;= document.documentElement.clientHeight) &#123; document.body.style.height = document.body.scrollHeight + &quot;px&quot;; &#125; else &#123; document.body.style.height = document.documentElement.clientHeight + &quot;px&quot;; &#125; &#125;, /* 页面切换动画 */ watch: &#123; //使用watch 监听$router的变化 $route(to, from) &#123; //console.log(&quot;to=&quot; + to.meta.index, &quot;from=&quot; + from.meta.index); //(1) 如果to的索引值为0，不添加任何动画；如果to索引大于from索引,判断为前进状态,反之则为后退状态 if (to.meta.index &gt; 0) &#123; if (to.meta.index &lt; from.meta.index) &#123; this.transitionName = &quot;slide-right&quot;; &#125; else &#123; this.transitionName = &quot;slide-left&quot;; &#125; &#125; else if (to.meta.index == 0 &amp;&amp; from.meta.index &gt; 0) &#123; this.transitionName = &quot;&quot;; &#125; //(2) 当然，如果你没有需要设置索引值为0的页面可以直接用着一段 // if (to.meta.index &lt; from.meta.index) &#123; // this.transitionName = &quot;slide-right&quot;; // &#125; else &#123; // this.transitionName = &quot;slide-left&quot;; // &#125; &#125; &#125;, methods: &#123;&#125;&#125;;&lt;/script&gt; &lt;style&gt;* &#123; margin: 0; padding: 0;&#125; html,body &#123; height: 100%;&#125; #app &#123; height: 100%; width: 100%;&#125; /********页面切换动画 *********/.slide-right-enter-active,.slide-right-leave-active,.slide-left-enter-active,.slide-left-leave-active &#123; /* will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置 */ will-change: transform; transition: all ease 0.4s; -webkit-transition: all ease 0.4s; position: absolute; width: 100%; left: 0;&#125;.slide-right-enter &#123; transform: translateX(-100%); -webkit-transform: translateX(-100%);&#125;.slide-right-leave-active &#123; transform: translateX(100%); -webkit-transform: translateX(100%);&#125;.slide-left-enter &#123; transform: translateX(100%); -webkit-transform: translateX(100%);&#125;.slide-left-leave-active &#123; transform: translateX(-100%); -webkit-transform: translateX(-100%);&#125;/********页面切换动画 *********/...&lt;/style&gt; 有个bug如果子页面没有高度，进入子页面再返回底部导航会有抖动bug 比如 加上一定高度后 123456.promise &#123; box-sizing: border-box; height: 100vh; overflow: hidden; background: #f5f5f5;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue阅读源码准备了什么","slug":"Vue阅读源码准备了什么","date":"2020-03-14T16:00:00.000Z","updated":"2020-12-12T03:58:26.000Z","comments":true,"path":"2020/03/15/Vue阅读源码准备了什么/","link":"","permalink":"http://mariogogogo.github.io/2020/03/15/Vue%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E5%87%86%E5%A4%87%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"1、掌握 Vue 所有API​ 我把 Vue 的所有 API 都详细研究使用过了一遍，而且尽量在项目中都有使用，让自己有深一点的体会 ​ 而且我对着官方文档，一个个做了详细的笔记，而且联想过了使用场景。","text":"1、掌握 Vue 所有API​ 我把 Vue 的所有 API 都详细研究使用过了一遍，而且尽量在项目中都有使用，让自己有深一点的体会 ​ 而且我对着官方文档，一个个做了详细的笔记，而且联想过了使用场景。 2、JavaScript 扎实基础​ 幸好自己之前花了大力气去给自己打基础，让自己现在的 JavaScript 基础还算不错。 逼着自己把很多本 JavaScript 书都看完了，并且做了详细笔记。像是【 JavaScript易维护】【JavaScript性能 】，【JavaScript 高级程序设计】【巴菲特给股东的信】看了两遍，说不上精通，也算是还可以？ 3、看完 JavaScript 设计模式​ 光是 JavaScript 设计模式 这本书 我就看了一年半，不能说自己把所有设计模式都掌握了，掌握了大部分吧，设计模式港真真的很有趣，不然我也不会决心学 ​ 在这里推荐 张容铭的 【JavaScript设计模式】，书讲得非常透彻和详细，我是从完全不懂开始看的 ​ 也经常使用一部分，我一直以设计模式为我的项目基构。就是 能用设计模式的地方，我都尽量使用设计模式。 ​ 设计模式看起来就像是 剑客 的剑谱，有招有式，连人家武侠剧发功的时候都知道 喊出 招式的名字… 降龙十八掌！！！！ ​ 野路子难登大雅之堂，主要是不好看啊，代码为了好维护，易扩展 4、学会调试​ 我很大胆地说，如果你不会调试，你看 Vue 源码，或者你会想死，你会出现这个场景… MMP，这个方法是怎么跳到 那个方法的，那个方法和 这个方法又是怎么联系起来的？ ​ 也许你可以慢慢 使用 函数名字 去寻找，但是无疑你会多消耗几倍时间，而且你会更烦 ​ 使用调试真的方便，以前我也真的不喜欢调试，觉得好像很难？？？ ​ 更喜欢使用 console.log 去打印信息….. ​ 是啊，我自己写项目的时候，我还是会使用 console.log 去调试……. ​ 那是因为我自己代码，我知道怎么跑，你 看别人的代码，还是超级抽象的框架，使用 console.log 的方式….. ​ 放心，相信我，你会掉很多头发……… ​ 这里，我使用的是 VSCode 去调试，真的简单又方便，我当时也真的很难去让自己又要学一个东西 ​ 但是我咬咬牙，我还是学了，感谢自己…… ​ 我可以保证，你从不懂到掌握，只要不到十分钟，简直就是 现实版的 十分钟精通到入门 ​ 好吧，下面开始说，Vue 的简单总结。 Vue 源码的简短的总结 1、封装了很多常用的函数！为了 复用 且 易维护 常用的类型判断、 类型转换 、数据格式转换（数组转对象）….. 举些例子 1234567891011121314151617function isObject(obj) &#123; return obj !== null &amp;&amp; typeof obj === &#x27;object&#x27;&#125;function isUndef(v) &#123; return v === undefined || v === null&#125;function isDef(v) &#123; return v !== undefined &amp;&amp; v !== null&#125;function toString(val) &#123; return val == null ? &#x27;&#x27; : typeof val === &#x27;object&#x27; ? JSON.stringify(val, null, 2) : String(val)&#125;function toObject(arr) &#123; var res = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i]) &#123; extend(res, arr[i]); &#125; &#125; return res&#125;.... ​ 你说说不定过了几年，判断是否是一个对象，不再是 什么 typeof obj==”object” ​ 如果没有封装，那岂不是所有代码涉及到的都要改一遍，且不说如果有很多个都变了…..那你就头大了 节点操作兼容函数addClass ,removeClass，createElement，appendChild，removeChild 1234567891011121314151617function addClass(el, cls) &#123; if (!cls || !(cls = cls.trim())) return if (el.classList) &#123; if (cls.indexOf(&#x27; &#x27;) &gt; -1) &#123; cls.split(/\\s+/).forEach(function(c) &#123; return el.classList.add(c); &#125;); &#125; else &#123; el.classList.add(cls); &#125; &#125; else &#123; var cur = &quot; &quot; + (el.getAttribute(&#x27;class&#x27;) || &#x27;&#x27;) + &quot; &quot;; if (cur.indexOf(&#x27; &#x27; + cls + &#x27; &#x27;) &lt; 0) &#123; el.setAttribute(&#x27;class&#x27;, (cur + cls).trim()); &#125; &#125;&#125;.... 这些函数都很有用，所以我都记下来了，毕竟是 框架封装的，肯定是最完善的 2、真的用了很多设计模式就我看到的设计模式就有 Vue涉及的设计模式观察者模式、状态模式、节流模式、参与者模式、备忘录模式、单例模式装饰者模式、组合继承模式、链模式……… 我怀疑 Vue 把所有的设计模式都用完了…. 真的….. 如果你不懂设计模式 你真不会领悟到他这么写的精髓 我就选 Vue 常用的一个设计模式来讲 【参与者模式】 Vue 封装的很多函数都是用了 参与者模式，也可以叫做柯里化 先来简单解释下 参与者模式 1、保存第一次调用 传入参数 2、返回定制函数，函数内使用 参数 https://blog.csdn.net/Forever201295/article/details/104032369 简单实现像这样 123456function add(a)&#123; return function(b)&#123; return a+b &#125;&#125;// 为了定制函数，把第一次调用时的参数闭包保存add5 = add(5)var result = add5(9) 看一下 Vue其中一个 使用柯里化 的封装函数 makeMap 创建 对象 map，返回函数，用于后面查找 某个东西是否存在 map 中 123456789101112131415161718function makeMap( str, expectsLowerCase ) &#123; var map = Object.create(null); var list = str.split(&#x27;,&#x27;); for (var i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true; &#125; return expectsLowerCase ? function(val) &#123; return map[val.toLowerCase()]; &#125; : function(val) &#123; return map[val]; &#125;&#125; // 应用var isUnaryTag = makeMap( &#x27;area,base,br,col,embed,frame,hr,img,input,isindex,keygen,&#x27; + &#x27;link,meta,param,source,track,wbr&#x27;); // 查找 area 标签是否存在 上面保存过的 字符串中isUnaryTag(&#x27;area&#x27;) **3、使用很多闭包！ 据我看过的地方 1、解析组件模板 使用了闭包作为缓存，为了重复解析 2、cached 函数，一个专门使用闭包 为缓存的函数 3、上面所讲到 的 柯里化所有涉及的函数，makeMap,parthPath, 4、createPatchFunction 当属篇幅最大的使用闭包的函数了，把一堆函数作为闭包，然后返回 一个函数。他最大的作用是 比较更新DOM 节点 4、使用很多标志位 Vue 常用标志位来 1、表明是否已经做了某件事 _isMounted：dom 是否已经挂载 _isDestroyed ：组件是否已经摧毁 pending：表明更新回调的 setTimeout 已经执行 waiting：是否已经初始化更新队列，在等待新的成员进入对垒 flushing：更新队列是否已经开始逐个更新成员 …… 2、指明当前东西的身份 isStatic：是否是静态节点 isComment：是否是注释节点 isCloned：是否是克隆节点 isOnce：是否有v-once 指令（如果有当前指令，会跳过编译） _isComponent：是否是组件 ….. ​ 多用标志位，控制流程，替代多余的判断（直接判断标志位来确认身份，不用做太多的判断），减少开销 ​ 上面那些变量，大家没看源码，可能有些懵逼，没关系，就当先知道有这个东西就好了 Vue 源码分几步走我给自己定的任务是 分为两个部分 Vue 的主体内容 1、Vue初始化初始化原理 2、render渲染机制 3、依赖收集 4、依赖更新 5、Virtual DOM ，dom 节点 生成虚拟Vnode 节点 6、Diff、Patch， 节点比较更新 7、Compile， 模板编译 8、NextTick ，延迟执行回调 9、LifeCircle ，生命周期 10、Model ，双向绑定 11、Event ，事件机制 Vue 组件选项 1、computed 2、filter 3、mixin 4、directive 5、slot 6、props 7、watch ​ 我就大约以这些为我的学习目标进行 源码阅读的，每一块都是一个非常大的内容，每一块内容都不是几天能看完的，有时候还需要一点灵感。当然还有很多内容，但是我的目标也并不是全部，一字不漏读完，我要的是他的精髓即可，或许等我掌握了这些，再去开发其他的内容，这样或许更简单 ​ 反正我始终提醒自己不要焦躁，因为这个东西真的是急不来，长期以往，不要妄想一步登天，一开始总会很难，但是久了也一样很难，哈哈哈哈哈 ​ 如果你有兴趣也读源码，我们可以一起讨论学习….","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"阿里云 http 升级 https","slug":"阿里云http升级https","date":"2020-03-12T16:00:00.000Z","updated":"2020-09-16T09:06:59.000Z","comments":true,"path":"2020/03/13/阿里云http升级https/","link":"","permalink":"http://mariogogogo.github.io/2020/03/13/%E9%98%BF%E9%87%8C%E4%BA%91http%E5%8D%87%E7%BA%A7https/","excerpt":"HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。","text":"HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 申请证书 然后在 SSL 证书中下载申请来的证书 有 2 个： 配置阿里云 nginx 我的配置文件在/ect/nginx，现在把刚才的两个证书文件复制过来，待会直接配置使用就行了。nginx 的配置文件是nginx.conf，里面的配置内容有以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name www.xxx.cn; # 在这里，我做了https全加密处理，在访问http的时候自动跳转到https rewrite ^(.*) https://$host$1 permanent; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /home/chan/www; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server 配置https就看这里啦 # server &#123; listen 443; server_name www.xxx.cn; ssl on; #定义服务器的默认网站根目录位置 root /home/chan/www; index index.html index.htm; ssl_certificate cert/ssl.pem; ssl_certificate_key cert/ssl.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; #location / &#123; #index index.html index.htm; # proxy_pass http://127.0.0.1:8081; #&#125; error_page 404 /404.html; &#125;&#125; 然后执行 1sudo nginx -s reload 运行浏览器","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://mariogogogo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"GitFlow 工作流","slug":"GitFlow工作流","date":"2020-02-24T16:00:00.000Z","updated":"2020-09-16T09:07:20.000Z","comments":true,"path":"2020/02/25/GitFlow工作流/","link":"","permalink":"http://mariogogogo.github.io/2020/02/25/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。","text":"GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。 视频Git 工作流指南 - GitFlow 工作流 概述 GitFlow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。 工作方式GitFlow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到中央仓库中。 历史分支相对使用仅有的一个 master 分支，GitFlow 工作流使用 2 个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。 剩下要说明的问题围绕着这 2 个分支的区别展开。 功能分支每个新功能位于一个自己的分支，这样可以 push 到中央仓库以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。 注意，从各种含义和目的上来看，功能分支加上 develop 分支就是功能分支工作流的用法。但 GitFlow 工作流没有在这里止步。 发布分支 一旦 develop 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 develop 分支上 fork 一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做 Bug 修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到 master 分支并分配一个版本号打好 Tag。另外，这些从新建发布分支以来的做的修改要合并回 develop 分支。 使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。 常用的分支约定： 用于新建发布分支的分支: develop 用于合并的分支: master 分支命名: release-_ 或 release/_ 维护分支 维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从 master 分支 fork 出来的分支。修复完成，修改应该马上合并回 master 分支和 develop 分支（当前的发布分支），master 分支应该用新的版本号打好 Tag。 为 Bug 修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在 master 分支上处理的临时发布。 示例下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。 创建开发分支 第一步为 master 分支配套一个 develop 分支。简单来做可以本地创建一个空的 develop 分支，push 到服务器上： 12git branch developgit push -u origin develop 以后这个分支将会包含了项目的全部历史，而 master 分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好 develop 分支的跟踪分支： 12git clone ssh://user@host/path/to/repo.gitgit checkout -b develop origin/develop 现在每个开发都有了这些历史分支的本地拷贝。 小红和小明开始开发新功能 这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于 master 分支，而是应该基于 develop 分支： 1git checkout -b some-feature develop 他们用老套路添加提交到各自功能分支上：编辑、暂存、提交： 123git statusgit addgit commit 小红完成功能开发 添加了提交后，小红觉得她的功能 OK 了。如果团队使用 Pull Requests，这时候可以发起一个用于合并到 develop 分支。否则她可以直接合并到她本地的 develop 分支后 push 到中央仓库： 12345git pull origin developgit checkout developgit merge some-featuregit pushgit branch -d some-feature 第一条命令在合并功能前确保 develop 分支是最新的。注意，功能决不应该直接合并到 master 分支。冲突解决方法和集中式工作流一样。 小红开始准备发布 这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号： 1git checkout -b release-0.1 develop 这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。 只要小红创建这个分支并 push 到中央仓库，这个发布就是功能冻结的。任何不在 develop 分支中的新功能都推到下个发布循环中。 小红完成发布 一旦准备好了对外发布，小红合并修改到 master 分支和 develop 分支上，删除发布分支。合并回 develop 分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。另外，如果小红的团队要求 Code Review，这是一个发起 Pull Request 的理想时机。 1234567git checkout mastergit merge release-0.1git pushgit checkout developgit merge release-0.1git pushgit branch -d release-0.1 发布分支是作为功能开发（develop 分支）和对外发布（master 分支）间的缓冲。只要有合并到 master 分支，就应该打好 Tag 以方便跟踪。 12git tag -a 0.1 -m &quot;Initial public release&quot; mastergit push --tags Git 有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。可以配置一个勾子，在你 push 中央仓库的 master 分支时，自动构建好对外发布。 最终用户发现 Bug 对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个 Issues 抱怨当前版本的一个 Bug。为了处理 Bug，小红（或小明）从 master 分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回 master 分支： 12345git checkout -b issue-#001 master# Fix the buggit checkout mastergit merge issue-#001git push 就像发布分支，维护分支中新加这些重要修改需要包含到 develop 分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了： 1234git checkout developgit merge issue-#001git pushgit branch -d issue-#001 总结到了这里， GitFlow 工作流已经感觉很舒适了。你应该也牢固的掌握了本地仓库的潜能，push/pull 模式和 Git 健壮的分支和合并模型。 记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用 Git 不可违逆的条例。所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让 Git 为你所用。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://mariogogogo.github.io/tags/Git/"},{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"koa2+mysql+router 后台开发项目","slug":"koa2+mysql后台开发项目","date":"2020-02-23T16:00:00.000Z","updated":"2020-09-16T09:07:38.000Z","comments":true,"path":"2020/02/24/koa2+mysql后台开发项目/","link":"","permalink":"http://mariogogogo.github.io/2020/02/24/koa2+mysql%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","excerpt":"koa2 与 mysql 在个人项目中经常用到记录一下","text":"koa2 与 mysql 在个人项目中经常用到记录一下 创建项目1.建立文件夹名为 koa-decorator 目录如下123456789101112131415├── dist----------------------------------- 编译后的├── src ----------------------------------- 项目的所有代码│ ├──config ----------------------------- 配置文件│ ├──controller ------------------------- 控制器│ ├──lib -------------------------------- 一些项目的核心文件（如路由的装饰器文件就在这里）│ ├──logic ------------------------------ 一些数据校验│ ├──middleware ------------------------- 中间件│ ├──models------------------------------ 操作数据表相关逻辑代码(根据项目复杂度可以再分Service层)│ ├──util-------------------------------- 相关的工具文件│ ├──index.js---------------------------- 项目的入口文件├── View --------------------------------- 一些静态文件(上传的图片)├── .babelrc ------------------------------ babelrc 的相关配置├── .gitignore ---------------------------- git 的忽略配置文件├── dev.js -------------------------------- 开发环境的启动文件├── production.js ------------------------- 生产环境的启动文件 2.入口文件编写开发环境 dev.js 和 生产环境的 production.js 的启动文件 1234567891. dev.jsrequire(&quot;babel-register&quot;);process.env.NODE_ENV = &quot;development&quot;;require(&quot;./src&quot;);2. production.jsprocess.env.NODE_ENV = &quot;production&quot;;require(&quot;./dist&quot;); 3.配置 package.json1234567&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src --out-dir dist&quot;, &quot;dev&quot;: &quot;set NODE_ENV=development &amp;&amp; supervisor --watch src dev.js&quot;, &quot;start&quot;: &quot;npm run build &amp;&amp; set NODE_ENV=production &amp;&amp; supervisor --watch dist production.js&quot;, &quot;pm2&quot;: &quot;pm2 start production.js --name &amp;#39;wx-node&amp;#39; --env NODE_ENV=&amp;#39;production&amp;#39; --output ./logs/logs-out.log --error ./logs/logs-error.log --watch dist&quot; &#125;, 运行 npm run build : 是用 babel 直接将 src 目录编译在 dist 目录 运行 npm run dev ： 是设置环境变量为 development 并且监听 src 目录，启动 dev.js 运行，为开发环境 运行 npm run start : 是 运行第一个命令 npm run build 并且设置环境变量为 production 监听 dist 目录,启动 production.js 运行，为生产或者测试环境 运行 npm run pm2： 这是使用 pm2 来守护项目进程,并且设置环境变量和日志记 4.nodejs 入口文件创建 server 文件下 index,js 1234567891011121314151617181920212223242526272829303132333435const Koa = require(&amp;#39;koa&amp;#39;);const &#123; resolve &#125; = require(&amp;#39;path&amp;#39;);const views = require(&amp;#39;koa-views&amp;#39;);const R = require(&amp;#39;ramda&amp;#39;);const MIDDLEWARES = [ &amp;#39;common&amp;#39;, &amp;#39;router&amp;#39; ];const useMiddlewares = (app) =&gt; &#123; R.map( R.compose(R.forEachObjIndexed((initWith) =&gt; initWith(app)), require, (name) =&gt; resolve(__dirname, `./middlewares/$&#123;name&#125;`) ) )(MIDDLEWARES);&#125;;(async () =&gt; &#123; //创建实例 const app = new Koa(); //views app.use( views(resolve(__dirname, &amp;#39;../views&amp;#39;), &#123; extension : &amp;#39;html&amp;#39; &#125;) ); // error logger app.on(&amp;#39;error&amp;#39;, (err, ctx) =&gt; &#123; console.log(&amp;#39;error occured:&amp;#39;, err); &#125;); await useMiddlewares(app); // 监听端口 app.listen(4455, () =&gt; &#123; console.log(&amp;#39;http://127.0.0.1:4455 is runing&amp;#39;); &#125;);&#125;)(); 5.Router 路由二次封装配置在 lib 文件中创建 decorator.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155const Router = require(&quot;koa-router&quot;);const &#123; resolve &#125; = require(&quot;path&quot;);const _ = require(&quot;lodash&quot;);const glob = require(&quot;glob&quot;);const R = require(&quot;ramda&quot;);const symbolPrefix = Symbol(&quot;prefix&quot;);const routerMap = new Map();const isArray = c =&gt; (_.isArray(c) ? c : [c]);export class Route &#123; constructor(app, apiPath) &#123; this.app = app; this.apiPath = apiPath; this.router = new Router(); &#125; init() &#123; glob.sync(resolve(this.apiPath, &quot;./**/*.js&quot;)).forEach(require); for (let [conf, controller] of routerMap) &#123; const controllers = isArray(controller); let prefixPath = conf.target[symbolPrefix]; if (prefixPath) prefixPath = normalizePath(prefixPath); const routerPath = prefixPath + conf.path; this.router[conf.method](routerPath, ...controllers); &#125; this.app.use(this.router.routes()); this.app.use(this.router.allowedMethods()); &#125;&#125;const normalizePath = path =&gt; (path.startsWith(&quot;/&quot;) ? path : `/$&#123;path&#125;`);const router = conf =&gt; (target, key, descriptor) =&gt; &#123; conf.path = normalizePath(conf.path); routerMap.set( &#123; target: target, ...conf &#125;, target[key] );&#125;;export const controller = path =&gt; target =&gt; (target.prototype[symbolPrefix] = path);export const get = path =&gt; router(&#123; method: &quot;get&quot;, path: path &#125;);export const post = path =&gt; router(&#123; method: &quot;post&quot;, path: path &#125;);export const put = path =&gt; router(&#123; method: &quot;put&quot;, path: path &#125;);export const del = path =&gt; router(&#123; method: &quot;delete&quot;, path: path &#125;);export const use = path =&gt; router(&#123; method: &quot;use&quot;, path: path &#125;);export const all = path =&gt; router(&#123; method: &quot;all&quot;, path: path &#125;);const decorate = (args, middleware) =&gt; &#123; let [target, key, descriptor] = args; target[key] = isArray(target[key]); target[key].unshift(middleware); return descriptor;&#125;;const convert = middleware =&gt; (...args) =&gt; decorate(args, middleware);export const auth = convert(async (ctx, next) =&gt; &#123; console.log(&quot;ctx.session.user&quot;); console.log(ctx.session.user); if (!ctx.session.user) &#123; return (ctx.body = &#123; success: false, code: 401, err: &quot;登录信息失效，重新登录&quot; &#125;); &#125; await next();&#125;);export const admin = roleExpected =&gt; convert(async (ctx, next) =&gt; &#123; try &#123; const &#123; role &#125; = ctx.session.user; console.log(&quot;admin session&quot;); console.log(ctx.session.user); if (!role || role !== roleExpected) &#123; return (ctx.body = &#123; success: false, code: 403, err: &quot;你没有权限，来错地方了&quot; &#125;); &#125; await next(); &#125; catch (error) &#123; return (ctx.body = &#123; success: false, code: 505, err: &quot;Cannot destructure property `role` of &#x27;undefined&#x27; or &#x27;null&#x27;.&quot; &#125;); &#125; &#125;);export const required = rules =&gt; convert(async (ctx, next) =&gt; &#123; let errors = []; const checkRules = R.forEachObjIndexed((value, key) =&gt; &#123; errors = R.filter(i =&gt; !R.has(i, ctx, ctx.request[key]))(value); &#125;); checkRules(rules); if (errors.length) &#123; ctx.body = &#123; success: false, code: 412, err: `$&#123;errors.join(&quot;,&quot;)&#125; is required` &#125;; &#125; await next(); &#125;); middle 文件夹中创建 route.js 123456789const &#123; Route &#125; = require(&quot;../lib/decorator&quot;);const &#123; resolve &#125; = require(&quot;path&quot;);export const router = app =&gt; &#123; const apiPath = resolve(__dirname, &quot;../routes&quot;); const router = new Route(app, apiPath); router.init();&#125;; 创建 routes 文件夹下 user.js 123456789101112const &#123; controller, get, post, put &#125; = require(&quot;../lib/decorator&quot;);@controller(&quot;/api/v0/user&quot;)export class userController &#123; @get(&quot;/&quot;) async login(ctx, next) &#123; return (ctx.body = &#123; success: false, err: &quot;用户&quot; &#125;); &#125;&#125; 6.mysql 配置创建 config 文件夹–&gt;default.js 123456789101112//服务器配置信息const config = &#123; port: 4455, database: &#123; DATABASE: &quot;order_test&quot;, USERNAME: &quot;root&quot;, PASSWORD: &quot;123456&quot;, PORT: &quot;3306&quot;, HOST: &quot;localhost&quot; &#125;&#125;;module.exports = config; 创建 lib 文件夹中 mysql.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798var mysql = require(&#x27;mysql&#x27;);var config = require(&#x27;../config/default.js&#x27;);var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE, port : config.database.PORT&#125;);let query = (sql, values) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 执行sql脚本对数据库进行读写 pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; connection.query(sql, values, (err, rows) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; console.log(&#x27;数据库连接正常&#x27;); resolve(rows); &#125; connection.release(); &#125;); &#125; &#125;); &#125;);&#125;;// 数据库表格创建const createTables = &#123; users : `CREATE TABLE IF NOT EXISTS user_info ( id INT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT &#x27;(自增长)&#x27;, user_id VARCHAR ( 100 ) NOT NULL COMMENT &#x27;账号&#x27;, user_name VARCHAR ( 100 ) NOT NULL COMMENT &#x27;用户名&#x27;, user_pwd VARCHAR ( 100 ) NOT NULL COMMENT &#x27;密码&#x27;, user_head VARCHAR ( 225 ) COMMENT &#x27;头像&#x27;, user_mobile VARCHAR ( 20 ) COMMENT &#x27;手机&#x27;, user_email VARCHAR ( 64 ) COMMENT &#x27;邮箱&#x27;, user_creatdata TIMESTAMP NOT NULL DEFAULT NOW( ) COMMENT &#x27;注册日期&#x27;, user_login_time TIMESTAMP DEFAULT NOW( ) COMMENT &#x27;登录时间&#x27;, user_count INT COMMENT &#x27;登录次数&#x27; ) ENGINE = INNODB charset = utf8;`, role : `CREATE TABLE IF NOT EXISTS role_info ( id INT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT &#x27;(自增长)&#x27;, role_name VARCHAR ( 20 ) NOT NULL COMMENT &#x27;角色名&#x27;, role_description VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;描述&#x27; ) ENGINE = INNODB charset = utf8;`, permission : `CREATE TABLE IF NOT EXISTS permission_info ( id INT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT &#x27;(自增长)&#x27;, permission_name VARCHAR ( 20 ) NOT NULL COMMENT &#x27;权限名&#x27;, permission_description VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;描述&#x27; ) ENGINE = INNODB charset = utf8;`, userRole : `CREATE TABLE IF NOT EXISTS user_role ( id INT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT &#x27;(自增长)&#x27;, user_id INT NOT NULL COMMENT &#x27;关联用户&#x27;, role_id INT NOT NULL COMMENT &#x27;关联角色&#x27;, KEY fk_user_role_role_info_1 ( role_id ), KEY fk_user_role_user_info_1 ( user_id ), CONSTRAINT fk_user_role_role_info_1 FOREIGN KEY ( role_id ) REFERENCES role_info ( id ) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT fk_user_role_user_info_1 FOREIGN KEY ( user_id ) REFERENCES user_info ( id ) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE = INNODB charset = utf8;`, rolePermission : `CREATE TABLE IF NOT EXISTS role_permission ( id INT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT &#x27;(自增长)&#x27;, role_id INT NOT NULL COMMENT &#x27;关联角色&#x27;, permission_id INT NOT NULL COMMENT &#x27;关联权限&#x27;, KEY fk_role_permission_role_info_1 ( role_id ), KEY fk_role_permission_permission_info_1 ( permission_id ), CONSTRAINT fk_role_permission_role_info_1 FOREIGN KEY ( role_id ) REFERENCES role_info ( id ) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT fk_role_permission_permission_info_1 FOREIGN KEY ( permission_id ) REFERENCES permission_info ( id ) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE = INNODB charset = utf8;`&#125;;let createTable = (sql) =&gt; &#123; return query(sql, []);&#125;;// 建表 ----创建一次之后可以注释不需要createTable(createTables.users);createTable(createTables.role);createTable(createTables.permission);createTable(createTables.userRole);createTable(createTables.rolePermission);// 通过名字查找用户const findDataByName = (name) =&gt; &#123; let _sql = `select * from user_info where user_name=&quot;$&#123;name&#125;&quot;;`; return query(_sql);&#125;;findDataByName(&#x27;jack&#x27;).then((res) =&gt; &#123; console.log(res);&#125;);....//其他方法相似 在路由文件中 router 文件夹下–&gt;user.js 123456789101112131415161718const &#123; controller, get, post, put &#125; = require(&#x27;../lib/decorator&#x27;);const userModel = require(&#x27;../lib/mysql.js&#x27;);@controller(&#x27;/api/v0/user&#x27;)export class userController &#123; @get(&#x27;/&#x27;) async login(ctx, next) &#123; const result = await userModel.findDataByName(&#x27;jack&#x27;); console.log(result); return (ctx.body = &#123; success : false, data : result err : &#x27;用户&#x27; &#125;); &#125;&#125;.....//其他操作类型 参考koa2+vue+mysql 全栈开发记录","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"koa2 使用 es7 的装饰器 decorator","slug":"koa2使用es7 的装饰器decorator","date":"2020-02-22T16:00:00.000Z","updated":"2020-09-16T09:07:39.000Z","comments":true,"path":"2020/02/23/koa2使用es7 的装饰器decorator/","link":"","permalink":"http://mariogogogo.github.io/2020/02/23/koa2%E4%BD%BF%E7%94%A8es7%20%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8decorator/","excerpt":"目前 JavaScript 对 decorator 是不支持，但是可以用 babel 来编译.","text":"目前 JavaScript 对 decorator 是不支持，但是可以用 babel 来编译. 装饰器配置12345678&quot;devDependencies&quot;: &#123; &quot;@babel/cli&quot;: &quot;^7.8.4&quot;, &quot;@babel/core&quot;: &quot;^7.8.4&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.8.3&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.8.3&quot;, &quot;@babel/register&quot;: &quot;^7.8.3&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot; //支持import 导入 &#125;, babel 配置文件 .babelrc 12345678910&#123; &quot;plugins&quot;: [ [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;], [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot;: true &#125;] ]&#125; 我们创建一个 js 1234567891011121314151617181920212223242526272829class Boy &#123; @speak(&quot;Chinese&quot;) run() &#123; console.log(&quot;====================================&quot;); console.log(&quot;i can run !&quot;); console.log(&quot;====================================&quot;); &#125;&#125;/** * @param &#123;any&#125; target | 指装饰的对象 boy speak紧跟的class * @param &#123;any&#125; key | 修饰的方法 run * @param &#123;any&#125; descriptor | 特定的描述 */function speak(language) &#123; return function(target, key, descriptor) &#123; console.log(target); console.log(key); console.log(descriptor); target.language = language; return descriptor; &#125;;&#125;const luke = new Boy();luke.run(); 入口文件 1234// 注册require(&amp;#39;@babel/register&amp;#39;);// 引入被执行的文件require(&amp;#39;./server/index.js&amp;#39;); import 支持nodejs 仍未支持 import/export 语法，需要安装必要的 npm 包–babel，使用 babel 将 js 文件编译成 node.js 支持的 commonjs 格式的代码。 1yarn add babel-register babel-preset-env -D babel 配置文件 .babelrc 12345&#123; &quot;plugins&quot;: [ &quot;transform-es2015-modules-commonjs&quot; ]&#125; 创建项目### 1.入口文件编写开发环境 dev.js 和 生产环境的 production.js 的启动文件 1234567891. dev.jsrequire(&quot;babel-register&quot;);process.env.NODE_ENV = &quot;development&quot;;require(&quot;./src&quot;);2. production.jsprocess.env.NODE_ENV = &quot;production&quot;;require(&quot;./dist&quot;); 2.配置 package.json1234567&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src --out-dir dist&quot;, &quot;dev&quot;: &quot;set NODE_ENV=development &amp;&amp; supervisor --watch src dev.js&quot;, &quot;start&quot;: &quot;npm run build &amp;&amp; set NODE_ENV=production &amp;&amp; supervisor --watch dist production.js&quot;, &quot;pm2&quot;: &quot;pm2 start production.js --name &#x27;wx-node&#x27; --env NODE_ENV=&#x27;production&#x27; --output ./logs/logs-out.log --error ./logs/logs-error.log --watch dist&quot; &#125;, 运行 npm run build : 是用 babel 直接将 src 目录编译在 dist 目录 运行 npm run dev ： 是设置环境变量为 development 并且监听 src 目录，启动 dev.js 运行，为开发环境 运行 npm run start : 是 运行第一个命令 npm run build 并且设置环境变量为 production 监听 dist 目录,启动 production.js 运行，为生产或者测试环境 运行 npm run pm2： 这是使用 pm2 来守护项目进程,并且设置环境变量和日志记 参考koa2 使用 es7 的装饰器 decorator - 天高任鸟飞吧 - 博客园","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"常用的 CSS 小技巧","slug":"常用的CSS小技巧","date":"2020-02-01T16:00:00.000Z","updated":"2020-12-08T06:28:55.000Z","comments":true,"path":"2020/02/02/常用的CSS小技巧/","link":"","permalink":"http://mariogogogo.github.io/2020/02/02/%E5%B8%B8%E7%94%A8%E7%9A%84CSS%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"css 一行文本超出…123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;","text":"css 一行文本超出…123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; IOS 手机容器滚动条滑动不流畅12overflow: auto;-webkit-overflow-scrolling: touch; 修改滚动条样式隐藏 div 元素的滚动条 123div::-webkit-scrollbar &#123; display: none;&#125; 水平垂直居中12345678910111213141516div &#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125;//======另一种==========.parent &#123; display: flex; justify-content: center; align-items: center;&#125; calc这是一个 css 属性，我一般称之为 css 表达式。可以计算 css 的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出 20px 是啥。 123div &#123; width: calc(25% - 20px);&#125; 多行换行 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 消息小三角 12345678910&amp;::before &#123; content: &#x27;&#x27;; border-width: 22px 22px 22px 22px; border-style: solid; border-color: transparent #fff transparent transparent; /* 定位 */ position: absolute; left: -38px; top: 36px;&#125; CSS flex 布局最后一行列表左对齐的 N 种方法我们布局经常会遇到这样的情况 方法一：模拟 space-between 和间隙 12345678910111213.container &#123; display: flex; flex-wrap: wrap;&#125;.list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px;&#125;.list:not(:nth-child(4n)) &#123; margin-right: calc(4% / 3); //间隙隔开&#125; 首先最后一行需要左对齐的布局更适合使用 CSS grid 布局实现，但是，repeat()函数兼容性有些要求，IE 浏览器并不支持。如果项目需要兼容 IE，则此方法需要斟酌。 方法二：根据个数最后一个元素动态 margin 例如，假设每行 4 个元素，结果最后一行只有 3 个元素，则最后一个元素的 margin-right 大小是“列表宽度+间隙大小”的话，那最后 3 个元素也是可以完美左对齐的。 .list:last-child:nth-child(4n - 1)说明最后一行，要么 3 个元素，要么 7 个元素…… .list:last-child:nth-child(4n - 2)说明最后一行，要么 2 个元素，要么 6 个元素…… 1234567891011121314151617181920.container &#123; display: flex; /* 两端对齐 */ justify-content: space-between; flex-wrap: wrap;&#125;.list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px;&#125;/* 如果最后一行是3个元素 */.list:last-child:nth-child(4n - 1) &#123; margin-right: calc(24% + 4% / 3);&#125;/* 如果最后一行是2个元素 */.list:last-child:nth-child(4n - 2) &#123; margin-right: calc(48% + 8% / 3);&#125; flex 项中子元素文本截断 text-overflow:ellipsis 失效这个小 “bug”栗子 🌰 我们不能为 .item-con 元素设置个宽度，这样就无法适应不同屏幕尺寸的终端设备。 解决方案：在 flex 项中设置 min-width: 0; 1234567891011121314151617181920212223.flex &#123; width: 320px; padding: 5px 10px; display: flex; border-bottom: 1px dashed #ccc;&#125;.flex .col1 &#123; margin-right: 6px; color: #999;&#125;.flex .col2 &#123; flex: 1; min-width: 0; /*解决方案*/&#125;.flex .col2 .item-con &#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125;.flex p &#123; font-size: 12px; color: #999;&#125; css 竖向子元素上下平均分配空间","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"CSS","slug":"CSS","permalink":"http://mariogogogo.github.io/tags/CSS/"}]},{"title":"Axios 源码解析","slug":"Axios源码解析","date":"2020-01-21T16:00:00.000Z","updated":"2020-09-16T09:07:18.000Z","comments":true,"path":"2020/01/22/Axios源码解析/","link":"","permalink":"http://mariogogogo.github.io/2020/01/22/Axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"首先对 axios 提出几个问题 为什么 axios 既可以当函数调用，也可以当对象使用，比如axios(&#123;url,method&#125;)、axios.get。 简述 axios 调用流程。 有用过拦截器吗？原理是怎样的？ 有使用 axios 的取消功能吗？是怎么实现的？ 为什么支持浏览器中发送请求也支持 node 发送请求？ 带着问题我们进入源码去看看吧","text":"首先对 axios 提出几个问题 为什么 axios 既可以当函数调用，也可以当对象使用，比如axios(&#123;url,method&#125;)、axios.get。 简述 axios 调用流程。 有用过拦截器吗？原理是怎样的？ 有使用 axios 的取消功能吗？是怎么实现的？ 为什么支持浏览器中发送请求也支持 node 发送请求？ 带着问题我们进入源码去看看吧 axios 简介axios 是目前最常用的 HTTP 请求库，即可以用于前端浏览器也可以在后端 node.js 中使用，在 github 上的 star 数已经有 6w+ 了，它也是 vue.js 官方极力推荐的，前端（全栈）开发必不可少的库，它的主要特性包括 基于 Promise 支持 前端浏览器环境 和 后端 node.js 环境 可添加拦截器转换请求和响应数据 支持请求取消 自动转换 JSON 数据 客户端支持防范 XSRF 支持各主流浏览器以及 IE8+ axios 返回信息 知识要点 XMLHttpRequest Promise 异步编程 工具函数库：bind、extend、deepCopy、deepMerge…… 拦截器：Interceptor 拦截器管理：InterceptorManager 适配器：Adaptor 工厂函数：createInstance 为什么 axios 支持对象又支持函数 axios 本质是函数，赋值了一些别名方法，比如 get、post 方法，可被调用，最终调用的还是 Axios.prototype.request 函数。 axios 与 Axios 的关系 从功能说 axios 是 Axios 的实例 (拥有功能,有属性) 从语法说 axios 不是 Axios 的实例 (是个函数) axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型上的所有方法.有 Axios 对象上所有属性 instance 与 axios 的区别?相同: 都是一个能发任意请求的函数:request 都有发特定请求的方法:get post put delete 都有默认配置参数与拦截器属性 不同: 默认配置可能不一样 没有 create cancelToken all 方法 利用 工厂函数包装通过工厂函数对实例化对象过程进行包装 request 方法处理 实例挂载 this 的处理 1234567891011121314151617181920212223242526272829function createInstance(defaultConfig) &#123; /* 创建Axios的实例 原型对象上有一些用来发请求的方法: get()/post()/put()/delete()/request() 自身上有2个重要属性: defaults/interceptors */ var context = new Axios(defaultConfig); // axios和axios.create()对应的就是request函数 // 下面这句话相当于 ===&gt; Axios.prototype.request.bind(context) var instance = bind(Axios.prototype.request, context); // 返回新函数,新函数内部调用request,里面的this 指向 context 也就是Axios的实例 // 将Axios原型对象上的方法拷贝到instance上: request()/get()/post()/put()/delete() //===&gt; 就可以使用axios.get() //===&gt; request() === axios.request(&#123;&#125;) === axios(&#123;&#125;) utils.extend(instance, Axios.prototype, context); // 将Axios实例对象上的属性拷贝到instance上: defaults和interceptors属性 utils.extend(instance, context); return instance;&#125;...var axios = createInstance(defaults);...//源码中导出module.exports = axios; Axios.prototype.request 是什么呢?是个函数 123456789101112131415161718192021222324//用于发请求的函数//我们使用的axios就是此函数bind()返回的函数Axios.prototype.request = function request(config) &#123; /*eslint no-param-reassign:0*/ // Allow for axios(&#x27;example/url&#x27;[, config]) a la fetch API if (typeof config === &#x27;string&#x27;) &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0]; &#125; else &#123; config = config || &#123;&#125;; &#125; .... // 给原型对象添加 四个方法 utils.forEach([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27;], function forEachMethodNoData(method) &#123; /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) &#123; return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url &#125;)); &#125;; &#125;);...&#125; axios 调用流程 实际是调用的 Axios.prototype.request 方法，最终返回的是 promise 链式调用，实际请求是在 dispatchRequest 中派发的。 因为 axios 是对异步任务的封装，所以必不可少的，我们需要使用 Promise 来进行包装 1234request(config) 将请求拦截器/dispatchRequest()/响应拦截器 通过Promise链串起来,返回Promise dispatchRequest(config)转换请求数据 ===&gt; 调用xhrAdapter()发请求 ===&gt; 请求返回后转化响应数据,返回Promise xhrAdapter(config)创建XHR对象,根据config进行相应设置,发送特定请求,并接受响应数据,返回Promise request(config) ==&gt; dispatchRequest(config)==&gt; xhrAdapter(config) 拦截器 - Interceptor 原理 用 axios.interceptors.request.use 添加请求成功和失败拦截器函数，用 axios.interceptors.response.use 添加响应成功和失败拦截器函数。在 Axios.prototype.request 函数组成 promise 链式调用时，Interceptors.protype.forEach 遍历请求和响应拦截器添加到真正发送请求 dispatchRequest 的两端，从而做到请求前拦截和响应后拦截。拦截器也支持用 Interceptors.protype.eject 方法移除。 给实例对象添加 request 和 response 拦截器 构造函数 Axios 123456789function Axios(instanceConfig) &#123; // 默认参数 this.defaults = instanceConfig; // 拦截器 请求和响应拦截器 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125; Interceptor拦截器对象，用来注册和管理拦截器 12345678910111213141516171819// 添加请求前拦截器axios.interceptors.request.use( function(config) &#123; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;);// 添加请求后拦截器axios.interceptors.response.use( function(response) &#123; return response; &#125;, function(error) &#123; return Promise.reject(error); &#125;); 构造函数中 InterceptorManager 的实现 12345678910111213141516export default class InterceptorManager &#123; constructor() &#123; this.handlers = []; //提供数组 &#125; /** * 类似与回调函数1 回调函数2 * @param resolvedHandler 回调函数1 * @param rejectedHandler 回调函数2 */ use(resolvedHandler, rejectedHandler) &#123; this.handlers.push(&#123; resolvedHandler, rejectedHandler &#125;); &#125;&#125; InterceptorManager.prototype.forEach 遍历1234567891011121314151617181920212223/* 创建用于保存请求/响应拦截函数的数组 数组的中间放发送请求的函数 数组的左边放请求拦截器函数(成功/失败) 数组的右边放响应拦截器函数 */var chain = [dispatchRequest, undefined];var promise = Promise.resolve(config);// 后添加的请求拦截器保存在数组的前面this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; chain.unshift(interceptor.fulfilled, interceptor.rejected);&#125;);// 后添加的响应拦截器保存在数组的后面this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; chain.push(interceptor.fulfilled, interceptor.rejected);&#125;);// 通过promise的then()串连起所有的请求拦截器/请求方法/响应拦截器while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift());&#125; 输出结构 异步任务链把请求包装在 Promise 任务链中 1234567891011let promise = Promise.resolve(configs);this.interceptors.request.handlers.forEach(handler =&gt; &#123; promise = promise.then(handler.resolvedHandler, handler.rejectedHandler);&#125;);promise = promise.then(this.dispatch, undefined);this.interceptors.response.handlers.forEach(handler =&gt; &#123; promise = promise.then(handler.resolvedHandler, handler.rejectedHandler);&#125;); 请求和响应的拦截器可以写 Promise。 如果设置了多个请求响应器，后设置的先执行。 如果设置了多个响应拦截器，先设置的先执行。 axios 如何取消请求? 通过传递 config 配置 cancelToken 的形式，来取消的。判断有传 cancelToken，在 promise 链式调用的 dispatchRequest 抛出错误，在 adapter 中 request.abort()取消请求，使 promise 走向 rejected，被用户捕获取消信息。 1234567891011121314151617181920let cancel; // 用于保存取消请求的函数function getProducts1() &#123; axios(&#123; url: &quot;http://localhost:4000/products1&quot;, cancelToken: new axios.CancelToken(c =&gt; &#123; // c是用于取消当前请求的函数 // 保存取消函数, 用于之后可能需要取消当前请求 cancel = c; &#125;) &#125;).then( response =&gt; &#123; cancel = null; console.log(&quot;请求1成功了&quot;, response.data); &#125;, error =&gt; &#123; cancel = null; console.log(&quot;请求1失败了&quot;, error.message, error); &#125; );&#125; new axios.CancelToken 做了什么当配置了cancelToken对象时 创建了一个用于将来取消请求的 cacelPromise 并定义了一个用于取消请求的 cancel 函数 将 cancel 函数传递出来 取消请求 执行 cancel 函数,传入错误的 message 内部会让 cancelPromise 变成成功,且成功的值为一个 Cancel 对象 在 cancelPromise 的成功回调中,中断请求,并让发请求的 promise 失败,失败的 reason 为 Cancel 对象 1234567891011121314151617181920212223242526function CancelToken(executor) &#123; if (typeof executor !== &quot;function&quot;) &#123; throw new TypeError(&quot;executor must be a function.&quot;); &#125; // 为将来取消请求准备一个promise对象, 并保存resolve函数 var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); // 保存当前token对象 var token = this; // 立即执行接收的执行器函数, 并传入用于取消请求的cancel函数 executor(function cancel(message) &#123; // 如果token中有reason了, 说明请求已取消 if (token.reason) &#123; // Cancellation has already been requested return; &#125; // 将token的reason指定为一个Cancel对象 token.reason = new Cancel(message); // 将取消请求的promise指定为成功, 值为reason resolvePromise(token.reason); &#125;);&#125; Cancel 对象 123456789101112function Cancel(message) &#123; this.message = message;&#125;Cancel.prototype.toString = function toString() &#123; return &quot;Cancel&quot; + (this.message ? &quot;: &quot; + this.message : &quot;&quot;);&#125;;// 用于标识是一个取消的errorCancel.prototype.__CANCEL__ = true;module.exports = Cancel; 在 xhr.js 中调用 CancelToken 函数中的 promise 的 then 123456789101112131415// 如果配置了cancelToken if (config.cancelToken) &#123; // 指定用于中断请求的回调函数 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; // 中断请求 request.abort(); // 让请求的promise失败 reject(cancel); // Clean up request request = null; &#125;); &#125; 其中 cancel 对象哪里来的呢? 12token.reason = new Cancel(message);resolvePromise(token.reason); 适配器(支持浏览器也支持 node 环境) - Adapter axios.defaults.adapter 默认配置中根据环境判断是浏览器还是 node 环境，使用对应的适配器。适配器支持自定义。 browser : XMLHttpRequest / Fetch node : http / https 数据转换请求数据转换 : transformRequest 响应数据转换 : transformResponse axios.defaults.transformResponse 数组中默认就有一个函数，所以使用 concat 链接自定义的函数。 12345678910111213141516171819202122232425262728293031323334353637export default &#123; baseURL: &quot;&quot;, url: &quot;&quot;, method: &quot;get&quot;, headers: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, transformResponse: function(data) &#123; //配置项对数据处理 return data; &#125;&#125;;//使用var ISO_8601 = /(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)T(\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;)Z/;function formatDate(d) &#123; return d.getMonth() + 1 + &quot;/&quot; + d.getDate() + &quot;/&quot; + d.getFullYear();&#125;/** * 扩展配置 对响应数据格式化转换 * @param data * @returns &#123;any&#125; */axios .get(&quot;https://api.github.com/users/mzabriskie&quot;, &#123; transformResponse: axios.defaults.transformResponse.concat(function(data, headers) &#123; Object.keys(data).forEach(function(k) &#123; if (ISO_8601.test(data[k])) &#123; data[k] = new Date(Date.parse(data[k])); &#125; &#125;); return data; &#125;) &#125;) .then(function(res) &#123; document.getElementById(&quot;created&quot;).innerHTML = formatDate(res.data.created_at); &#125;); 几个好用的工具方法- deepCopy 函数基于上面说的，我们需要封装一个方法，用于深度克隆对象 123456789101112131415let deepCopy = source =&gt; &#123; let target = Array.isArray(source) ? [] : &#123;&#125;; for (let key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (typeof source[key] === &quot;object&quot; &amp;&amp; source !== null) &#123; //递归 target[key] = deepCopy(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;; - configMerge 函数对于配置合并，并不能简单的进行处理，需要针对不同的配置进行不同的处理，有的是覆盖，有的合并 baseURL、url、 method 等是直接覆盖的 headers 是需要进行合并处理的 12345678910111213141516171819let mergeConfig = (obj1, obj2) =&gt; &#123; let target = deepCopy(obj1); let source = deepCopy(obj2); Object.keys(source).reduce((t, k) =&gt; &#123; if ([&quot;url&quot;, &quot;method&quot;, &quot;baseURL&quot;].includes(k)) &#123; t[k] = source[k]; &#125; if ([&quot;headers&quot;].includes(k)) &#123; // console.log(&#x27;target&#x27;, target.headers); // console.log(&#x27;source&#x27;, source.headers); t[k] = Object.assign(target[k], source[k]); // console.log(&#x27;t&#x27;, t); &#125; return t; &#125;, target); return target;&#125;; 最后看下整个流程图 参考学习 axios 源码整体架构…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"Axios封装","slug":"Axios封装","date":"2020-01-21T16:00:00.000Z","updated":"2020-12-09T08:07:24.000Z","comments":true,"path":"2020/01/22/Axios封装/","link":"","permalink":"http://mariogogogo.github.io/2020/01/22/Axios%E5%B0%81%E8%A3%85/","excerpt":"2020.11.14更新axios的封装根据需求的不同而不同。这里非常感谢评论里一些很中肯的建议，我也对此进行了思考和针对不同需求的改善。主要有以下改变： 1.优化axios封装，去掉之前的get和post 2.断网情况处理 3.更加模块化的api管理 4.接口域名有多个的情况 5.api挂载到vue.prototype上省去引入的步骤","text":"2020.11.14更新axios的封装根据需求的不同而不同。这里非常感谢评论里一些很中肯的建议，我也对此进行了思考和针对不同需求的改善。主要有以下改变： 1.优化axios封装，去掉之前的get和post 2.断网情况处理 3.更加模块化的api管理 4.接口域名有多个的情况 5.api挂载到vue.prototype上省去引入的步骤 base.js 1234567const base = &#123; sq: &#x27;https://alibaba.com/api/v1&#x27;, bd: &#x27;http://alibaba.com/api/test&#x27;&#125;export default base; articleApi.js 1234567891011121314151617181920212223import base from &#x27;./base&#x27;; // 导入接口域名列表import axios from &#x27;./http&#x27;; // 导入http中创建的axios实例import qs from &#x27;qs&#x27;; // 根据需求是否导入qs模块const article = &#123; // 新闻列表 articleList () &#123; return axios.get(`$&#123;base.sq&#125;/topics`); &#125;, // 新闻详情,演示 articleDetail (id, params) &#123; return axios.get(`$&#123;base.sq&#125;/topic/$&#123;id&#125;`, &#123; params: params &#125;); &#125;, // post提交 login (params) &#123; return axios.post(`$&#123;base.sq&#125;/accesstoken`, qs.stringify(params)); &#125; // 其他接口…………&#125;export default article; http.js中axios封装的优化，先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &#x27;axios&#x27;;import router from &#x27;../router&#x27;;import store from &#x27;../store/index&#x27;;import &#123; Toast &#125; from &#x27;vant&#x27;;/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; &#123; Toast(&#123; message: msg, duration: 1000, forbidClick: true &#125;);&#125;/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123; router.replace(&#123; path: &#x27;/login&#x27;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;);&#125;/** * 请求失败后的错误统一处理 * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123; // 状态码判断 switch (status) &#123; // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip(&#x27;登录过期，请重新登录&#x27;); localStorage.removeItem(&#x27;token&#x27;); store.commit(&#x27;loginSuccess&#x27;, null); setTimeout(() =&gt; &#123; toLogin(); &#125;, 1000); break; // 404请求不存在 case 404: tip(&#x27;请求的资源不存在&#x27;); break; default: console.log(other); &#125;&#125;// 创建axios实例var instance = axios.create(&#123; timeout: 1000 * 12&#125;);// 设置post请求头instance.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */ instance.interceptors.request.use( config =&gt; &#123; // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error =&gt; &#123; const &#123; response &#125; = error; if (response) &#123; // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) &#123; store.commit(&#x27;changeNetwork&#x27;, false); &#125; else &#123; return Promise.reject(error); &#125; &#125; &#125;);export default instance; Index.js 12345678import article from &#x27;./articleApi&#x27;;// 其他模块的接口……// 导出接口export default &#123; article, // ……&#125; main.js 12import $api from &#x27;./utils/http&#x27;Vue.prototype.$api = $api 项目中使用 1234567891011121314methods: &#123;onRefresh() &#123; this.$api.article.articleDetail(&#x27;id&#x27;, &#123; api: 123 &#125;).then(res=&gt; &#123; // 执行某些操作 console.log(&#x27;res :&gt;&gt; &#x27;, res); &#125;) // setTimeout(() =&gt; &#123; // this.isLoading = false; // this.count++; // &#125;, 1000); &#125;,&#125; axios取消接口请求1.应用场景，为什么要取消请求我给你这样一个场景你变能理解为什么需要取消请求这种骚操作了（非常常见的场景，这里是用vue写的） 1.当我点击动态栏的时候，通过ajax获取当参数为2的时候的数据，然后在将原本参数为1的tab页的数据清空（默认进来展示的tab1）， 2.渲染tab2的页面，我们知道ajax是异步操作的，获取的数据过多或者用户网速较差的时候，这个获取数据的ajax操作需要一定的时间来将数据拿到再渲染到页面上 3.在这个时间段内，如果我再次点击tab3也就是“系统公告”的时候，代码又将id=3的参数传给后台，去获取tab3的数据，而id=2的时候的接口数据或许还在从服务器回到前台的路上 4.就想从tab1到tab2一样的我们去清空数组中盛放的tab2的数据，清空的是什么？tab2的数据还在返回来的路上还没被push进数组呢！所以这里我们清空了一次空数组！！！ 5.此时我们页面是处在tab3了，里面的数据因为是被push进去我们本地用来盛放数据的数组的，所以，此时的数据会是id=2的数据 &amp;&amp; id=3的数据，这样，问题就暴露出来了！ 解决思路 现在我得到的数据多余我要的 &gt; 多出来的数据是因为上一个tab页请求延迟造成的 &gt; 那我就在当前页请求数据的时候掐断上一个页面还没完成的请求就好了 在axios中取消接口请求操作好了，接下来才是我们的主题，Axios官方提供了一个取消接口请求的方法，但是怎么用这个方法官网写的很简略（不知道是不是我没找全的问题），反正官网的axios取消接口请求累的半死没看懂，后来是扒了很多大佬的博客，才自己理解出来的 Axios 提供了一个 CancelToken的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的，至于怎么用，看代码吧，我在代码中写了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div class=&quot;page&quot; id=&quot;app&quot;&gt; &lt;button @click=&quot;getMsg&quot; class=&quot;get-msg&quot;&gt;获取数据&lt;/button&gt; &lt;button @click=&quot;cancelGetMsg&quot; class=&quot;cancel&quot;&gt;取消获取&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27;, items: [], cancel: null &#125;, methods: &#123; getMsg () &#123; let CancelToken = axios.CancelToken let self = this axios.get(&#x27;http://jsonplaceholder.typicode.com/comments&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; self.cancel = c console.log(c) // 这个参数 c 就是CancelToken构造函数里面自带的取消请求的函数，这里把该函数当参数用 &#125;) &#125;).then(res =&gt; &#123; this.items = res.data &#125;).catch(err =&gt; &#123; console.log(err) &#125;) //手速够快就不用写这个定时器了，点击取消获取就可以看到效果了 setTimeout(function () &#123; //只要我们去调用了这个cancel()方法，没有完成请求的接口便会停止请求 self.cancel() &#125;, 100) &#125;, //cancelGetMsg 方法跟上面的setTimeout函数是一样的效果，因为手速不够快，哦不，是因为网速太快，导致我来不及点取消获取按钮，数据就获取成功了 cancelGetMsg () &#123; // 在这里去判断你的id 1 2 3，你默认是展示的tab1，点击的时候不管你上一个请求有没有执行完都去调用这个cancel()， this.cancel() &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 重复点击问题那我们经常开发的时候会遇到一个重复点击的问题，短时间内多次点击同一个按钮发送请求会加重服务器的负担，消耗浏览器的性能，多以绝大多数的时候我们需要做一个取消重复点击的操作 在vue开发中，这个方法一样完美解决这一问题，通常我们会封装一遍axios，这里我们便可以将此功能封装到拦截器里面去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 import axios from &#x27;axios&#x27;; axios.defaults.timeout = 5000; axios.defaults.baseURL =&#x27;&#x27;; let pending = []; //声明一个数组用于存储每个ajax请求的取消函数和ajax标识 let cancelToken = axios.CancelToken; let removePending = (ever) =&gt; &#123; for(let p in pending)&#123; if(pending[p].u === ever.url + &#x27;&amp;&#x27; + ever.method) &#123; //当当前请求在数组中存在时执行函数体 pending[p].f(); //执行取消操作 pending.splice(p, 1); //把这条记录从数组中移除 &#125; &#125; &#125; //http request 拦截器 axios.interceptors.request.use( config =&gt; &#123; config.data = JSON.stringify(config.data); config.headers = &#123; &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27; &#125; // ------------------------------------------------------------------------------------ removePending(config); //在一个ajax发送前执行一下取消操作 config.cancelToken = new cancelToken((c)=&gt;&#123; // 这里的ajax标识我是用请求地址&amp;请求方式拼接的字符串，当然你可以选择其他的一些方式 pending.push(&#123; u: config.url + &#x27;&amp;&#x27; + config.method, f: c &#125;); &#125;); // ----------------------------------------------------------------------------------------- return config; &#125;, error =&gt; &#123; return Promise.reject(err); &#125;);//http response 拦截器axios.interceptors.response.use( response =&gt; &#123; // ------------------------------------------------------------------------------------------ removePending(res.config); //在一个ajax响应后再执行一下取消操作，把已经完成的请求从pending中移除 // ------------------------------------------------------------------------------------------- if(response.data.errCode ==2)&#123; router.push(&#123; path:&quot;/login&quot;, querry:&#123;redirect:router.currentRoute.fullPath&#125;//从哪个页面跳转 &#125;) &#125; return response; &#125;, error =&gt; &#123; return Promise.reject(error) &#125;) 这是我自己项目用来封装axios的代码，里面加入了取消重复点击事件的方法（灵感来源于 大田角https://www.jianshu.com/p/4445595488e2），以后写项目一劳永逸啦，妈妈再也不用担心我的代码重复请求的问题啦！！ 完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &quot;axios&quot;;import router from &quot;../../router/index&quot;;import store from &quot;../../store/index&quot;;/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = (msg) =&gt; &#123; Toast(&#123; message: msg, duration: 1000, forbidClick: true, &#125;);&#125;;/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123; router.replace(&#123; path: &quot;/login&quot;, query: &#123; redirect: router.currentRoute.fullPath, &#125;, &#125;);&#125;;/** * 请求失败后的错误统一处理 * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123; // 状态码判断 switch (status) &#123; // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip(&quot;登录过期，请重新登录&quot;); localStorage.removeItem(&quot;token&quot;); store.commit(&quot;loginSuccess&quot;, null); setTimeout(() =&gt; &#123; toLogin(); &#125;, 1000); break; // 404请求不存在 case 404: tip(&quot;请求的资源不存在&quot;); break; default: console.log(other); &#125;&#125;;//声明一个数组用于存储每个请求的取消函数和axios标识let pending = [];let cancelToken = axios.CancelToken;let removePending = (config) =&gt; &#123; // 如果截取请求这样的：http://jsonplaceholder.typicode.com/posts?userId=2 const nurl = config.url.split(&#x27;=&#x27;)[0] console.log(&#x27;存储每个请求的取消函数和axios标识 :&gt;&gt; &#x27;, pending); for (let p in pending) &#123; console.log(&#x27;p :&gt;&gt; &#x27;, p); //当前请求在数组中存在时执行函数体 if (pending[p].u === nurl + &quot;&amp;&quot; + config.method) &#123; pending[p].f(); //执行取消操作 pending.splice(p, 1); &#125; &#125;&#125;;// 创建axios实例var instance = axios.create(&#123; timeout: 1000 * 12 &#125;);// 设置post请求头instance.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;;/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */instance.interceptors.request.use( (config) =&gt; &#123; // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 /**********取消请求*********/ removePending(config); //在一个axios发送前执行一下取消操作 console.log(&quot;在每一个axios发送前执行一下取消操作 :&gt;&gt; &quot;); config.cancelToken = new cancelToken((c) =&gt; &#123; // 这里的axios标识我是用请求地址&amp;请求方式拼接的字符串，当然你可以选择其他的一些方式 console.log(&#x27;c就是cancel函数 :&gt;&gt; &#x27;, c); console.log(&#x27;config.method :&gt;&gt; &#x27;, config.method); console.log(&#x27;config.url :&gt;&gt; &#x27;, config.url); const nurl = config.url.split(&#x27;=&#x27;)[0] pending.push(&#123; u: nurl + &quot;&amp;&quot; + config.method, f: c &#125;); &#125;); /************************/ const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, (error) =&gt; Promise.error(error));// 响应拦截器instance.interceptors.response.use( // 请求成功 // (res) =&gt; (res.status === 200 ? Promise.resolve(res) : Promise.reject(res)), (res) =&gt; &#123; removePending(res.config); //在一个axios响应后再执行一下取消操作，把已经完成的请求从pending中移除 return res.status === 200 ? Promise.resolve(res) : Promise.reject(res); &#125;, // 请求失败 (error) =&gt; &#123; console.log(&#x27;error :&gt;&gt; &#x27;, error); const &#123; response &#125; = error; if (response) &#123; // 请求已发出，但是不在2xx的范围 console.log(&#x27;error :&gt;&gt; &#x27;, response); errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) &#123; store.commit(&quot;changeNetwork&quot;, false); &#125; else &#123; return Promise.reject(error); &#125; &#125; &#125;);export default instance; 解决之后效果 参考掘金 vue axios重复点击取消上一次请求封装的方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"前端面试-原型及原型链","slug":"前端面试-原型及原型链","date":"2020-01-01T16:00:00.000Z","updated":"2021-01-29T01:28:28.000Z","comments":true,"path":"2020/01/02/前端面试-原型及原型链/","link":"","permalink":"http://mariogogogo.github.io/2020/01/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"2020 想跳槽一下，相关面试系列文章梳理","text":"2020 想跳槽一下，相关面试系列文章梳理 7建对象的几种方法通常三种 1234567891011//======1var a = &#123; name: &quot;jack&quot; &#125;;var a1 = new Object(&#123; name: &quot;jack&quot; &#125;);//======2var B = function() &#123; this.name = &quot;love&quot;;&#125;;var b1 = new B();//======3var c = &#123; name: &quot;petter&quot; &#125;;var c1 = Object.create(c); 构造函数–使用 new 运算符-&gt;生成一个实例。 函数都有一个prototype属性，创建函数的时候 js 自动生成的，这个属性会创建一个 空对象就是原型对象。原型对象如何区分我是被哪个构造函数所引用，原型对象中有一个(构造器)constructor会默认你声明(或者指向)的那个函数。 原型链我从我的原型对象向上找构造这个实例的相关联的对象；这个关联的对象再往上找它又有创造它的的原型对象，以此类推一直到 Object.prototype 为止.原型链的顶端 Object.prototype， 原型链靠什么向上找的过程：向上找主要靠 prototype 和——proto-这二个 原型对象与原型链起了什么作业当我构造函数中有很多属性和方法，我的实例就可以共用这些东西当我创建很多实例，要去共用这些方法和属性。我不能每个实例都拷贝这些属性和方法；他们之间其实可以共同存在一个地方（原型对象） 任何一个实例对象通过原型链找到它上面的原型对象的属性和方法这个是被实例所共享的； 一个实例没有找到属性或方法它就向原型对象上找，如果上级原型对象找不到则会根据原型对象的——proto-的原型对象上去找 注意： 构造函数才会有 prototype，对象没有 prototype。 实例对象才会有——proto-，如果发现函数也有-proto-。 函数也是对象, 1A._proto_ === Function.prototype; //true A 的原型对象就是 Function 的原型对象 instanceof 的原理实例对象的（-proto-）和构造函数的 prototype 是不是引用同一个地址a 继承 b，b 继承 ca 继承的对象用 instanceof 判断 b 或者 c 都返回 true，怎么区分是 b 的实例还是 c 的实例呢？这就用到 constructor 的属性是哪个构造函数 new 运算符背后原理 new 运算符后面跟的构造函数，一个新对象被创建，继承这个构造函数的原型对象(foo.prototype) 构造函数 foo 被执行，执行的时候相应的传参，同时上下文 this 被指定这个新实例，newfoo 等同于 new foo();只能用在不传参的情况下 如果构造函数返回了一个新’对象‘，那么这个对象会取代 new 出来的结果，如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象 123456789var new2 = function(func) &#123; var o = Object.create(func.prototype); var k = func.call(o); if (typeof k == &quot;object&quot;) &#123; return k; &#125; else &#123; return o; &#125;&#125;; 继承说到原型链还可以联系到继承 面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ 组合继承寄生组合继承","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试，Javascript，基础","slug":"面试，Javascript，基础","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJavascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"前端面试-React","slug":"前端面试-React","date":"2019-12-31T16:00:00.000Z","updated":"2020-09-16T09:07:10.000Z","comments":true,"path":"2020/01/01/前端面试-React/","link":"","permalink":"http://mariogogogo.github.io/2020/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-React/","excerpt":"能力遇到瓶颈，2020 想跳槽一下，相关面试系列文章梳理","text":"能力遇到瓶颈，2020 想跳槽一下，相关面试系列文章梳理 VdomJsx的本质是什么React.createElement 即是h函数，返回vnode patch(el,vnode) 和 patch(vnode,newvnode)更新 第一个参数可能是组件，也可能是html tag React生命周期有哪些，16版本生命周期发生了哪些变化？setState是同步的还是异步的？有时异步（普通使用） 有时同步（settimeout 自己定义的Dom事件） 有时合并（对象形式） 有时不合并（函数形式） 后者比较好理解（像object.assign) setState主流程 比如对比下同步和异步 函数执行的时候会初始一个isBatchingUpdate这个值为true，这个函数执行完设置false，settimeout和自定义事件执行后在触发setState函数的时候已经是false了，所以走右边的路线 batchUpdate机制 生命周期和它调用的函数 React注册的事件 React可以管理的入口 为什么有时连续多次 setState只有一次生效？React如何实现自己的事件机制？合成机制 event是SyntheticEvent （生散题k-evnt）模拟dom原生事件 event.nativeEvent是原生事件对象 所有事件都被挂载到doucument上 和dom事件不一样，和vue事件也不一样 通过合成事件去派发事件（通过event.target知道那个原生触发的，找到对应组件，组件中那个触发onclik事件） 把event传给对应触发的事件函数 为什么要用合成事件机制？更好的兼容性和跨平台。（摆脱dom事件逻辑） 挂载到document，减少内存消耗，避免频繁解绑，（滚动或者瀑布流事件，挂载到最外层，当组件销毁时候就不需要去解绑dom事件） 方便事件的统一管理（事务机制） 为何 React事件要自己绑定 this？在上面提到的事件处理流程中， React在 document上进行统一的事件分发， dispatchEvent通过循环调用所有层级的事件来模拟事件冒泡和捕获。 在 React源码中，当具体到某一事件处理函数将要调用时，将调用 invokeGuardedCallback方法。 可见，事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this是不准确的，所以我们需要手动将当前组件绑定到 this上。 原生事件和 React事件的区别？ React 事件使用驼峰命名，而不是全部小写。 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。 React和原生事件的执行顺序是什么？可以混用吗？React的所有事件都通过 document进行统一分发。当真实 Dom触发事件后冒泡到 document后才会对 React事件进行处理。 所以原生的事件会先执行，然后执行 React合成事件，最后执行真正在 document上挂载的事件 React事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation方法，则会导致其他 React事件失效。因为所有元素的事件将无法冒泡到 document上，导致所有的 React事件都将无法被触发。。 React组件的渲染流程是什么？ 使用 React.createElement或 JSX编写 React组件，实际上所有的 JSX代码最后都会转换成 React.createElement(...)， Babel帮助我们完成了这个转换的过程。 createElement函数对 key和 ref等特殊的 props进行处理，并获取 defaultProps对默认 props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个 ReactElement对象（所谓的虚拟 DOM）。 ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM`。 React更新过程怎么样首先props state更新 —&gt; dirComponents(可能是子组件) render()生成newvnode patch(el,vnode) 更新分2个节点 ： reconciliation（和解）阶段（执行diff js计算） 和 commit阶段 当组件足够复杂，组件更新时计算和渲染压力大，同时再有dom操作动画或鼠标需求将卡顿 解决方案fiber 将reconciliation阶段进行任务拆分（commit无法拆分） 浏览器需要支持requestIdleCallback。 虚拟Dom是什么？而 React会先将你的jsx代码转换成一个 JavaScript对象，然后这个 JavaScript对象再转换成真实 DOM。这个 JavaScript对象就是所谓的虚拟 DOM 虚拟Dom比 普通Dom更快吗？首次渲染， VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。 VitrualDom的优势在于 React的 Diff算法和批处理策略， React在页面更新之前，提前计算好了如何进行更新和渲染 DOM。实际上，这个计算过程我们在直接操作 DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如 React好的。所以，在这个过程中 React帮助我们”提升了性能”。 虚拟Dom中的 $$typeof属性的作用是什么？ 为什么代码中一定要引入 React？JSX只是为 React.createElement(component,props,...children)方法提供的语法糖。 所有的 JSX代码最后都会转换成 React.createElement(...)， Babel帮助我们完成了这个转换的过程。 所以使用了 JSX的代码都必须引入 React。 为什么 React组件首字母必须大写？babel在编译时会判断 JSX中组件的首字母，当首字母为小写时，其被认定为原生 DOM标签， createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement的第一个变量被编译为对象； React在渲染 真实Dom时做了哪些性能优化？ 什么是高阶组件？如何实现？ HOC在业务场景中有哪些实际应用场景？ 高阶组件( HOC)和 Mixin的异同点是什么？ Hook有哪些优势？ 异步组件按需加载 Reloadable库 （import ‘xx.page’).then","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试，Javascript，基础","slug":"面试，Javascript，基础","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJavascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"前端面试-JS 事件循环 EventLoop","slug":"前端面试-事件循环","date":"2019-12-31T16:00:00.000Z","updated":"2020-09-16T09:07:09.000Z","comments":true,"path":"2020/01/01/前端面试-事件循环/","link":"","permalink":"http://mariogogogo.github.io/2020/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"2020 想跳槽一下，相关面试系列文章梳理","text":"2020 想跳槽一下，相关面试系列文章梳理 JS 运行机制推荐 2 分钟视频讲的真不错 事件循环是个什么东西就我们所知，浏览器的 js 是单线程的，也就是说，在同一时刻，最多也只有一个代码段在执行，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？关于执行中的线程： 主线程：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行。工作线程：也称幕后线程，这个线程可能存在于浏览器或 js 引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件。 了解下阻塞还是非阻塞关于 js 阻塞还是非阻塞的问题，我觉得可以这么理解，不够在这之前，我们先理解下同步、异步、阻塞还是非阻塞的解释，在网上看到一段描述的非常好，引用下 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。（轮询）异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗最蠢）异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。（最机智） 任务队列同步任务优先于异步任务。 在同步队列被执行完之前，任何异步的操作都不会被执行 同步任务执行完之后才执行异步任务 运行机制1234for(vari=0;i&lt;4;i++)&lt;setTimeout(function () [console.log(i);), 1000); 涉及异步队列涉及的时间，浏览器发现 settimeout 不会马上放到运行栈里去，for 循环体执行完才去执行异步队列，异步队列没有到时间去收编 settimeout，再等待事件循环里处理 Event Loop 事件循环 运行栈运行的是同步任务。 浏览器识别了事件是一个异步任务，他不会把他放在运行栈里，而是拿走。 拿走了之后也不是立马放在异步队列中，同步任务执行完以后，再放入异步队列。 运行栈里没有任务了，就开始执行异步任务。 执行完后如果运行栈里没有任务了，再监听异步队列。 这个循环的过程就是 EventLoop 异步任务setTimeout 和 setIntervalDOM 事件Promise 12345678910for (var i = 0; i &lt; 4; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); console.log(&quot;one:&quot; + i); setTimeout(function() &#123; console.log(i + 1); &#125;, 0); console.log(&quot;two:&quot; + (i + 1));&#125; async/await 又是如何处理的呢 ？async/await： 这哥俩个其实是 Promise 和 Generator 的语法糖，所以我们把它们转成我们熟悉的 Promise 12345678910async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;// 等同于下面async function async1() &#123; console.log(&quot;async1 start&quot;); Promise.resolve(async2()).then(() =&gt; console.log(&quot;async1 end&quot;));&#125; 分析一道题123456789101112131415161718192021222324252627282930313233343536373839404142const p = new Promise((reslove, reject) =&gt; &#123; console.log(&quot;4&quot;); reslove(&quot;5&quot;);&#125;);function fun1() &#123; console.log(&quot;1&quot;);&#125;function fun2() &#123; setTimeout(() =&gt; &#123; console.log(&quot;2&quot;); &#125;, 0); fun1(); console.log(&quot;3&quot;); p.then((res) =&gt; &#123; fun3(); console.log(res); &#125;).then(() =&gt; &#123; console.log(&quot;6&quot;); &#125;);&#125;async function fun3() &#123; console.log(&quot;7&quot;); await fun4(); console.log(&quot;9&quot;);&#125;function fun4() &#123; setTimeout(() =&gt; &#123; console.log(&quot;8&quot;); &#125;, 3000); console.log(&quot;10&quot;);&#125;setTimeout(() =&gt; &#123; fun2();&#125;, 1000);console.log(&quot;0&quot;);// 4 0 1 3 7 10 5 9 6 2 8 分析如下执行第一条语句 new Promise 函数主动触发打印’4’ 走到底部的 setTimeout 遇到 fn2()放到消息队列，执行’0’ 调用栈清空，执行 fn2()函数，遇到 etTimeout 继续把里面的函数放到消息队列 执行 fun1()，打印’1’，弹出 fun1 执行’3’ 6.遇到 then()放到微任务中去， 调用栈又清空了，先执行微任务中的队列，fun3()执行，打印’7’ 遇到 awai 任务进去执行，又遇到 setTimeout，消息队列排队’8’, 执行’10‘ 回到刚才的地方执行 console.log(res)，打印’5‘ 执行’9’,继续执行第二个 then 打印‘6’ 11.调用栈清空，微任务队列也清空，最后执行消息队列中的‘2’，‘8’ 为什么 JavaScript 是单线程的？单线程意思就是说同一个时间只能做一件事。那这样的话效率不是很低？也没有啦，其实 javascript 的单线程特点是跟他的用途有关的。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。假如不是单线程的话，在一个线程当我们在给某个 DOM 节点增加内容的时候，另一个线程正在删除这个 DOM 节点的内容，那还得了，那不是乱套了吗。所以 javascript 只能是单线程是最优方案。 总结： 理解 js 单线程的概念 一个时间只能干一件事理解任务队列EventLoop哪些会被放入异步队列放入异步队列的时机","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试，Javascript，基础","slug":"面试，Javascript，基础","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJavascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"前端面试-算法","slug":"前端面试-算法","date":"2019-12-31T16:00:00.000Z","updated":"2020-09-16T09:07:10.000Z","comments":true,"path":"2020/01/01/前端面试-算法/","link":"","permalink":"http://mariogogogo.github.io/2020/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/","excerpt":"想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远。","text":"想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远。 选择排序基本思想1.默认第一个元素是最小值， 2.内循环从第二个（i+1）元素开始遍历找到比第一个元素小的，调换位置 3.继续循环 特点就是最快找到最小值或最大值 代码实现123456789101112131415161718192021222324252627282930313233343536373839/** * 判断是否是数组 * @param &#123;*&#125; array */function checkArray(array) &#123; return Array.isArray(array);&#125;/** * 位置交换 * @param &#123;*&#125; array * @param &#123;*&#125; left * @param &#123;*&#125; right */function swap(array, left, right) &#123; if (left &gt; array.length - 1 || right &gt; array.length - 1) &#123; return array; &#125; [ array[left], array[right] ] = [ array[right], array[left] ];&#125;/** * 选择排序 * 不断的从左边位置后找最小值 * 特点第一轮排序就已经找到了最小值 */function selection(arr) &#123; if (!checkArray(arr)) return; for (let i = 0; i &lt; arr.length - 1; i++) &#123; //初始最小值 最小值往左排， let miniIndex = i; // 每次排位一个 i+1位置继续排列 for (let j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; swap(arr, i, miniIndex); &#125; return arr;&#125;console.log(selection([ 2, 5, 6, 10, 2, 8 ])); 冒泡排序基本思想1.依次比较左右相邻2个位置大小， 2.如果大就换个位置继续比较。 3.外循环比较i是数组长度 递减–，这样内循环每次就缩小比较范围 能解决什么问题：1.查找数组间最大差值 2。奇偶排序 设置2个游标 分别指向奇 偶游标 代码实现123456789101112131415161718/** * 冒泡排序 * 特点第一轮排序就能找到最右边的最大值 */let a = [ 5, 4, 2, 1 ];function bubble(arr) &#123; if (!checkArray(arr)) return; for (let i = arr.length - 1; i &gt; 0; i--) &#123; // 下面的i是你下次要遍历的最大边界 for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; return arr;&#125;console.log(bubble(a)); 插入排序基本思想1.排序默认从第二个开始遍历 2.每一次遍历序号之前的元素全部遍历一遍，比较大小，交换位置 代码实现1234567891011121314151617181920212223242526272829/** * 插入排序 * 适合小型数组 算法比选择和冒泡性能好 * @param &#123;*&#125; array */function insertionSort(array) &#123; const &#123; length &#125; = array; let temp; //注意是从第二个位置开始 for (let i = 1; i &lt; length; i++) &#123; let j = i; temp = array[i]; //储存一个临时变量 //每一次都比较当前索引之前的序列全都比较一遍 //比如【3，2，1，5】，当前1 要跟 2 3都比较一遍 下一次5 跟 3，2，1 都比较一遍 //array[j - 1] 是前面一个数 temp后面一个数 while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125; return array;&#125;const array = [ 3, 5, 1, 4, 2 ];console.log(insertionSort(array)); 堆排序基本思想构造一个大顶堆，取堆顶也就是最大值 再将剩下的数字构建一个大顶堆，取堆顶数字 重复以上操作最终得到一个从大到小的数组 代码实现12345678910111213141516171819202122232425262728293031323334353637const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];// 堆排序function heapSort(array)&#123; console.time(&#x27;堆排序耗时&#x27;); // 初始化大顶堆，从第一个非叶子结点开始 for (let i = Math.floor(array.length / 2 - 1); i &gt;= 0; i--) &#123; heapify(array, i, array.length); &#125; // 排序，每一次 for 循环找出一个当前最大值，数组长度减一 for (let i = Math.floor(array.length - 1); i &gt; 0; i--) &#123; // 根节点与最后一个节点交换 swap(array, 0, i); // 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可 heapify(array, 0, i); &#125; console.timeEnd(&#x27;堆排序耗时&#x27;); return array;&#125;;//创建一个大顶堆const heapify = (array, i, length) =&gt; &#123; let temp = array[i]; // 当前父节点 // j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整 for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) &#123; temp = array[i]; // 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置 if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) &#123; j++; // 找到两个孩子中较大的一个，再与父节点比较 &#125; if (temp &lt; array[j]) &#123; swap(array, i, j); // 如果父节点小于子节点:交换；否则跳出 i = j; // 交换后，temp 的下标变为 j &#125; else &#123; break; &#125; &#125;&#125;;console.log(heapSort(array)); 希尔排序基本思想 希尔排序是对直接插入排序算法的优化和升级 先将整个待排序的记录序列分割成为若干子序列。 分别进行直接插入排序。 待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。 代码实现12345678910111213141516171819202122let arr = [ 98, 42, 25, 54, 15, 3, 25, 72, 41, 10, 121 ];function shellSort(array) &#123; //初始化步长 arr长度的一半 let gap = Math.floor(array.length / 2); while (1 &lt;= gap) &#123; // 把距离为 gap 的元素编为一个组，扫描所有组 for (let i = gap; i &lt; array.length; i++) &#123; let j = 0; let temp = array[i]; //依次3, 25, 72, 41, 10, 121 // 对距离为 gap 的元素组进行排序 for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j -= gap) &#123; //如果右边比左边小则交换位置 swap(array, j, j + gap); &#125; &#125; gap = Math.floor(gap / 2); // 减小增量 &#125; return array;&#125;console.log(shellSort(arr)); 归并排序基本思想代码实现123456789101112131415161718192021222324252627282930313233343536/** * 归并排序 * 思想将序列中带序号数字分成若干组，每个数字分一组 * 将若干组22 合并 合并后保证有序 * 重复第二步直到只剩一组 排序完成 */const arr = [ 19, 97, 09, 17, 01, 08, 02 ];function mergeSort(array) &#123; // 判断数组长度1 表示已经分组 if (array.length &gt; 1) &#123; const &#123; length &#125; = array; //找中间元素 const middle = Math.floor(length / 2); //分左右二组 const left = mergeSort(array.slice(0, middle)); const right = mergeSort(array.slice(middle, length)); array = merge(left, right); &#125; return array;&#125;function merge(left, right) &#123; let i = 0; let j = 0; const result = []; while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123; //判断每一个数组第一个元素左边大还是右边大 比如 [3,4,5] [1,2] //比较后把那个大的数组后面的数字也一同加入新数组中 result.push(left[i] &lt; right[j] ? left[i++] : right[j++]); &#125; return result.concat(i &lt; left.length ? left.slice(i) : right.slice(j));&#125;console.log(mergeSort(arr)); 快速排序基本思想 从中间数组找一个值 设计2个双指针左右各一个 左边找比中间值小的元素，右边找比它大的元素 交换他们 左边超过右边则停止比较 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 快速排序 * 从中间数组找一个值 * 设计2个双指针左右各一个 * 左边找比中间值小的元素，右边找比它大的元素 交换他们 * 直到左超过了右边 */function quickSort(array) &#123; //传数组的下标 return quick(array, 0, array.length - 1);&#125;function quick(array, left, right) &#123; let index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); //[3,5,1,2,4] &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array;&#125;function partition(array, left, right) &#123; // 找到中心轴的数字 const pivot = array[Math.floor((right + left) / 2)]; // 双指针 let i = left; let j = right; // 满足双指针重合就停止 while (i &lt;= j) &#123; // 找到比中心轴小的数字则放左边，继续++ while (array[i] &lt; pivot) &#123; i++; &#125; // 找到比中心轴大的数字则放右边，继续-- while (array[j] &gt; pivot) &#123; j--; &#125; if (i &lt;= j) &#123; swap(array, i, j); i++; j--; &#125; &#125; return i;&#125;console.log(quickSort([ 3, 5, 1, 6, 4, 7, 2 ])); 桶排序基本思想代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 桶排序 */function bucketSort(array, bucketSize = 5) &#123; if (array.length &lt; 2) return array; const bucket = createBuckets(array, bucketSize); return sortBuckets(buckets);&#125;function createBuckets(array, bucketSize) &#123; //初始化最大值最小值 let miniValue = array[0], maxValue = array[0]; // 寻找最大值最小值; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] &lt; miniValue) &#123; miniValue = array[i]; &#125; else if (array[i] &gt; maxValue) &#123; maxValue = array[i]; &#125; &#125; //分配每一个桶的容量大小 const bucketCount = Math.floor((maxValue - miniValue) / bucketSize + 1); const buckets = []; //分配桶 for (let i = 0; i &lt; bucketCount; i++) &#123; buckets[i] = []; &#125; // 把数组中的值放入相应的桶中 for (let i = 0; i &lt; array.length; i++) &#123; //计算将元素放到哪个桶中 const bucketIndex = Math.floor((array[i] - miniValue) / bucketSize); buckets[bucketIndex].push(array[i]); &#125; return buckets;&#125;/** * 每一个桶排序 * @param &#123;*&#125; buckets */function sortBuckets(buckets) &#123; //初始化一个新数组 const sortedArray = []; for (let i = 0; i &lt; buckets.length; i++) &#123; if (buckets[i] != null) &#123; //插入排序 insertionSort(buckets[i]); //加入新数组 sortedArray.push(...buckets[i]); &#125; &#125; return sortedArray;&#125; 计数排序基本思想 求最大值就知道需要的数组有多长（非常消耗内存，开辟数组在内存空间大小） 把每一个值作为下标放入对应counts数组中，出现的次数作为值,次数越多值越大 循环counts把下标把值都放入array数组中，返回array就是排好序的数组 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 计数排序 */function findMaxValue(array) &#123; let max = array[0]; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; return max;&#125;function countingSort(array) &#123; if (array.length &lt; 2) &#123; return array; &#125; const maxValue = findMaxValue(array); //创建计数数组 数组从0开始 所以要+1 const counts = new Array(maxValue + 1); array.forEach((item) =&gt; &#123; //item是下标值，如果不存在则初始为0 if (!counts[item]) &#123; counts[item] = 0; &#125; //接着+1 次 counts[item]++; &#125;); // 索引 let sortedIndex = 0; counts.forEach((item, i) =&gt; &#123; //item是出现的次数直到剪到0次 如【1，2，2】 while (item &gt; 0) &#123; array[sortedIndex++] = i; item--; &#125; &#125;); return array;&#125;console.log(countingSort([ 4, 3, 2, 1 ])); 基数排序基本思想其实就是桶思想的一种 先排个位数，十位数 百位数 千位数。。放入桶里 如何去判断个位数 十位数 百位数 比如 421 个位数是1 ，那我们是不是取模， 421 /1 = 42 余数就是1，十位数 421 /10 余数是 2 百位数 421 /100 余数是4 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const array = [ 19, 240, 100, 532, 305, 430, 124 ];function findMinValue(array) &#123; ... return min;&#125;function findMaxValue(array) &#123; ... return max;&#125;/** * 分布式排序算法 * 根据进制去选择 * @param &#123;&#x27;*&#x27;&#125; array * @param &#123;*&#125; radixBase 10进制 就参数10 8进制就选8 */function radixSort(array, radixBase = 10) &#123; if (array.length &lt; 2) &#123; return array; &#125; const minValue = findMinValue(array); const maxValue = findMaxValue(array); //从最后一位开始排序所有数 let significantDigit = 1; // 后续进行第二个有效位数排序 第三个有效位数排序 直到没有待排序的有效位 // 比如 （999 - 900） /1 /10 /100 （99-19） /1 /10 但是/100就不行了 while ((maxValue - minValue) / significantDigit &gt;= 1) &#123; //获取每一次有效位后排好的数组，直到最后没有有效位 array = countingSortForRadix(array, radixBase, significantDigit, minValue); significantDigit *= radixBase; &#125; return array;&#125;function countingSortForRadix(array, radixBase, significantDigit, minValue) &#123; let bucketsIndex; // 基数初始化桶 const buckets = []; // 创建临时数组 作用：帮助后面移值到原始数组中 const tmp = []; for (let i = 0; i &lt; radixBase; i++) &#123; buckets[i] = 0; &#125; //[ 421, 240, 100, 532, 305, 430, 124 ] //第二次 【240,100,430,421,532,124,305】 for (let i = 0; i &lt; array.length; i++) &#123; //计算有效位进行计数排序 bucketsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase); //累计出现的次数 buckets[bucketsIndex]++; // ==== 0 1 2 3 4 5.... // 1次 2次 0次。。。 &#125; // 第一次循环个位数出现的次数 // 0:3 // 1:1 // 2:1 // 3:0 // 4:1 // 5:1 // 6:0 // 7:0 // 8:0 // 9:0 // 累积结果得到计数值 for (let i = 1; i &lt; radixBase; i++) &#123; buckets[i] += buckets[i - 1]; &#125; console.log(&#x27;累积结果得到计数值&#x27;, buckets); // 倒叙重新放入临时数组; for (let i = array.length - 1; i &gt;= 0; i--) &#123; //计算有效位进行计数排序 bucketsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase); //找buckets中有效位对应的下标 tmp[--buckets[bucketsIndex]] = array[i]; &#125; // 把临时数组新排好给array return tmp;&#125;console.log(radixSort(array)); 参考算法之美 JavaScript 数据结构与算法第三版 bilibili网上教程","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试，Javascript，基础","slug":"面试，Javascript，基础","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJavascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"前端面试-CSS 相关","slug":"前端面试-CSS相关","date":"2019-12-31T16:00:00.000Z","updated":"2020-09-16T09:07:10.000Z","comments":true,"path":"2020/01/01/前端面试-CSS相关/","link":"","permalink":"http://mariogogogo.github.io/2020/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-CSS%E7%9B%B8%E5%85%B3/","excerpt":"2020 想跳槽一下，相关面试系列文章梳理","text":"2020 想跳槽一下，相关面试系列文章梳理 CSS 盒模型标准模型和 IE 模型 区别标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin低版本 IE 盒子模型：宽度=内容宽度（content+border+padding）+ margin css 如何设置这 2 种模型box-sizing：content-box 标准模型 （默认）box-sizing：border-box ie 模型 比如：对比 CSS 选择器有哪些？哪些属性可以继承？CSS 选择符： id 选择器(#myid) 类选择器(.myclassname) 标签选择器(div, h1, p) 相邻选择器(h1 + p) 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=”external”]） 伪类选择器（a:hover, li:nth-child） 可继承的属性：font-size, font-family, color 不可继承的样式：border, padding, margin, width, height 优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ] !important 比内联优先级高 CSS3 新增伪类有那些?p:first-of-type 选择属于其父元素的首个元素p:last-of-type 选择属于其父元素的最后元素p:only-of-type 选择属于其父元素唯一的元素p:only-child 选择属于其父元素的唯一子元素p:nth-child(2) 选择属于其父元素的第二个子元素:enabled :disabled 表单控件的禁用状态。:checked 单选框或复选框被选中。 display 有哪些值？ position 的值？inline（默认）–内联none–隐藏block–块显示table–表格显示list-item–项目列表inline-block static（默认）：按照正常文档流进行排列；relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right 定位；fixed(固定定位)：所固定的参照对像是可视窗口。 display:none 与 visibility：hidden 的区别？display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘） visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘） position:fixed;在 android 下无效怎么处理？1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms。 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?参数是 scroll 时候，必会出现滚动条。参数是 auto 时候，子元素内容大于父元素时出现滚动条。参数是 visible 时候，溢出的内容出现在父元素之外。参数是 hidden 时候，溢出隐 JS 如何获取盒模型的宽和高dom.style.widht/height (只限内联样式的宽和高） 如果不是内联元素就取不到对应的值 然后我们试试这个dom.currentStyle.width/height (渲染以后得到的宽和高） 只有 ie 支持window.getComputedStyle(dom).width/height 谷歌火狐支持 dom.getBoundClientRect().width/height 非常重要 计算元素的绝对位置 （视窗左上角相对元素的位置） 思考一个问题 为什么 bottom 与 left 的值不一样？？ 盒模型解释边距重叠 BFC 边距重叠解决方案概念（块级格式化上下文） 边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。两个或多个块级盒子的垂直相邻边界会重合，它们的边界宽度是相邻边界宽度中的最大值。注意水平边界是不会重合的。 兄弟元素重叠 取最大值（上下）空元素 边距重叠 原理 bfc 这个元素的垂直方向的边距会发生重叠 bfc 的区域不会与浮动元素的区域重叠 （清除浮动） bfc 的页面是一个独立的容器 外面的元素不会影响里面的元素 计算 bfc 高度的时候 浮动元素也会参与计算 创建 BFCfloat 值不为 none 只要创建了浮动就创建了 BFCoverflow：hiddenposition 不是 realtive 或者display table flex BFC 的使用场景一种情况 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #wrapper &#123; background: lightpink; overflow: hidden; &#125; #wrapper &gt; p &#123; margin: 5px auto 25px; background: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;div style=&quot;overflow: hidden;&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 给子元素的增加一个父级，父级设置overflow: hidden可以解决这个上下边距重叠的问题 另一种情况 1234567891011121314151617181920&lt;section class=&quot;float&quot;&gt; &lt;style&gt; .float &#123; background: red; &#125; .left &#123; float: left; width: 100px; height: 100px; background: #008000; &#125; .right &#123; height: 110px; background: peru; overflow: auto; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt; 创建 bfc 之后的效果 第三种场景 12345678910111213&lt;section class=&quot;float&quot;&gt; &lt;style&gt; .float &#123; background: hotpink; &#125; .left &#123; float: left; font-size: 22px; background: #008000; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;浮动&lt;/div&gt;&lt;/section&gt; BFC 子元素既是 float 元素也会参与高度计算 如图： 水平居中与垂直居中 水平居中1.1 行内元素123.parent &#123; text-align: center;&#125; 1.2 块级元素1.2.1 块级元素一般居中方法123.son &#123; margin: 0 auto;&#125; 1.2.2 子元素含 floatfit-content以下两种情况下的较大值: 1.固有的最小宽度 2.固有首选宽度（max-content）和可用宽度（available）的较小值 12345678.parent &#123; width: fit-content; margin: 0 auto;&#125;.son &#123; foat: left;&#125; 1.2.3 Flex 弹性盒子1） flex 2012 版 1234.parent &#123; display: flex; justify-content: center;&#125; 1.2.4 绝对定位1）transform 12345.son &#123; position: absolute; left: 50%; transform: translate(-50%, 0);&#125; 2）left: 50% 123456.son &#123; position: absolute; width: 宽度; left: 50%; margin-left: -0.5*宽度&#125; 3）left/right: 0 1234567.son &#123; position: absolute; width: 宽度; left: 0; right: 0; margin: 0 auto;&#125; 二、垂直居中2.1 行内元素1234567.parent &#123; height: 高度;&#125;.son &#123; line-height: 高度;&#125; 注：① 子元素 line-height 值为父元素 height 值。② 单行文本。 2.2 块级元素2.2.1 行内块级元素12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle;&#125;.parent::after&#123; content:&#x27;&#x27;; height:100%;&#125; 适应 IE7。 2.2.2 table1234567.parent &#123; display: table;&#125;.son &#123; display: table-cell; vertical-align: middle;&#125; 优点 元素高度可以动态改变, 不需再 CSS 中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断。 缺点 IE6~7, 甚至 IE8 beta 中无效。 2.2.3 Flex 弹性盒子1）flex 2012 版 123456.parent &#123; display: flex; align-items: center;&#125; 优点 内容块的宽高任意, 优雅的溢出。 可用于更复杂高级的布局技术中。 缺点 IE8/IE9 不支持。 需要浏览器厂商前缀。 渲染上可能会有一些问题。 2.2.4 绝对定位1）transform 12345.son &#123; position: absolute; top: 50%; transform: translate( 0, -50%);&#125; 优点 代码少。 缺点 IE8 不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象。 2）top: 50% 12345678.son &#123; position: absolute; top: 50%; height: 高度; margin-top: -0.5高度;&#125; 优点 适用于所有浏览器。 缺点 父元素空间不够时, 子元素可能不可见 (当浏览器窗口缩小时, 滚动条不出现时). 如果子元素设置了 overflow:auto, 则高度不够时, 会出现滚动条。 3）top/bottom: 0; 123456.son &#123; position: absolute; top: 0; bottom: 0; margin: auto 0;&#125; 优点 简单。 缺点 没有足够空间时, 子元素会被截断, 但不会有滚动条。 三栏布局的五种写法已知高度, 左右距离固定, 中间自适应三栏布局在 html 很常见，基础知识回顾 双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间 middle 多了一个子容器存在，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度。 最常见的圣杯布局实现方法关键点 圣杯布局的关键点是通过 margin-left 与 left 属性将左右两列放置到准确的位置 圣杯布局的关键点父元素需要设置 padding 圣杯布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的 最常见的双飞翼布局实现方法关键点 双飞翼布局的关键点是通过 margin-left 属性将左右两列放置到准确的位置，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度 双飞翼布局的关键点父元素不需要设置 padding 双飞翼布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的 浮动布局方法-12345678910111213141516171819202122232425262728&lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; .layout.float .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; table-cell 布局方法-123456789101112131415161718192021222324252627282930313233343536&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left-mid-right &#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-mid-right &gt; div &#123; display: table-cell; &#125; .layout.table .left &#123; width: 300px; background: red; &#125; .layout.table .right &#123; width: 300px; background: blue; &#125; .layout.table .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flexbox布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; flex 布局方法-1234567891011121314151617181920212223242526272829303132333435&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox &#123; margin-top: 130px; &#125; .layout.flexbox .left-mid-right &#123; display: flex; &#125; .layout.flexbox .left &#123; width: 300px; background: red; &#125; .layout.flexbox .right &#123; width: 300px; background: blue; &#125; .layout.flexbox .mid &#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flexbox布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 定位布局方法-12345678910111213141516171819202122232425262728293031323334&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left-mid-right &gt; div &#123; position: absolute; &#125; .layout.absolute .left &#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .right &#123; right: 0; width: 300px; background: blue; &#125; .layout.absolute .mid &#123; left: 300px; right: 300px; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;绝对定位&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; grid 布局方法-1234567891011121314151617181920212223242526272829303132&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left-mid-right &#123; display: grid; width: 100%; height: 100px; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left &#123; background: red; &#125; .layout.grid .right &#123; background: blue; &#125; .layout.grid .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;网格布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 扩展问题 扩展每个布局的优缺点浮动：脱离文档流（必须清浮动） 优点：兼容性比较好定位：脱离文档流 你后面的子元素也必须脱离文档流，效果比较差 优点：快捷、flex：css3 中出现解决上述 2 种布局的缺点；表格：优点：在一定的场景下兼容性还不错，缺点如果某一列的高度增加了则其他 2 列的高度也会同样增加网格：新技术，网格布局 优缺点. 不是所有的浏览器都支持 grid 高度去掉之后 哪个方案就不适用了浮动 x 扩展点： 浮动如何清除 BFC 是什么定位 xflex ✔️表格 ✔️grid x 兼容性哪个比较好，项目中用哪个最好？ 写页面的时候还需要注意语义化：section 章 ，article 容器 上下高度固定，中间自适应定位布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;section class=&quot;layout abosult&quot;&gt; &lt;style&gt; .layout.abosult .top-mid-bottom &#123; position: relative; height: 100vh; width: 100vw; background: #14e014; &#125; .layout.abosult .top &#123; position: absolute; top: 0; left: 0; width: 100vw; height: 300px; background: red; &#125; .layout.abosult .bottom &#123; position: absolute; bottom: 0; left: 0; width: 100vh; height: 300px; background: blue; &#125; .layout.abosult .mid &#123; position: absolute; width: 100vw; top: 300px; bottom: 300px; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;top-mid-bottom&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;定位解决方案&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; flex 布局 1234567891011121314151617181920212223242526272829303132333435363738&lt;section class=&quot;layout flex&quot;&gt; &lt;style&gt; .layout.flex .top-mid-bottom &#123; display: flex; flex-direction: column; height: 100vh; width: 100vw; background: #14e014; &#125; .layout.flex .top &#123; width: 100vw; height: 300px; background: red; &#125; .layout.flex .bottom &#123; width: 100vh; height: 300px; background: blue; &#125; .layout.flex .mid &#123; flex: 1; width: 100vw; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;top-mid-bottom&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flex解决方案&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; table 布局 1234567891011121314151617181920212223242526272829&lt;section class=&quot;table-top-center-bottom&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .table-top-center-bottom &#123; width: 100vw; height: 100vh; display: table; &#125; .table-top &#123; display: table-row; height: 300px; width: 100%; background: yellow; &#125; .table-center &#123; display: table-row; width: 100%; background: #ff3c4a; &#125; .table-bottom &#123; display: table-row; height: 300px; width: 100%; background: #49a094; &#125; &lt;/style&gt; &lt;div class=&quot;table-top&quot;&gt;上&lt;/div&gt; &lt;div class=&quot;table-center&quot;&gt;table-布局 -中&lt;/div&gt; &lt;div class=&quot;table-bottom&quot;&gt;下&lt;/div&gt;&lt;/section&gt; grid 布局 123456789101112131415161718192021222324252627282930313233&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .top-mid-bottom &#123; display: grid; grid-template-row: 300px auto 300px; height: 100vh; background: #14e014; &#125; .layout.grid .top &#123; width: 100vw; background: red; &#125; .layout.grid .bottom &#123; width: 100vh; background: blue; &#125; .layout.grid .mid &#123; width: 100vw; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;top-mid-bottom&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flex解决方案&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 参考《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？","categories":[{"name":"面试","slug":"面试","permalink":"http://mariogogogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试，Javascript，基础","slug":"面试，Javascript，基础","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJavascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"Docker 初体验打造超溜的前端环境","slug":"Docker初体验","date":"2019-12-30T16:00:00.000Z","updated":"2020-09-16T09:07:18.000Z","comments":true,"path":"2019/12/31/Docker初体验/","link":"","permalink":"http://mariogogogo.github.io/2019/12/31/Docker%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"总结一下有如下问题：手动部署成本太高，改错别字都很麻烦一台服务器由于时间累积导致环境变得“脏乱差”重装系统成本太高，难以迁移","text":"总结一下有如下问题：手动部署成本太高，改错别字都很麻烦一台服务器由于时间累积导致环境变得“脏乱差”重装系统成本太高，难以迁移 而 Docker，正是我解决所有问题 SCP-500 万能药！那么 Docker 是如何做的呢？镜像与容器Docker 中有两个重要概念。一个是容器（Container）：容器特别像一个虚拟机，容器中运行着一个完整的操作系统。可以在容器中装 Nodejs，可以执行 npm install，可以做一切你当前操作系统能做的事情另一个是镜像（Image）：镜像是一个文件，它是用来创建容器的。如果你有装过 Windows 操作系统，那么 Docker 镜像特别像“Win7 纯净版.rar”文件上边就是你所需要了解的 Docker 全部基础知识。就这么简单顺便一提，在 Docker 中，我们通常称你当前使用的真实操作系统为“宿主机”(Host) 写个 vue+node 的案例实战下目录结构 12345678910111213141516171819202122232425262728293031323334├── vue_docker //vue项目│ ├── Dockerfile│ ├── README.md│ ├── babel.config.js│ ├── dist│ │ ├── css│ │ ├── favicon.ico│ │ ├── img│ │ ├── index.html│ │ └── js│ ├── docker-compose.debug.yml│ ├── docker-compose.yml│ ├── nginx //nginx配置信息│ │ └── default.conf│ ├── package.json│ ├── public│ │ ├── favicon.ico│ │ └── index.html│ ├── src│ │ ├── App.vue│ │ ├── assets│ │ ├── components│ │ ├── main.js│ │ ├── router│ │ └── views│ └── yarn.lock└── vue_docker_server //node项目 ├── Dockerfile ├── docker-compose.debug.yml ├── docker-compose.yml ├── package.json ├── server.js ├── test.txt └── yarn.lock 部署 vue过程省略了写过 vue 的都知道… 1yarn build 部署 node创建 server.js 12345678910111213141516171819const Koa = require(&quot;koa&quot;);const app = new Koa();const router = require(&quot;koa-router&quot;)();const bodyParser = require(&quot;koa-bodyparser&quot;);app.use(bodyParser());app.use(router.routes());router.get(&quot;/&quot;, async (ctx, next) =&gt; &#123; ctx.response.body = &quot;hello,word&quot;;&#125;);router.get(&quot;/api/json&quot;, async (ctx, next) =&gt; &#123; ctx.body = &#123; code: 0, data: &quot;This is message from node container&quot; &#125;;&#125;);app.listen(8000);console.log(&quot;http://localhost:8000&quot;); 部署 nginx config 配置文件123456789101112131415161718192021222324252627282930313233343536//路径:/nginx/default.conf/server &#123; listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/error.log error; location / &#123; # 这个是nginx的默认文件路径 # root /usr/share/nginx/html; # 自定义的nginx显示路径 root /home/web/app; index index.html index.htm; &#125; # 代理以 api 为前缀的请求 location ~^/api &#123; proxy_pass http://192.168.8.93:8000; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; # root /usr/share/nginx/html; root /home/web/app; &#125;&#125; docker 二种启动模式Dockerfile 启动在 vue 项目根目录创建 Dockerfile 文件配置如下 123FROM nginxCOPY dist/ /usr/share/nginx/html/COPY nginx/default.conf /etc/nginx/conf.d/default.conf 自定义构建镜像的时候基于Dockerfile来构建。 FROM nginx 命令的意思该镜像是基于 nginx:latest 镜像而构建的。 COPY dist/ /usr/share/nginx/html/ 命令的意思是将项目根目录下 dist 文件夹下的所有文件复制到镜像中 /usr/share/nginx/html/ 目录下。 COPY nginx/default.conf /etc/nginx/conf.d/default.conf 命令的意思是将 nginx 目录下的 default.conf 复制到 etc/nginx/conf.d/default.conf，用本地的 default.conf 配置来替换 nginx 镜像里的默认配置。 执行命令 1docker build -t vuenginxcontainer . -t 是给镜像命名 .是基于当前目录的 Dockerfile 来构建镜像 1docker image ls | grep vuenginxcontainer 到此时我们的 vue 应用镜像 vuenginxcontainer 已经成功创建。接下来，我们基于该镜像启动一个 docker 容器。 基于 vuenginxcontainer 镜像启动容器，运行命令： 1234docker run \\-p 3000:80 \\-d --name vueApp \\vuenginxcontainer docker run 基于镜像启动一个容器 -p 3000:80 端口映射，将宿主的 3000 端口映射到容器的 80 端口 -d 后台方式运行 --name 容器名 查看 docker 进程 docker ps可以发现名为 vueApp 的容器已经运行起来。此时访问 http://localhost:3000 应该就能访问到该 vue 应用 node_docker 部署123456789101112FROM nodeWORKDIR /usr/src/appCOPY package*.json ./RUN npm installCOPY . .EXPOSE 8080CMD [ &quot;npm&quot;, &quot;start&quot; ] 执行 1docker build -t nodewebserver . 启动 1234docker run \\-p 5000:8080 \\-d --name nodeserver \\nodewebserver docker-compose 启动vue 项目 docker-compose 配置1234567891011121314151617version: &quot;2&quot;services: # 服务名称 nginx: # 镜像:版本 image: nginx # 映射容器80端口到本地80端口 ports: - &quot;3000:80&quot; # 数据卷 映射本地文件到容器 volumes: # 映射nginx.conf文件到容器的/etc/nginx/conf.d目录并覆盖default.conf文件 - ./nginx/default.conf:/etc/nginx/conf.d/default.conf # 映射build文件夹到容器的/usr/share/nginx/html文件夹与config中的root路径一致 - ./dist:/home/web/app # 覆盖容器启动后默认执行的命令。 command: /bin/bash -c &quot;nginx -g &#x27;daemon off;&#x27;&quot; 启动 1234docker-compose up -d//关闭docker-compose down node 项目 docker-compose 配置12345678910111213version: &quot;3&quot;services: web: image: node:10.13-alpine user: node working_dir: /home/node/app environment: - PORT=8000 volumes: - ./:/home/node/app # 将本地目录映射到容器内 command: [&quot;node&quot;, &quot;server.js&quot;] # 运行命令 ports: - 8000:8000 # 本地端口:容器端口 启动 1234docker-compose up -d//关闭docker-compose down 跨域转发想要将 vueApp 容器 上的请求转发到 nodeserver 容器上。首先需要知道 nodeserver 容器的 ip 地址和端口，目前已知 nodeserver 容器内部服务监听在 8080 端口，还需要知道 ip 即可。 如何查看容器地址? docker inspect 02277acc3efc 1234567# 代理以 api 为前缀的请求 location ~^/api &#123; proxy_pass http://192.168.8.93:8000; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; docker-compose.yml 配置详解每个 docker-compose.yml 必须定义 image 或者 build 中的一个，其它的是可选的。 image指定镜像 tag 或者 ID。示例： 12345image: redis 或者 node 或者 nginximage: ubuntu:14.04image: tutum/influxdbimage: example-registry.com:4000/postgresqlimage: a4bc65fd 脚本执行内容只是把以上命令整合到一起执行： 12345678910111213141516171819202122232425262728293031323334353637# 备份原代码tar -zcvf gentle-vue.tar ./gentle-vue# 删除原代码文件夹rm -rf gentle-vue# 拉取代码git clone https://gitee.com/FJ_WoMenDeShiJie/gentle-vue.gitecho -e &quot;\\033[32m\\n代码拉取\\n\\033[0m&quot;# 拷贝 node_modulescp ./node.tar ./gentle-vue# build 打包 vue 项目，生成 dist 文件夹cd ./gentle-vuetar -zxvf node.tarnpm run buildecho -e &quot;\\033[32m\\nvue项目打包完成\\n\\033[0m&quot;# 删除原镜像docker rmi gentle-vue &amp;&gt; /dev/nullecho -e &quot;\\033[32m\\n删除原镜像文件\\n\\033[0m&quot;# 拷贝 dockerfile 到工程目录下cp ../dockerfile ./# 构建镜像docker build -t gentle-vue .echo -e &quot;\\033[32m\\n新镜像构建成功\\n\\033[0m&quot;# 删除原容器docker rm -f gentle-vue# 启动容器docker run -p 3000:80 -d --name gentle-vue gentle-vueecho -e &quot;\\033[32m\\n前端工程部署完成\\n\\033[0m&quot;这样部署就方便多了。 Docker 的常用命令镜像常用命令123456789docker pull [镜像名称:版本] 拉取镜像docker images 镜像列表docker rmi [镜像名称:版本] 删除镜像docker history [镜像名称] 镜像操作记录docker tag [镜像名称:版本][新镜像名称:新版本]docker inspect [镜像名称:版本] 查看镜像详细docker search [关键字] 搜索镜像docker login 镜像登陆 容器常用命令12345678910111213docker ps -a 容器列表(所有容器)docker ps 查看所有(运行的)容器docker exec -ti &lt;id&gt; bash 以 bash 命令进入容器内docker run -ti --name [容器名称][镜像名称:版本] bash 启动容器并进入docker logs 查看容器日志docker top &lt;container_id&gt; 查看容器最近的一个进程docker run -ti --name [容器名称] -p 8080:80 [镜像名称:版本] bash 端口映射docker rm &lt;container_id&gt; 删除容器docker stop &lt;container_id&gt; 停止容器docker start &lt;container_id&gt; 开启容器docker restart &lt;container_id&gt; 重启容器docker inspect &lt;container_id&gt; 查看容器详情docker commit [容器名称] my_image:v1.0 容器提交为新的镜像 参考前端工程师学 Docker ？ 看这篇就够了 Docker 搭建你的第一个 Node 项目到服务器 Docker 打造超溜的前端环境 使用 docker-compose 替代 docker run 官方文档","categories":[{"name":"Docker","slug":"Docker","permalink":"http://mariogogogo.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://mariogogogo.github.io/tags/Docker/"}]},{"title":"前端路由原理解析和实现","slug":"前端路由的原理解析与实现","date":"2019-12-14T16:00:00.000Z","updated":"2020-09-16T09:07:09.000Z","comments":true,"path":"2019/12/15/前端路由的原理解析与实现/","link":"","permalink":"http://mariogogogo.github.io/2019/12/15/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"在单页应用如此流行的今天，曾经令人惊叹的前端路由已经成为各大框架的基础标配，每个框架都提供了强大的路由功能，导致路由实现变的复杂。想要搞懂路由内部实现还是有些困难的，但是如果只想了解路由实现基本原理还是比较简单的。本文针对前端路由主流的实现方式 hash 和 history，提供了原生 JS/React/Vue 共计六个版本供参考，每个版本的实现代码约 25~40 行左右（含空行）。","text":"在单页应用如此流行的今天，曾经令人惊叹的前端路由已经成为各大框架的基础标配，每个框架都提供了强大的路由功能，导致路由实现变的复杂。想要搞懂路由内部实现还是有些困难的，但是如果只想了解路由实现基本原理还是比较简单的。本文针对前端路由主流的实现方式 hash 和 history，提供了原生 JS/React/Vue 共计六个版本供参考，每个版本的实现代码约 25~40 行左右（含空行）。 什么是前端路由？路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。 在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。 如何实现前端路由？要实现前端路由，需要解决两个核心： ⭐ 如何改变 URL 却不引起页面刷新？ ⭐ 如何检测 URL 变化了？ 下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。 hash 实现hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过标签改变 URL、通过 window.location 改变 URL，这几种情况改变 URL 都会触发 hashchange 事件 history 实现history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新 history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过 pushState/replaceState 或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState 的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。 原生 JS 版前端路由实现基于 hash 实现 HTML 部分： 12345678910&lt;body&gt; &lt;ul&gt; &lt;!-- 定义路由 --&gt; &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt;&lt;/li&gt; &lt;!-- 渲染路由对应的 UI --&gt; &lt;div id=&quot;routeView&quot;&gt;&lt;/div&gt; &lt;/ul&gt;&lt;/body&gt; JavaScript 部分： 123456789101112131415161718192021222324252627// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件window.addEventListener(&quot;DOMContentLoaded&quot;, onLoad);// 监听路由变化window.addEventListener(&quot;hashchange&quot;, onHashChange);// 路由视图let routerView = null;function onLoad() &#123; routerView = document.querySelector(&quot;#routeView&quot;); onHashChange();&#125;// 路由变化时，根据路由渲染对应 UIfunction onHashChange() &#123; console.log(&quot;location.hash&quot;, location.hash); switch (location.hash) &#123; case &quot;#/home&quot;: routerView.innerHTML = &quot;Home&quot;; return; case &quot;#/about&quot;: routerView.innerHTML = &quot;About&quot;; return; default: return; &#125;&#125; 补充: DOMContentLoaded 顾名思义，就是 dom 内容加载完毕。那什么是 dom 内容加载完毕呢？我们从打开一个网页说起。当输入一个 URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发 DOMContentLoaded 事件。而这段时间就是 HTML 文档被加载和解析完成。参考DOMContentLoaded 与 load 的区别 基于 history 实现 html 部分: 12345678&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;about&lt;/a&gt;&lt;/li&gt; &lt;div id=&quot;routeView&quot;&gt;&lt;/div&gt; &lt;/ul&gt;&lt;/body&gt; js 部分: 12345678910111213141516171819202122232425262728293031323334353637383940// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件window.addEventListener(&quot;DOMContentLoaded&quot;, onLoad);// 监听路由变化window.addEventListener(&quot;popstate&quot;, onPopState);// 路由视图var routerView = null;function onLoad() &#123; routerView = document.querySelector(&quot;#routeView&quot;); onPopState(); // 🌟🌟🌟🌟🌟拦截 &lt;a/&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。 var linkList = document.querySelectorAll(&quot;a[href]&quot;); linkList.forEach(el =&gt; el.addEventListener(&quot;click&quot;, function(e) &#123; //阻止默认事件 e.preventDefault(); //history系统自带属性 history.pushState(&quot;这里是否可以添加state状态&quot;, &quot;&quot;, el.getAttribute(&quot;href&quot;)); //el.getAttribute(&#x27;href&#x27;) ---&gt; 点击时使用 pushState 修改 URL并更新手动 UI/home 或者 /about onPopState(); &#125;) );&#125;// 路由变化时，根据路由渲染对应 UIfunction onPopState() &#123; console.log(&quot;location.pathname&quot;, location.pathname); // location.pathname /home switch (location.pathname) &#123; case &quot;/home&quot;: routerView.innerHTML = &quot;Home&quot;; return; case &quot;/about&quot;: routerView.innerHTML = &quot;About&quot;; return; default: return; &#125;&#125; React 版前端路由实现基于 hash 实现html 部分: 12345678910111213&lt;BrowserRouter&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;about&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route path=&quot;/about&quot; render=&#123;() =&gt; &lt;h2&gt;About&lt;/h2&gt;&#125; /&gt; &lt;/BrowserRouter&gt; js 部分 1234567891011121314151617181920212223242526272829export default class BrowserRouter extends React.Component &#123; state = &#123; currentPath: utils.extractHashPath(window.location.href) &#125;; onHashChange = e =&gt; &#123; const currentPath = utils.extractHashPath(e.newURL); console.log(&quot;onHashChange:&quot;, currentPath); this.setState(&#123; currentPath &#125;); &#125;; componentDidMount() &#123; window.addEventListener(&quot;hashchange&quot;, this.onHashChange); &#125; componentWillUnmount() &#123; window.removeEventListener(&quot;hashchange&quot;, this.onHashChange); &#125; render() &#123; // window.location.href http://localhost:3000/#/home //onPopState undefined return ( &lt;RouteContext.Provider value=&#123;&#123; currentPath: this.state.currentPath &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/RouteContext.Provider&gt; ); &#125;&#125; Route 实现123export default (&#123; path, render &#125;) =&gt; ( &lt;RouteContext.Consumer&gt;&#123;(&#123; currentPath &#125;) =&gt; currentPath === path &amp;&amp; render()&#125;&lt;/RouteContext.Consumer&gt;); Link 实现1export default (&#123; to, ...props &#125;) =&gt; &lt;a &#123;...props&#125; href=&#123;&quot;#&quot; + to&#125; /&gt;; 基于 history 实现使用方式和 react-router 类似： 12345678910111213&lt;HistoryRouter&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;about&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route path=&quot;/about&quot; render=&#123;() =&gt; &lt;h2&gt;About&lt;/h2&gt;&#125; /&gt;&lt;/HistoryRouter&gt; HistoryRouter 实现123456789101112131415161718192021222324252627export default class HistoryRouter extends React.Component &#123; state = &#123; currentPath: utils.extractUrlPath(window.location.href) &#125;; onPopState = e =&gt; &#123; const currentPath = utils.extractUrlPath(window.location.href); console.log(&quot;onPopState:&quot;, currentPath); this.setState(&#123; currentPath &#125;); &#125;; componentDidMount() &#123; window.addEventListener(&quot;popstate&quot;, this.onPopState); &#125; componentWillUnmount() &#123; window.removeEventListener(&quot;popstate&quot;, this.onPopState); &#125; render() &#123; return ( &lt;RouteContext.Provider value=&#123;&#123; currentPath: this.state.currentPath, onPopState: this.onPopState &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/RouteContext.Provider&gt; ); &#125;&#125; Route 实现123export default (&#123; path, render &#125;) =&gt; ( &lt;RouteContext.Consumer&gt;&#123;(&#123; currentPath &#125;) =&gt; currentPath === path &amp;&amp; render()&#125;&lt;/RouteContext.Consumer&gt;); Link 实现 (区别在这里)1234567891011121314151617export default (&#123; to, ...props &#125;) =&gt; ( &lt;RouteContext.Consumer&gt; &#123;(&#123; onPopState &#125;) =&gt; ( &lt;a href=&quot;&quot; &#123;...props&#125; onClick=&#123;e =&gt; &#123; //阻止默认事件 e.preventDefault(); //改变浏览器的路径 window.history.pushState(null, &quot;&quot;, to); onPopState(); &#125;&#125; /&gt; )&#125; &lt;/RouteContext.Consumer&gt;); 小结前端路由的核心实现原理很简单，但是结合具体框架后，框架增加了很多特性，如动态路由、路由参数、路由动画等等，这些导致路由实现变的复杂。本文去粗取精只针对前端路由最核心部分的实现进行分析，并基于 hash 和 history 两种模式，分别提供原生 JS/React 三种实现，共计四个实现版本供参考，希望对你有所帮助。 参考[【第 1611 期】前端路由原理解析](","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"Redux源码探索-applyMiddleware","slug":"Redux源码探索-applyMiddleware","date":"2019-12-02T16:00:00.000Z","updated":"2020-09-16T09:07:51.000Z","comments":true,"path":"2019/12/03/Redux源码探索-applyMiddleware/","link":"","permalink":"http://mariogogogo.github.io/2019/12/03/Redux%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2-applyMiddleware/","excerpt":"顾名思义，applyMiddleware 就是中间件的意思。applyMiddleware 接收中间件为参数，并返回一个以createStore为参数的函数；","text":"顾名思义，applyMiddleware 就是中间件的意思。applyMiddleware 接收中间件为参数，并返回一个以createStore为参数的函数； 123456789101112131415161718192021222324252627/ applyMiddleware.jsexport default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( &#x27;Dispatching while constructing your middleware is not allowed. &#x27; + &#x27;Other middleware would not be applied to this dispatch.&#x27; ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // middlewareAPI 作为参数执行一遍所有的中间件 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 根据 compose 生产的其实是类似 mid1(mid2(mid3(store.dispatch))) // 所以在数组最后的 middleware 其实是第一个执行的 dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 这里要结合实际的中间件来理解，下面是 logger 中间件的示例代码: 可以看到中间件 logger 其实是一个函数，参数为 dispatch 和 getState，这个对应上面的 middlewareAPI. middleware(middlewareAPI) 执行后得到的还是个函数，参数是 next，看上面的 compose, 这个 next 其实就是 store.dispatch，返回的是新的 dispatch. 假如是 newDispatch,根据上面的 compose，你会发现，这个 newDispatch 是作为中间件链的下一个 middleware 的参数值（就是 next）这样一环扣一环，得到一个最终的 dispatch 在实际调用最终的 dispatch 时，你会发现，middleware 的执行顺序又变成是从左往右了（因为最终返回的 dispatch 是第一个中间件的函数） 执行过程中，遇到 next(action)，这时候其实就是右边一个 middleware 的返回的 dispatch，控制权就转到这个 middleware 了， 这样执行到最后，控制权返回，再执行 next 后面的代码 最终就是形成了中间件的洋葱模型，看下面的示意图 1234567// logger 中间件的示例代码const logger = (&#123; getState, dispatch &#125;) =&gt; next =&gt; action =&gt; &#123; console.log(&quot;dispatching&quot;, action); let result = next(action); console.log(&quot;next state&quot;, store.getState()); return result;&#125;; 1234567891011121314// 洋葱模型示意图+-------------------------------------------------------------+| mid21 || +---------------------------------------------+ || | mid2 +-----------------------------+ | || | | mid2 +-------------+ | | || | | | | | | |-&gt; next() -&gt; next() -&gt;next() -&gt; dispatch() -&gt; -&gt; -&gt; -&gt;| | | | | | | || | | +-------------+ | | || | +-----------------------------+ | || +---------------------------------------------+ |+-------------------------------------------------------------+ 比如这个 logger 中间件的执行顺序会是 打印 dispatching -&gt; 等待 next 执行返回 -&gt; 打印 next state 总结通过熟悉 redux 的源码，我们也对 redux 的代码结构本身有了一个完整的理解，我们可以理解 redux 的整个工作流程： 设计全局 state 的数据结构状态树 设计更改 state 数据、状态的 actionType 常量 根据 actionType，编写 actionCreator 根据各个 actionCreator 的返回值，用 reducer 做数据处理 有个 reducer 之后，我们用 createStore 来得到全局唯一的 store，来管理 state 用 bindActionCreator 函数将 actionCreator 和 store.dispatch 绑定起来，得到一组能更改 state 的函数 分发使用各个状态修改函数（dispatch）","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Redux","slug":"Redux","permalink":"http://mariogogogo.github.io/tags/Redux/"}]},{"title":"Redux源码探索-bindActionCreators","slug":"Redux源码探索-bindActionCreators","date":"2019-12-01T16:00:00.000Z","updated":"2020-09-16T09:07:51.000Z","comments":true,"path":"2019/12/02/Redux源码探索-bindActionCreators/","link":"","permalink":"http://mariogogogo.github.io/2019/12/02/Redux%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2-bindActionCreators/","excerpt":"bindActionCreators 的代码比较简单，就是将 actionCreator 和 dispatch 联结在一起。","text":"bindActionCreators 的代码比较简单，就是将 actionCreator 和 dispatch 联结在一起。 对于多个 actionCreator，我们可以像 reducers 一样，组织成一个 key/action 的组合。由于很多情况下，action 是 actionCreator 返回的，实际上要这样调用 store.dispatch(actionCreator(...args))，很麻烦是吧？只能再封装一层呗，这就是函数式思想的体现，通过反复组合，将嵌套函数分离。（在这里，我不得不再夸一次 redux 的作者） 123456789// bindActionCreators.js 部分代码// 这个方法的做用，其实就是一个简写的调用方法，方便使用// 结果就是返回一个函数: `dispatch(actionCreator(xxx))`function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)); &#125;;&#125; compose.jscompose 的代码不难理解，它调用了 ES5 的 Array.prototype.reduce 方法，将形如 fn(arg1)(arg2)(arg3)…的柯里化函数按照顺序执行。 1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Redux","slug":"Redux","permalink":"http://mariogogogo.github.io/tags/Redux/"}]},{"title":"Redux源码探索-combineReducers","slug":"Redux源码探索-combineReducers","date":"2019-12-01T16:00:00.000Z","updated":"2020-09-16T09:07:52.000Z","comments":true,"path":"2019/12/02/Redux源码探索-combineReducers/","link":"","permalink":"http://mariogogogo.github.io/2019/12/02/Redux%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2-combineReducers/","excerpt":"这个函数可以组合一组 reducers，然后返回一个新的 reducer。","text":"这个函数可以组合一组 reducers，然后返回一个新的 reducer。 由于 redux 只维护唯一的 state，随着整个项目越来越大，state 状态树也会越来越庞大，state 的层级也会越来越深，当某个 action.type 所对应的 case 只是要修改 state.a.b.c.d.e.f 这个属性时，我的 handleCase 函数写起来就非常难看，我必须在这个函数的头部验证 state 对象有没有那个属性。这是让开发者非常头疼的一件事。 1234567891011121314151617181920212223242526// 返回一个合并后的 reducer 函数, state 默认值为空对象return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError; &#125; //..... let hasChanged = false; const nextState = &#123;&#125;; // 循环执行 reducer，这部分写的很清晰 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i]; const reducer = finalReducers[key]; const previousStateForKey = state[key]; const nextStateForKey = reducer(previousStateForKey, action); // 这里验证是否会没有 state 返回 if (typeof nextStateForKey === &quot;undefined&quot;) &#123; const errorMessage = getUndefinedStateErrorMessage(key, action); throw new Error(errorMessage); &#125; nextState[key] = nextStateForKey; hasChanged = hasChanged || nextStateForKey !== previousStateForKey; &#125; // state 有改变返回下一个 state，否则返回原来的 state return hasChanged ? nextState : state;&#125;; combineReducers实现方法很简单，它遍历传入的 reducers，返回一个新的 reducer，这个新对象的 key 跟传入的 reducers 一样，它的 value 则是传入的 reducers 的不同 key 对应的 value 展开的{ key: value }。貌似讲的有点绕啊~，举个例子好讲明白： 123456789var reducers = &#123; todos: (state, action) &#123; // 此处的 state 参数是全局 state.todos属性 switch (action.type) &#123;...&#125; // 返回的 new state 更新到全局 state.todos 属性中 &#125;, activeFilter: (state, action) &#123; // 拿到 state.activeFilter 作为此处的 state switch (action.type) &#123;...&#125; // new state 更新到全局 state.activeFilter 属性中 &#125;&#125;var rootReducer = combineReducers(reducers) 不足combineReducers是有缺陷的，源码中 mapValues 只是一级深度的映射，目前 redux 并没有提供简便的映射到 state.a.b 一级以上深度的 state 的方法。这是它目前的不足之处。我们在不改源码的情况下，可以通过嵌套 combineReducers 来达到目的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var todosReducers = &#123; active: (state, action) =&gt; &#123; //拿到全局 state.todos.active switch (action.type) &#123; case A: //处理 A 场景 return handleA(state); case B: //处理 B 场景 return handleB(state); default: return state; &#125; &#125;, completed: (state, action) =&gt; &#123; //拿到全局 state.todos.completed switch (action.type) &#123; case C: //处理 C 场景 return handleC(state); default: return state; &#125; &#125;&#125;;var todosRootReducer = combineReducers(todosReducers);var reducers = &#123; todos: (state, action) =&gt; &#123; //拿到全局 state.todos switch (action.type) &#123; case A: case B: case C: // A B C 场景都传递给 todosRootReducer return todosRootReducer(state, action); case D: //...handle state default: return state; &#125; &#125;&#125;;//rootReducer(state, action) 这里的 state 是真正的全局 statevar rootReducer = combineReducers(reducers); 参考redux 源码分析与设计思路剖析 Redux 源码解读","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Redux","slug":"Redux","permalink":"http://mariogogogo.github.io/tags/Redux/"}]},{"title":"Redux源码探索-createStore","slug":"Redux源码探索-createStore","date":"2019-11-30T16:00:00.000Z","updated":"2020-09-16T09:07:52.000Z","comments":true,"path":"2019/12/01/Redux源码探索-createStore/","link":"","permalink":"http://mariogogogo.github.io/2019/12/01/Redux%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2-createStore/","excerpt":"redux 的源码非常的简洁，总共加起来就几百行，所以不难理解；建议先去熟悉 redux 的 API 和用法再来看本文，会更得心应手。","text":"redux 的源码非常的简洁，总共加起来就几百行，所以不难理解；建议先去熟悉 redux 的 API 和用法再来看本文，会更得心应手。 大家看目录结构，一共有 6 个问件。先说下各个文件大概功能。 12345678src├── utils #工具函数 包括控制台输出一个警告，我们可以不用看├── applyMiddleware.js #使用自定义的 middleware 来扩展 Redux├── bindActionCreators.js #把 action creators 转成拥有同名 keys 的对象,使用时可以直接调用├── combineReducers.js #一个比较大的应用，需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分├── compose.js #从右到左来组合多个函数，函数编程中常用到├── createStore.js #创建一个 Redux Store 来放所有的state└── index.js #入口 js createStore 是 redux 非常重要的一个 API，createStore 会生成一个 store，用来维护一个全局的 state。store 作为一个对象,提供了直接获取对象页面数据getState方法,触发更新了 store 的dispatch方法,以及订阅 store 状态变化的subscribe方法 123456const store = &#123; dispatch, getState, subscribe, replaceReducer&#125;; 思考如何实现 store?创建 store 从createStore函数入手,一般简单需要接受reducer函数作为参数. 1234import &#123; createStore &#125; from &quot;redux&quot;;import reduce from &quot;./reduce&quot;;const store = createStore(reduce);export default store; createStore 返回一个完整的 store 对象,我们需要实现一个 getState,dispatch 和 subscribe 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export default function createStore(reducer, preloadedState, enhancer) &#123; // 判断接受的参数个数，来指定 reducer 、 preloadedState 和 enhancer if (typeof preloadedState === &#x27;function&#x27; &amp;&amp; typeof enhancer === &#x27;undefined&#x27;) &#123; enhancer = preloadedState preloadedState = undefined &#125; // 如果 enhancer 存在并且适合合法的函数，那么调用 enhancer，并且终止当前函数执行 if (typeof enhancer !== &#x27;undefined&#x27;) &#123; if (typeof enhancer !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected the enhancer to be a function.&#x27;) &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected the reducer to be a function.&#x27;) &#125; // 储存当前的 currentReducer var currentReducer = reducer // 储存当前的状态 var currentState = preloadedState // 储存当前的监听函数列表 var currentListeners = [] // 储存下一个监听函数列表 var nextListeners = currentListeners var isDispatching = false // 这个函数可以根据当前监听函数的列表生成新的下一个监听函数列表引用 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; ... getState ... ... subscribe ... ... dispatch ... ... replaceReducer ... ... observable ... dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 这就是 createStore 的基本雏形,实际上就是设计模式中的发布订阅模式 以上只是本人简单的分析与源码中还是有一些出入. 源码中 createStore 接受 3 个参数：reducer, preloadedState, enhancer；第一个参数 reducer 和第三个参数 enhancer 我们接下来会具体介绍，第二个参数是preloadedState，它是 state 的初始值。 createStore 的返回值是 dispatch，subscribe，getState，replaceReducer，[$$observable]: observable，共同组成了一个 store，接下来我们也会讲到讲这些方法。 12345678//源码中最后returnreturn &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable&#125;; 1. actionaction 代表的是用户的操作。redux 规定 action 一定要包含一个 type 属性，且 type 属性也要唯一，相同的 type，redux 视为同一种操作，因为处理 action 的函数 reducer 只判断 action 中的 type 属性。 2. reducerreducer 接受两个参数，state 以及 action 函数返回的 action 对象，并返回最新的 state，如下 reducer 的 demo 123456789101112export default (state, action) =&gt; &#123; switch (action.type) &#123; case A: return handleA(state); case B: return handleB(state); case C: return handleC(state); default: return state; // 如果没有匹配上就直接返回原 state &#125;&#125;; reducer 只是一个模式匹配的东西，真正处理数据的函数，一般是额外在别的地方写的（当然直接写在 reducer 中也没问题，只是不利于后期维护），在 reducer 中调用罢了。 reducer 为什么叫 reducer 呢？因为 action 对象各种各样，每种对应某个 case ，但最后都汇总到 state 对象中，从多到一，这是一个减少( reduce )的过程，所以完成这个过程的函数叫 reducer。 3 getState123function getState() &#123; return currentState;&#125; 整个项目的currentState 是处于一个闭包之中，所以能一直存在，getState 会返回当前最新的 state。 4 subscribe123456789101112131415161718192021222324252627282930function subscribe(listener) &#123; //... // 标记订阅状态，取消订阅时避免重复取消订阅的逻辑执行，造成的性能损耗 let isSubscribed = true; // 添加 listener 之前，确保不改动 currentListeners，而是 currentListeners 的复制出来的 nextListeners ensureCanMutateNextListeners(); // 添加回调函数 listener 到 nextListeners nextListeners.push(listener); // 🌟🌟订阅的返回值是个函数，调用这个返回值来取消订阅（类似于 setTimeout 的返回值可以用来取消定时器） return function unsubscribe() &#123; if (!isSubscribed) &#123; return; &#125; // reducer 执行时不能取消订阅 if (isDispatching) &#123; throw new Error( &quot;You may not unsubscribe from a store listener while the reducer is executing. &quot; + &quot;See https://redux.js.org/api-reference/store#subscribe(listener) for more details.&quot; ); &#125; // 标记为未订阅 isSubscribed = false; // 这里会再次确认 nextListeners 和 currentListeners 时，浅复制一份新的 nextListeners 出来 ensureCanMutateNextListeners(); // 找到需要取消订阅的 listener，通过 splice 从数组中删除，变化体现在 nextListeners 数组中 const index = nextListeners.indexOf(listener); nextListeners.splice(index, 1); &#125;;&#125; subscribe 接收一个 listener，它的作用是给 store 添加监听函数。nextListeners 储存了整个监听函数列表。 subscribe 的返回值是一个 unsubscribe，是一个解绑函数，调用该解绑函数，会将已经添加的监听函数删除，该监听函数处于一个闭包之中，会一直存在，所以在解绑函数中能删除该监听函数。（由此可见 redux 源码设计的精巧，多处地方巧用闭包，精简了许多代码。） 这里注意到一个函数 ensureCanMutateNextListeners，是干嘛用的呢？ 123456// createStore.jsfunction ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice(); &#125;&#125; 考虑下面这种场景： dispatch 过程中，监听回调 listener 数组 [ a, b, c ,d ] 在循环执行，但是刚执行完 a，a 被取消监听了，这时候数组就会变成 [ b, c ,d ]，c 是数组的第二项了。原本要执行第二项的 b 就被跳过了，而去执行 c 去了。 这个函数的作用是为了保证在 dispatch 过程中，新增或者取消订阅不会影响到当前的 dispatch，避免类似这种场景下 bug 的产生。 浅复制一份 currentListeners，保证当前的 dispatch 的不变，新增或者取消的会在 nextListeners 中体现，也就是下次 dispatch 时。 (subscribe 的注释里也有说明) 5 dispatch123456789101112131415161718192021222324function dispatch(action) &#123; // ... try &#123; // 开始执行 reducer isDispatching = true; // reducer 的参数是当前的 state 和指定的 action，返回值作为新的 state, 所以要保证 reducer 一定要有 state 返回 currentState = currentReducer(currentState, action); &#125; finally &#123; // reducer 执行完成 isDispatching = false; &#125; /** * 这里获取最新的回调函数数组, 然后循环逐个执行. * 这里让 currentListeners = nextListeners, 如果这时候出现新增或者取消订阅, 之前的 ensureCanMutateNextListeners 就起作用了, * 改动不会影响当前执行的数组, 下次执行 dispatch 才会拿到改过后的数组 */ const listeners = (currentListeners = nextListeners); for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i]; listener(); &#125; return action;&#125; dispatch 接收一个参数 action。代码会先调用 createStore 传入的参数 reducer 方法，reducer 接受当前 state 和 action，通过判断 actionType，来做对应的操作，并返回最新的 currentState。dispatch 还会触发整个监听函数列表，所以最后整个监听函数列表都会按顺序执行一遍。dispatch返回值就是传入的action。 6 replaceReducer12345678function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== &quot;function&quot;) &#123; throw new Error(&quot;Expected the nextReducer to be a function.&quot;); &#125; currentReducer = nextReducer; dispatch(&#123; type: ActionTypes.INIT &#125;);&#125; replaceReducer是替换当前的 reducer 的函数，replaceReducer 接受一个新的reducer，替换完成之后，会执行 dispatch({ type: ActionTypes.INIT }) ，用来初始化 store 的状态。官方举出了三种 replaceReducer 的使用场景，分别是： 当你的程序要进行代码分割的时候 当你要动态的加载不同的 reducer 的时候 当你要实现一个实时 reloading 机制的时候 7 observable这个 API 并不是暴露给使用者的，这个是 redux 内部用的，大家不用深究（千万不要死脑筋啊~~~）。什么，你不信？好吧，实话告诉你，就是内部用的，在测试代码中会用到，感兴趣的可以去 test 目录下查看。 今天就先分析到这里…..拜里个拜~💤 参考redux 源码分析与设计思路剖析 Redux 源码解读","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Redux","slug":"Redux","permalink":"http://mariogogogo.github.io/tags/Redux/"}]},{"title":"React2019 年最劲爆的新特性 React-Hooks","slug":"React今年最劲爆的新特性React Hooks","date":"2019-11-27T16:00:00.000Z","updated":"2020-09-16T09:07:45.000Z","comments":true,"path":"2019/11/28/React今年最劲爆的新特性React Hooks/","link":"","permalink":"http://mariogogogo.github.io/2019/11/28/React%E4%BB%8A%E5%B9%B4%E6%9C%80%E5%8A%B2%E7%88%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7React%20Hooks/","excerpt":"React 在 v16.8 的版本中推出了 React Hooks 新特性，虽然社区还没有最佳实践如何基于 React Hooks 来打造复杂应用(至少我还没有)，凭借着阅读社区中大量的关于这方面的文章，下面我将通过十个案例来帮助你认识理解并可以熟练运用 React Hooks 大部分特性。","text":"React 在 v16.8 的版本中推出了 React Hooks 新特性，虽然社区还没有最佳实践如何基于 React Hooks 来打造复杂应用(至少我还没有)，凭借着阅读社区中大量的关于这方面的文章，下面我将通过十个案例来帮助你认识理解并可以熟练运用 React Hooks 大部分特性。 为什么 React 要搞一个 Hooks？ 想要复用一个有状态的组件太麻烦了！ react 都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。那之前，官方推荐怎么解决这个问题呢？ 答案是：渲染属性（Render Props）和高阶组件（Higher-Order Components）。我们可以举例这两种模式。 Render Props渲染属性指的是使用一个值为函数的 prop 来传递需要动态渲染的 nodes 或组件。如下面的代码可以看到我们的 DataProvider 组件包含了所有跟状态相关的代码，而 Cat 组件则可以是一个单纯的展示型组件，这样一来 DataProvider 就可以单独复用了。 123456789101112131415161718192021222324import Cat from &#x27;components/cat&#x27;class DataProvider extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; target: &#x27;Zac&#x27; &#125;; &#125; render() &#123; return ( &lt;div&gt; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ) &#125;&#125;&lt;DataProvider render=&#123;data =&gt; ( &lt;Cat target=&#123;data.target&#125; /&gt;)&#125;/&gt;============改写下=======&lt;DataProvider&gt; &#123;data =&gt; ( &lt;Cat target=&#123;data.target&#125; /&gt; )&#125;&lt;/DataProvider&gt; Higher-Order Components高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser 函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。 1234567891011const withUser = WrappedComponent =&gt; &#123; const user = sessionStorage.getItem(&quot;user&quot;); return props =&gt; &lt;WrappedComponent user=&#123;user&#125; &#123;...props&#125; /&gt;;&#125;;const UserPage = props =&gt; ( //复用每一个组件都需要获取user参数 &lt;div class=&quot;user-container&quot;&gt; &lt;p&gt;My name is &#123;props.user&#125;!&lt;/p&gt; &lt;/div&gt;);export default withUser(UserPage); 很多库也运用了这种模式，比如我们常用的 React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开 devtool 看看你的组件层级嵌套是不是很夸张吧 生命周期钩子函数的逻辑太混乱比如我们需要在 componentDidMount 中发起 ajax 请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在 componentDidUpdate 做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。 12345678910111213componentDidMount() &#123;//注册 this.timer = setInterval(()=&gt;&#123; this.setState(&#123; count: this.state.count+1 &#125;) &#125;,1000) &#125; componentWillMount() &#123; //销毁 clearInterval(this.timer) &#125; class 中的 this 绑定用 class 来创建 react 组件时，还有一件很麻烦的事情，就是 this 的指向问题 1&lt;button onClick=&#123;() =&gt; this.handleClick(e)&#125;&gt; 需求变更项目中需求变更是非常常见的问题,之前组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用 function 写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的 state，我们又得很麻烦的把 function 改成 class。 在这样的背景下，Hooks 便横空出世了！ 先从简单的 Hooks 说起–useState我们看一下原来简单的有状态组件 123456789101112131415161718class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; //根据state的改变重新渲染 &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 使用 hooks 之后 123456789101112131415import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0);&#125;========或者==========//初始化状态const [state, setState] = useState(()=&gt;&#123; //默认只执行一次console.log(&#x27;只执行初始化一次&#x27;); const initialState = someExpensiveComputation(props) return initialState&#125;)//使用setState((preState)=&gt;&#123; return &#123;...prevState, ...updatedValues&#125;;&#125;) 特点: setState 组件重新渲染时不会变化，useState 返回的第一个值始终是最新的 state state 如果是对象，当只更新对象部分属性时，state 更新不会合并对象 如果 state 不发生变化，调用 setState 将跳过更新 建议：将同一时间段更新的 state， 组合初始化在一起 还有一个问题 123456function add(n) &#123; const result = 0; return result + 1;&#125;add(1); //1add(1); //1 普通函数是记忆不住result的变量的. 为什么 useState 可以记住之前的状态？useState 接收的初始值没有规定一定要是 string/number/boolean 这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的 this.setState 做的是合并状态后返回一个新状态，而 useState 是直接替换老状态后返回新状态。 1234function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&#x27;banana&#x27;); const [todos, setTodos] = useState([&#123; text: &#x27;Learn Hooks&#x27; &#125;]); useState 无论调用多少次，相互之间是独立的。不同组件调用同一个 hook 也能保证各自状态的独立性。react 是怎么保证多个 useState 的相互独立的？ 123456789//第一次渲染useState(42); //将age初始化为42useState(&quot;banana&quot;); //将fruit初始化为bananauseState([&#123; text: &quot;Learn Hooks&quot; &#125;]); //...//第二次渲染useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略）useState(&quot;banana&quot;); //读取状态变量fruit的值（这时候传的参数banana直接被忽略）useState([&#123; text: &quot;Learn Hooks&quot; &#125;]); //... 假如我们改一下代码： 1234567891011let showFruit = true;function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); if (showFruit) &#123; const [fruit, setFruit] = useState(&quot;banana&quot;); showFruit = false; &#125; const [todos, setTodos] = useState([&#123; text: &quot;Learn Hooks&quot; &#125;]);&#125; react 是根据 useState 出现的顺序来定的 123456789//第一次渲染useState(42); //将age初始化为42useState(&quot;banana&quot;); //将fruit初始化为bananauseState([&#123; text: &quot;Learn Hooks&quot; &#125;]); //...//第二次渲染useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略）// useState(&#x27;banana&#x27;);useState([&#123; text: &quot;Learn Hooks&quot; &#125;]); //读取到的却是状态变量fruit的值，导致报错 什么是 Effect Hooks?useEffect 组件渲染之后异步执行回调，并在下次渲染前执行useLayoutEffect 组件渲染之后同步执行回调比如: 123useEffect(callback); //组件每次渲染，都会重新生成 useEffectuseEffect(callback, [依赖参数]); //组件每次渲染之后，根据依赖参数判断是否重新生成 useEffectuseEffect(callback, []); // 只在组件挂载时运行一 我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起 ajax 请求获取数据，添加一些监听的注册和取消注册，手动修改 dom 等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如 componentDidMount，componentDidUpdate 和 componentWillUnmount。而现在的 useEffect 就相当与这些声明周期函数钩子的集合体。它以一抵三。 1234567891011121314151617import &#123; useState, useEffect &#125; from &quot;react&quot;;function Example() &#123; const [count, setCount] = useState(0); // 类似于componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 更新文档的标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125; useEffect Hook 对应的生命周期： componentDidMount componentDidUpdate componentWillUnmount 再梳理一遍下面代码的逻辑： 我们声明了一个状态变量 count，将它的初始值设为 0。 然后我们告诉 react，我们的这个组件有一个副作用。我们给 useEffecthook 传了一个匿名函数，这个匿名函数就是我们的副作用。 在这个例子里，我们的副作用是调用 browser API 来修改文档标题。 当 react 要渲染我们的组件时，它会先记住我们用到的副作用。等 react 更新了 DOM 之后，它再依次执行我们定义的副作用函数。 这里要注意几点： 第一，react 首次渲染和之后的每次渲染都会调用一遍传给 useEffect 的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）第二，useEffect 中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的 componentDidMount 或 componentDidUpdate 中的代码则是同步执行的。这种安排对大多数副作用说都是合理的 useEffect 怎么解绑一些副作用这种场景很常见，当我们在 componentDidMount 里添加了一个注册，我们得马上在 componentWillUnmount 中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。 怎么清除呢？让我们传给 useEffect 的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些 pubsub 模式的实现中很常见。看下面的例子： 123456789101112131415161718192021import &#123; useState, useEffect &#125; from &quot;react&quot;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &quot;Loading...&quot;; &#125; return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;&#125; 再举个小李子 12345678//清理事件绑定useEffect(() =&gt; &#123; document.querySelector(&quot;#size&quot;).addEventListener(&quot;click&quot;, changeName, false); //清理事件绑定 return () =&gt; &#123; document.querySelector(&quot;#size&quot;).removeEventListener(&quot;click&quot;, changeName, false); &#125;;&#125;); 这种解绑的模式与 componentWillUnmount 区别?componentWillUnmount 只会在组件被销毁前执行一次而已，而 useEffect 里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。 为什么要让副作用函数每次组件更新都执行一遍？我们在 componentDidMount 注册，再在 componentWillUnmount 清除注册。但假如这时候 props.friend.id 变了怎么办？我们不得不再添加一个 componentDidUpdate 来处理这种情况：原来的做法: 1234567891011121314151617181920212223242526componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; //增加一步动态改变id componentDidUpdate(prevProps) &#123; // 先把上一个friend.id解绑 ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 再重新注册新但friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; 看到了吗？很繁琐，而我们但 useEffect 则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的： 1.页面首次渲染 2.替 friend.id=1 的朋友注册 3.突然 friend.id 变成了 2 4.页面重新渲染 5.清除 friend.id=1 的绑定 6.替 friend.id=2 的朋友注册… 怎么跳过一些不必要的副作用函数我们只需要给 useEffect 传第二个参数即可。用第二个参数来告诉 react 只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数） 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句 当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是 componentDidMount 加 componentWillUnmount 的模式。不过这种用法可能带来 bug，少用。 怎么写自定义的 Effect Hooks?为什么要自己去写一个 Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。 比如我们可以把上面写的 FriendStatus 组件中判断朋友是否在线的功能抽出来，新建一个 useFriendStatus 的 hook 专门用来判断某个 id 是否在线。 12345678910111213141516171819202122232425import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125;============这时候FriendStatus组件就可以简写为：function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; 假如别的组件需要一个朋友列表也需要显示是否在线的信息： 123456function FriendListItem(props) &#123; //引入方法 const isOnline = useFriendStatus(props.friend.id); return &lt;li style=&#123;&#123; color: isOnline ? &quot;green&quot; : &quot;black&quot; &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;/li&gt;;&#125; 什么是 useContext用来处理多层级传递数据的方式，在以前组件树种，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事 123456789101112131415161718192021import React, &#123; useState &#125; from &quot;react&quot;;const &#123; Provider, Consumer &#125; = React.createContext(null);function Bar() &#123; return &lt;Consumer&gt;&#123;color =&gt; &lt;div&gt;&#123;color&#125;&lt;/div&gt;&#125;&lt;/Consumer&gt;;&#125;function Foo() &#123; return &lt;Bar /&gt;;&#125;function App() &#123; return ( &lt;Provider value=&#123;&quot;grey&quot;&#125;&gt; &lt;Foo /&gt; &lt;/Provider&gt; );&#125;export default App; React Hooks 中，我们可以使用 useContext 进行改造 1234567891011121314151617181920212223import React, &#123; useState, useContext &#125; from &quot;react&quot;;function Bar() &#123; //接受这个变量 const color = useContext(colorContext); return &lt;div&gt;&#123;color&#125;&lt;/div&gt;;&#125;function Foo() &#123; return &lt;Bar /&gt;;&#125;//首先声明一个变量const colorContext = React.createContext(&quot;gray&quot;);function App() &#123; return ( &lt;colorContext.Provider value=&#123;&quot;red&quot;&#125;&gt; &lt;Foo /&gt; &lt;/colorContext.Provider&gt; );&#125;export default App; 传递给 useContext 的是 context 而不是 consumer，返回值即是想要透传的数据了。用法很简单，使用 useContext 可以解决 Consumer 多状态嵌套的问题。 原本嵌套的方法层级太多 1234567891011121314function HeaderBar() &#123; return ( &lt;CurrentUser.Consumer&gt; &#123;user =&gt; &lt;Notifications.Consumer&gt; &#123;notifications =&gt; &lt;header&gt; Welcome back, &#123;user.name&#125;! You have &#123;notifications.length&#125; notifications. &lt;/header&gt; &#125; &#125; &lt;/CurrentUser.Consumer&gt; );&#125; 现在用 useContext 12345678910function HeaderBar() &#123; //想要传过来的值直接用useContext读取即可,可读性大大增加 const user = useContext(CurrentUser); const notifications = useContext(Notifications); return ( &lt;header&gt; Welcome back, &#123;user.name&#125;! You have &#123;notifications.length&#125; notifications. &lt;/header&gt; );&#125; 什么是 useReducer这个 Hooks 在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件。 12345678910111213141516171819202122232425262728293031import React, &#123; useReducer &#125; from &quot;react&quot;;//初始化一个值const initData = &#123; count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &quot;add&quot;: return &#123; count: state.count + action.payload &#125;; break; case &quot;remove&quot;: return &#123; count: state.count - action.payload &#125;; break; default: throw new Error(&quot;错误&quot;); &#125;&#125;function App() &#123; //初始化 const [state, dispatch] = useReducer(reducer, initData); return ( &lt;&gt; &lt;h1&gt;Count:&#123;state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;add&quot;, payload: 5 &#125;)&#125;&gt;增加&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;remove&quot;, payload: 1 &#125;)&#125;&gt;减少&lt;/button&gt; &lt;/&gt; );&#125;export default App; 用法跟 Redux 基本上是一致的，用法也很简单，算是提供一个 mini 的 Redux 版本。 什么是 useCallback四个字:记忆函数在类组件中，我们经常犯下面这样的错误： 1234567891011121314class App &#123; render() &#123; return ( &lt;div&gt; &lt;SomeComponent style=&#123;&#123; fontSize: 14 &#125;&#125; doSomething=&#123;() =&gt; &#123; console.log(&quot;do something&quot;); &#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 这样写有什么坏处呢？一旦 App 组件的 props 或者状态改变了就会触发重渲染，即使跟 SomeComponent 组件不相关，由于每次 render 都会产生新的 style 和 doSomething，所以会导致 SomeComponent 重新渲染，倘若 SomeComponent 是一个大型的组件树，这样的 Virtual Dom 的比较显然是很浪费的，解决的办法也很简单，将参数抽离成变量。 1234567891011121314const fontSizeStyle = &#123; fontSize: 14 &#125;;class App &#123; doSomething = () =&gt; &#123; console.log(&quot;do something&quot;); &#125;; render() &#123; return ( &lt;div&gt; &lt;SomeComponent style=&#123;fontSizeStyle&#125; doSomething=&#123;this.doSomething&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在类组件中，我们还可以通过 this 这个对象来存储函数，而在函数组件中没办法进行挂载了。所以函数组件在每次渲染的时候如果有传递函数的话都会重渲染子组件。 而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。 1234567891011121314function App() &#123; const [count, setCount] = useState(0); const memoizedHandleClick = useCallback(() =&gt; &#123; console.log(&quot;Click happened&quot;); setCount(count + 1); &#125;, []); // 空数组代表无论什么情况下该函数都不会发生改变 return ( &lt;div&gt; Count:&#123;count&#125; &lt;SomeComponent doSomething=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/SomeComponent&gt; &lt;/div&gt; );&#125; 老规矩，第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。 这样只要子组件继承了 PureComponent 或者使用 React.memo 就可以有效避免不必要的 VDOM 渲染。还有一些注意的事情如果此时子组件再传入其他的参数 123456789101112131415function App() &#123; const [count, setCount] = useState(0); const memoizedHandleClick = useCallback(() =&gt; &#123; console.log(&quot;Click happened&quot;); setCount(count + 1); &#125;, []); // 空数组代表无论什么情况下该函数都不会发生改变 return ( &lt;div&gt; Count:&#123;count&#125; &lt;SomeComponent doSomething=&#123;memoizedHandleClick&#125; count=&#123;count&#125;&gt; Click Me &lt;/SomeComponent&gt; &lt;/div&gt; );&#125; 只执行一次因为数组为空代表只执行一次 什么是 useMemouseCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 12345678910const [count, setCount] = useState(0);const memoizedHandleClick = useMemo( () =&gt; () =&gt; &#123; console.log(&quot;Click happened&quot;); if (count &lt; 3) &#123; setCount(count + 1); &#125; &#125;, [count]); // 空数组代表无论什么情况下该函数都不会发生改变 唯一的区别是： useCallback 不会执行第一个参数函数，而是将它返回给你， useMemo 会执行第一个函数并且将函数执行结果返回给你。所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。 123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; );&#125; 当 a/b 改变时，child1/child2 才会重新渲染。从例子可以看出来，只有在第二个参数数组的值发生变化时，才会触发子组件的更新。 什么是 useRefuseRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用 1234567891011121314151617181920212223import React, &#123; useState, useRef &#125; from &quot;react&quot;;function App() &#123; let [name, setName] = useState(&quot;Nate&quot;); let nameRef = useRef(); const submitButton = () =&gt; &#123; setName(nameRef.current.value); nameRef.current.value = &quot;&quot;; &#125;; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;div&gt; &lt;input ref=&#123;nameRef&#125; type=&quot;text&quot; /&gt; &lt;button type=&quot;button&quot; onClick=&#123;submitButton&#125;&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default App; useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值访问组件或真实的 DOM 节点，从而可以对 DOM 进行一些操作，比如监听事件等等。 当然 useRef 远比你想象中的功能更加强大，useRef 的功能有点像类属性，或者说您想要在组件中记录一些值，并且这些值在稍后可以更改。 利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。参考例子：精读《Function VS Class 组件》 什么是 React Hooks 中存在 Capture Value 的特性12345678910111213141516171819202122function MessageThread() &#123; const [message, setMessage] = useState(&quot;&quot;); const showMessage = () =&gt; &#123; alert(&quot;You said: &quot; + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125; 在点击 Send 按钮后,再次修改输入框的值，3 秒后的输出依然是点击前输入框的值。这就是所谓的 capture value 的特性。而在类组件中 3 秒后输出的就是修改后的值，因为这时候 message 是挂载在 this 变量上，它保留的是一个引用值，对 this 属性的访问都会获取到最新的值。讲到这里你应该就明白了，useRef 创建一个引用，就可以有效规避 React Hooks 中 Capture Value 特性,ref拿到的是最新的值. 12345678910111213141516171819202122function MessageThread() &#123; const latestMessage = useRef(&quot;&quot;); const showMessage = () =&gt; &#123; alert(&quot;You said: &quot; + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; latestMessage.current = e.target.value; &#125;; return ( &lt;&gt; &lt;input value=&#123;latestMessage.current.value&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125; 只要将赋值与取值的对象变成 useRef，而不是 useState，就可以躲过 capture value 特性，在 3 秒后得到最新的值。 什么是 useImperativeMethods通过 useImperativeHandle 用于让父组件获取子组件内的索 什么是 useMutationEffect什么是 useLayoutEffectuseLayoutEffect 同步执行副作用大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。 1234567891011121314151617181920212223242526import React, &#123; useState, useEffect, useLayoutEffect &#125; from &quot;react&quot;;function App() &#123; const [width, setWidth] = useState(0); useEffect(() =&gt; &#123; console.log(&quot;useEffect&quot;); &#125;); useLayoutEffect(() =&gt; &#123; const title = document.querySelector(&quot;#title&quot;); const titleWidth = title.getBoundingClientRect().width; console.log(&quot;useLayoutEffect&quot;, width, titleWidth, title.getBoundingClientRect()); if (width !== titleWidth) &#123; setTimeout(() =&gt; &#123; setWidth(titleWidth); &#125;, 2000); &#125; &#125;); return ( &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt; );&#125;export default App; 加入定时器后再看看执行顺序 React Hooks 不足尽管我们通过上面的例子看到 React Hooks 的强大之处，似乎类组件完全都可以使用 React Hooks 重写。但是当下 v16.8 的版本中，还无法实现 getSnapshotBeforeUpdate 和 componentDidCatch 这两个在类组件中的生命周期函数。官方也计划在不久的将来在 React Hooks 进行实现,期待吧!😄💪🏻","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"Redux 异步方案选型","slug":"Redux异步方案选型","date":"2019-10-26T16:00:00.000Z","updated":"2020-09-16T09:07:51.000Z","comments":true,"path":"2019/10/27/Redux异步方案选型/","link":"","permalink":"http://mariogogogo.github.io/2019/10/27/Redux%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/","excerpt":"本文会从一些常见的 Redux 异步方案出发，介绍它们的优缺点，进而讨论一些与异步相伴的常见场景，帮助你在选型时更好地权衡利弊。","text":"本文会从一些常见的 Redux 异步方案出发，介绍它们的优缺点，进而讨论一些与异步相伴的常见场景，帮助你在选型时更好地权衡利弊。 由于 Redux 的理念非常精简，没有追求大而全，这份架构上的优雅却在某种程度上伤害了使用体验：不能开箱即用，甚至是异步这种最常见的场景也要借助社区方案。 redux-thunk：指路先驱 Redux 本身只能处理同步的 Action，但可以通过中间件来拦截处理其它类型的 action，比如函数(Thunk)，再用回调触发普通 Action，从而实现异步处理，在这点上所有 Redux 的异步方案都是类似的。 缺点:就是重复的模板代码太多： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123;Component&#125; from &#x27;react&#x27;;import &#123;connect&#125; from &#x27;react-redux&#x27;import &#123;Button, Progress,Loading&#125; from &#x27;element-react&#x27;;import &#x27;./App.css&#x27;import &#123; onGetData, onGetDataSuccess, onGetDataFAILED,&#125; from &#x27;./actions&#x27;class App extends Component &#123; render() &#123; const &#123; value, onAdd, data, loaddingVisible, &#125; = this.props return ( &lt;div className=&quot;counter_wrap&quot;&gt; ... &lt;Button type=&quot;primary&quot; onClick=&#123;onAsyncGetData&#125;&gt;异步加载&lt;/Button&gt; &lt;Loading text=&quot;拼命加载中&quot; loading=&#123;!!loaddingVisible&#125;&gt; &#123; data.length === 0 ? &lt;h1&gt;加载之后可见&lt;/h1&gt; : &lt;div&gt;&#123;data[0].name&#125;&lt;/div&gt; &#125; &lt;/Loading&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; &#123; const &#123;value,loaddingVisible,data&#125; = state; return &#123; value:value, data:data, loaddingVisible:loaddingVisible &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; ... onAsyncGetData:()=&gt;&#123; dispatch(onGetData()) fetch(&#x27;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test&#x27;, &#123; method: &#x27;POST&#x27;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;) &#125;).then(res =&gt; res.json()) .then(data=&gt;&#123; console.log(data) const &#123;success,results&#125; = data; setTimeout(()=&gt;&#123; dispatch(onGetDataSuccess(results)) &#125;,2000) &#125;) .catch(error=&gt;&#123; console.log(error) dispatch(onGetDataFAILED()) &#125;) &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App) 这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍。 另一方面，像GET_DATA_SUCCESS、GET_DATA_FAILED这样的字符串声明也非常无趣且易错。如果一个异步需要那么多状态,那么 5,6 个异步都需要那么多状态.太繁琐了 redux-actions：简化 redux 的使用Redux 虽然好用，但是里面还是有些重复代码，所以有了 redux-actions 来简化那些重复代码。 这部分简化工作主要集中在构造 action 和处理 reducers 方面。 先来看看原先的 actions 123456789101112131415161718192021222324252627import axios from &quot;axios&quot;;import * as T from &quot;./actionTypes&quot;;export const changeBtnText = text =&gt; &#123; return &#123; type: T.CHANGE_BTN_TEXT, payload: text &#125;;&#125;;export const changeBtnTextAsync = () =&gt; &#123; return (dispatch, getState) =&gt; &#123; if (!getState().isLoading) &#123; dispatch(changeBtnText(&quot;正在加载中&quot;)); &#125; axios .get(&quot;http://test.com&quot;) .then(() =&gt; &#123; if (getState().isLoading) &#123; dispatch(changeBtnText(&quot;加载完毕&quot;)); &#125; &#125;) .catch(() =&gt; &#123; dispatch(changeBtnText(&quot;加载有误&quot;)); &#125;); &#125;;&#125;; 然后再来看看修改后的：这里注意到，异步的 action 就不要用 createAction，因为这个 createAction 返回的是一个对象，而不是一个函数，就会导致 redux-thunk 的代码没有起到作用。 这里也可以使用 createActions 这个函数同时创建多个 action，但是讲道理，这个语法很奇怪，用 createAction 就好。 同样 redux-actions 对 reducer 的部分也进行了处理，比如 handleAction 以及 handelActions。 123456789101112131415161718192021222324import axios from &quot;axios&quot;;import * as T from &quot;./actionTypes&quot;;import &#123; createAction &#125; from &quot;redux-actions&quot;;//普通action传值export const changeBtnText = createAction(T.CHANGE_BTN_TEXT, text =&gt; text);export const changeBtnTextAsync = () =&gt; &#123; return (dispatch, getState) =&gt; &#123; if (!getState().isLoading) &#123; dispatch(changeBtnText(&quot;正在加载中&quot;)); &#125; axios .get(&quot;http://test.com&quot;) .then(() =&gt; &#123; if (getState().isLoading) &#123; dispatch(changeBtnText(&quot;加载完毕&quot;)); &#125; &#125;) .catch(() =&gt; &#123; dispatch(changeBtnText(&quot;加载有误&quot;)); &#125;); &#125;;&#125;; 看的出来actions的代码量也没有发生变化,再看看reducers 12345678910111213141516171819202122232425import &#123; handleActions &#125; from &quot;redux-actions&quot;;import * as T from &quot;./actionTypes&quot;;const initialState = &#123; btnText: &quot;我是按钮&quot;&#125;;const pageMainReducer = handleActions( &#123; [T.CHANGE_BTN_TEXT]: &#123; next(state, action) &#123; return &#123; ...state, btnText: action.payload &#125;; &#125;, throw(state) &#123; return state; &#125; &#125; &#125;, initialState);export default pageMainReducer; redux-promise：redux-actions 的好基友，轻松创建和处理异步 action由于 redux-thunk 写起来实在是太麻烦了，社区当然会有其它轮子出现。redux-promise则是其中比较知名的，同样也享受了官网出镜的待遇。 它自定义了一个 middleware，当检测到有 action 的 payload 属性是 Promise 对象时，就会： 若 resolve，触发一个此 action 的拷贝，但 payload 为 promise 的 value，并设 status 属性为”success” 若 reject，触发一个此 action 的拷贝，但 payload 为 promise 的 reason，并设 status 属性为”error” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, &#123;Component&#125; from &#x27;react&#x27;;import &#123;connect&#125; from &#x27;react-redux&#x27;import &#123;Button, Progress,Loading&#125; from &#x27;element-react&#x27;;import &#123;createAction&#125; from &#x27;redux-actions&#x27;import &#x27;./App.css&#x27;import &#123; onAddToPromise,&#125; from &#x27;./actions&#x27;class App extends Component &#123; render() &#123; const &#123; value, onAdd, data, error, loaddingVisible, onRemove, onAddIfOdd, onAsyncAddOne, onAsyncGetData, onPromise, &#125; = this.props return ( &lt;div className=&quot;counter_wrap&quot;&gt; ... &lt;Button type=&quot;primary&quot; onClick=&#123;onPromise&#125;&gt;Promise异步加载&lt;/Button&gt; &#123; error.length &gt; 0 &amp;&amp; &lt;h1&gt;&#123;error&#125;&lt;/h1&gt; &#125; &lt;h1&gt;&#123;data&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; &#123; const &#123;value,loaddingVisible,data,error&#125; = state; return &#123; value:value, data:data, error:error, loaddingVisible:loaddingVisible &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; ... onPromise:()=&gt;&#123; dispatch(onGetData()) //createAction函数的第一个就是type值，后面接受一个函数。 const promise = createAction(&#x27;ADD_PROMISE&#x27;,()=&gt;&#123; return new Promise((resolve, reject) =&gt;&#123; fetch(&#x27;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test&#x27;, &#123; method: &#x27;POST&#x27;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;) &#125;).then(res =&gt; res.json()) .then(data =&gt; &#123; resolve(data) &#125;).catch(error=&gt;&#123; reject(error) &#125;) &#125;) &#125;) console.log(&#x27;promise&#x27;,promise()) dispatch(promise()) &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App) 我们再看来来 reducer 得写法handleActions的第一个参数是一个对象，对象中的 key 就是 action 的 type 的值，第二个参数就是初始值的设置。 1234567891011121314151617181920212223242526272829303132//reducers.jsimport &#123; handleActions &#125; from &quot;redux-actions&quot;;const initData = &#123; value: 0, data: [], loaddingVisible: false, error: &quot;&quot;&#125;;export default handleActions( &#123; ADD_PROMISE: &#123; //请求成功处理 next(state, action) &#123; const &#123; results, success &#125; = action.payload; return &#123; ...state, data: results[0].name &#125;; &#125;, //错误处理 throw(state, action) &#123; return &#123; ...state, error: action.payload.toString() &#125;; &#125; &#125; &#125;, initData); 错误得情况下如何返回呢? redux 多个接口同时调用并发求值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export const onPromiseAction = createAction(&quot;ADD_PROMISE&quot;, () =&gt; &#123; return Promise.all([asyncGetMockTest(), asyncGetMockTest2()]) .then(data =&gt; &#123; console.log(&quot;data&quot;, data); return Promise.resolve(data); &#125;) .catch(error =&gt; &#123; return Promise.reject(error); &#125;);&#125;);const asyncGetMockTest = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(&quot;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test&quot;, &#123; method: &quot;POST&quot;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;) &#125;) .then(res =&gt; res.json()) .then(data =&gt; &#123; resolve(data); &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;);&#125;;const asyncGetMockTest2 = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(&quot;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test2&quot;, &#123; method: &quot;POST&quot;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;) &#125;) .then(res =&gt; res.json()) .then(data =&gt; &#123; resolve(data); &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;);&#125;; 再看看 reducers 中 12345678910111213141516 ADD_PROMISE: &#123; next(state, action) &#123; console.log(&#x27;action&#x27;,action) // action接受到数组对数组展开求值 return &#123; ...state, &#125;; &#125;, throw(state, action) &#123; return &#123; ...state, &#125; &#125;, &#125;,&#125;, initData); 请求之间有依赖关系如何处理根据请求 3 之后再调用请求 4 12345678910111213141516171819202122232425262728293031323334353637383940414243export const onPromiseAction = createAction(&quot;ADD_PROMISE&quot;, async () =&gt; &#123; const test3 = await asyncGetMockTest3(); console.log(&quot;test3&quot;, test3); if (test3.success) &#123; const test4 = await asyncGetMockTest4(); return Promise.resolve(test4); &#125; return Promise.resolve(&quot;失败&quot;);&#125;);//test3const asyncGetMockTest3 = async () =&gt; &#123; return await fetch(&quot;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test2&quot;, &#123; method: &quot;POST&quot;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;) &#125;) .then(res =&gt; res.json()) .then(data =&gt; &#123; return data; &#125;) .catch(error =&gt; &#123; return error; &#125;);&#125;;//test4const asyncGetMockTest4 = async () =&gt; &#123; return await fetch(&quot;http://mock.52react.cn/mock/5d886fc46cacdb72c1cb5ff2/v2.2/test&quot;, &#123; method: &quot;POST&quot;, // or &#x27;PUT&#x27; body: JSON.stringify(&#123;&#125;), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;) &#125;) .then(res =&gt; res.json()) .then(data =&gt; &#123; return data; &#125;) .catch(error =&gt; &#123; return error; &#125;);&#125;; 总结总的来说： redux 是一个可预测的状态容器， react-redux 是将 store 和 react 结合起来，使得数据展示和修改对于 react 项目而言更简单 redux 中间件就是在 dispatch action 前对 action 做一些处理 redux-thunk 用于对异步做操作 redux-actions 用于简化 redux 操作 redux-promise 可以配合 redux-actions 用来处理 Promise 对象，使得异步操作更简单 redux-saga 可以起到一个控制器的作用，集中处理边际效用，并使得异步操作的写法更优雅。 OK，虽然说不想写那么多，结果还是写了一大堆。","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"『TypeScript 系列』类型推断","slug":"TypeScript 系列类型推断","date":"2019-10-04T16:00:00.000Z","updated":"2020-09-16T09:07:53.000Z","comments":true,"path":"2019/10/05/TypeScript 系列类型推断/","link":"","permalink":"http://mariogogogo.github.io/2019/10/05/TypeScript%20%E7%B3%BB%E5%88%97%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/","excerpt":"类型是在哪里如何被推断的?","text":"类型是在哪里如何被推断的? TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型 基础1let x = 3; 变量x的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 通用类型1let x = [0, 1, null]; 为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number和null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 1let zoo = [new Rhino(), new Elephant(), new Snake()]; 这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型： 1let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; 上下文类型这个例子会得到一个类型错误，TypeScript 类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型。 因此，就能推断出event参数的类型了。 如果函数表达式不是在上下文类型的位置，event参数的类型需要指定为any，这样也不会报错了。 123window.onmousedown = function(event) &#123; console.log(event.clickTime); //&lt;- Error&#125;; 修改 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.button); //&lt;- Now, no error is given&#125;; 上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如： 123456789101112class Animal &#123; public numLen: number;&#125;class Bee extends Animal &#123;&#125;class Lion extends Animal &#123;&#125;function createZoo(): Animal[] &#123; return [new Bee(), new Lion()];&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』枚举","slug":"TypeScript系列枚举","date":"2019-09-23T16:00:00.000Z","updated":"2020-09-16T09:07:54.000Z","comments":true,"path":"2019/09/24/TypeScript系列枚举/","link":"","permalink":"http://mariogogogo.github.io/2019/09/24/TypeScript%E7%B3%BB%E5%88%97%E6%9E%9A%E4%B8%BE/","excerpt":"什么是枚举如 TypeScript 官方文档所说，枚举类型是对 JavaScript 标准数据类型集的扩充。对于熟悉 C# 的开发者来说，枚举类型并不陌生，它能够给一系列数值集合提供友好的名称，也就是说枚举表示的是一个命名元素的集合，因而它能够使您的程序避免因硬编码的值而显杂乱且难以维护。","text":"什么是枚举如 TypeScript 官方文档所说，枚举类型是对 JavaScript 标准数据类型集的扩充。对于熟悉 C# 的开发者来说，枚举类型并不陌生，它能够给一系列数值集合提供友好的名称，也就是说枚举表示的是一个命名元素的集合，因而它能够使您的程序避免因硬编码的值而显杂乱且难以维护。 简单说起默认情况下，枚举是基于 0 的，也就是说第一个值是 0，后面的值依次递增。不要担心，当中的每一个值都可以显式指定，只要不出现重复即可，没有被显式指定的值，都会在前一个值的基础上递增。 123456enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; // 1 或者 12enum Color &#123;Red = 1, Green, Blue = 4&#125;let c: Color = Color.Green; // 2 枚举有一个很方便的特性，就是您也可以向枚举传递一个数值，然后获取它对应的名称值。举个例子，如果我们有一个值 2，但是不清楚在 Color 枚举中与之对应的名称是什么，我们就可以通过以下的方式来进行检索： 反向映射除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字。 例如，在下面的例子中： 123enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]; // 2值的不是下标 而是green的值 &#x27;Green&#x27; 但是像上面的这种写法不是太好，因为如果您给定的数值没有与之对应的枚举项，那么结果就是 undefined。所以，如果您想要得到指定枚举项的字符串名称，可以使用类似这样的写法： 1let colorName: string = Color[Color.Green]; // &#x27;Green&#x27; 字符串枚举字符串枚举的概念很简单，但是有细微的 运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction &#123; Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,&#125; 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化,字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 异构枚举(不推荐)枚举可以混合字符串和数字成员(我们不建议你怎么做) 1234enum BooleanLikeHeterogeneousEnum &#123; No = 0, Yes = &quot;YES&quot;,&#125; 运行时的枚举枚举是在运行时真正存在的对象123enum E &#123; X, Y, Z&#125;使用123function f(obj: &#123; X: number &#125;) &#123; return obj.X;&#125; const枚举大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义。 12345const enum Enum &#123; A = 1, B = A * 2&#125; 外部枚举外部枚举用来描述已经存在的枚举类型的形状。 123456declare enum Enum &#123; A = 1, B, C = 2&#125; 计算的和常量成员每个枚举成员都带有一个值，它可以是 常量或 计算出来的. 1enum E &#123; X &#125; 枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符 +, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。 123456789enum FileAccess &#123; // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = &quot;123&quot;.length&#125; 参考简书-TypeScript 数据类型——枚举 (Enum)","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』泛型","slug":"TypeScript系列泛型","date":"2019-09-11T16:00:00.000Z","updated":"2020-09-16T09:07:53.000Z","comments":true,"path":"2019/09/12/TypeScript系列泛型/","link":"","permalink":"http://mariogogogo.github.io/2019/09/12/TypeScript%E7%B3%BB%E5%88%97%E6%B3%9B%E5%9E%8B/","excerpt":"组件在构建过程不仅要考虑当下的数据类型,也要考虑未来的扩展.让其灵活 在像 C#和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。","text":"组件在构建过程不仅要考虑当下的数据类型,也要考虑未来的扩展.让其灵活 在像 C#和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 不用泛型12345678function identity(arg: number): number &#123; return arg&#125;//或者 我们可以用anyfunction identity(arg: any): any &#123; return arg&#125; 但是 any 这种类型可以用任何类型,这样导致传入的类型和返回的类型可以不统一. 因此我们需要去规定返回类型与传入类型的相同,我们只用表示类型而不是值 使用泛型123function identity&lt;T&gt;(arg: T): T &#123; return arg&#125; 我们给这个方法传入类型变量T,这个T帮我们规定传入的类型(比如:number),之后我们就可以使用这个类型,之后我们再次使用这个T当返回值类型. 不同与 any,它不会丢失一些规则. 我们在定义了泛型后,可以用 2 种方法使用 1.传入所有的参数,包含类型参数 2.方法更普遍 1let output = identity &lt; string &gt; &#x27;myString&#x27; 或者 利用了类型推论 12//编译器会根据传入的参数自动地帮助我们确定T的类型let output = identity(&#x27;myString&#x27;) 使用泛型变量1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length) // Error: T doesn&#x27;t have .length return arg&#125; 编译器会报错说我们使用了 arg 的.length 属性，但是没有地方指明 arg 具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有.length属性的 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length) // Array has a .length, so no more error return arg&#125; 可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数 T 和参数arg，它是个元素类型是T的数组，并返回元素类型是 T 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 T 的的类型为number。 这可以让我们把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性 泛型类型泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样 1234567function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity//也可以用不同的泛型参数名let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity 还可以写个泛型接口 123456789101112interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg&#125;//类似于这样//let myIdentity: &#123;&lt;T&gt;(arg:T):T&#125; = identity;let myIdentity: GenericIdentityFn = identity 泛型类12345678910111213141516class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;//或者let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = &quot;&quot;;stringNumeric.add = function(x, y) &#123; return x + y; &#125;;alert(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;)); 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 泛型约束之前的例子 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length) // Error: T doesn&#x27;t have .length return arg&#125; 如果我们可以约束下 arg 的某一种类型是可以又 lenght 属性的 1234567891011interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;loggingIdentity(3); // Error, number doesn&#x27;t have a .length propertyloggingIdentity(&#123;length: 10, value: 3&#125;); 在泛型里使用类类型使用原型属性推断并约束构造函数与类实例的关系 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: &#123;new () =&gt; A&#125;): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』函数","slug":"TypeScript系列函数","date":"2019-09-08T16:00:00.000Z","updated":"2020-09-16T09:07:53.000Z","comments":true,"path":"2019/09/09/TypeScript系列函数/","link":"","permalink":"http://mariogogogo.github.io/2019/09/09/TypeScript%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0/","excerpt":"加班!加班!加班! 又好久没更了 😓","text":"加班!加班!加班! 又好久没更了 😓 函数是 JavaScript 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。 TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用 简单函数1234// thisfunction add1(x: any, y: any): number &#123; return x + y + 234;&#125; 函数类型包含两部分： 参数类型 返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写： 1234// 函数类型 == 参数类型 + 返回值类型const myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y;&#125;; 对于返回值，我们在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空。 推断类型你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型 1234567let myAdd = function(x: number, y: number): number &#123; return x + y;&#125;;let myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) &#123; return x + y;&#125;; 可选参数和默认参数在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 last 是可选的 12345function buildName2(first: string, last?: string) &#123; return first + &quot;,&quot; + last;&#125;const res3 = buildName2(&quot;jack&quot;); 我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 1234// 默认参数function buildName3(first = &quot;jack&quot;, last?: string) &#123; return first + &quot;,&quot; + last;&#125; 剩余参数有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。在 TypeScript 里，你可以把所有参数收集到一个变量里,可以一个都没有，同样也可以有任意个。编译器创建参数数组，名字是你在省略号（...）后面给定的名字，你可以在函数体内使用这个数组。 12345678910111213function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);//或者function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; this 和箭头函数this 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 1234567891011121314151617181920const deck = &#123; suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), createCardPicker() &#123; return function() &#123; const pickerCard = Math.floor(Math.random() * 52); const pickedSuit = Math.floor(pickerCard / 13); return &#123; suit: this.suits[pickedSuit], // this=&gt;指向全局 global undefined card: pickerCard % 13 &#125;; &#125;; &#125;&#125;;const cardPicker = deck.createCardPicker();const pickerCard = cardPicker();console.log(&quot;card:&quot; + pickerCard.card); 返回的函数里的this被设置成了 window 而不是 deck 对象。 this 参数123456789101112131415161718192021222324252627// 重构上面函数interface card &#123; suit: string card: number&#125;interface deck &#123; suits: string[] card: number[] createCardPicker(this: deck): () =&gt; card&#125;const deck1 = &#123; suits: [&#x27;hearts&#x27;, &#x27;spades&#x27;, &#x27;clubs&#x27;, &#x27;diamonds&#x27;], cards: Array(52), createCardPicker() &#123; console.log(&#x27;this&#x27;, this) return function(this: deck) &#123; const pickerCard = Math.floor(Math.random() * 52) const pickedSuit = Math.floor(pickerCard / 13) return &#123; suit: this.suits[pickedSuit], //this --&gt;deck card: pickerCard % 13, &#125; &#125; &#125;,&#125; 回调函数里的 this 参数当回调函数被调用时，它会被当成一个普通函数调用，this将为undefined。 稍做改动，你就可以通过 this 参数来避免错误。 1234interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void意味着addClickListener期望 onclick 是一个函数且它不需要一个 this 类型。 然后，为调用代码里的 this 添加类型注解： 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can&#x27;t use this here because it&#x27;s of type void! console.log(&quot;clicked!&quot;); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递 addClickListener 是合法的。 当然了，这也意味着不能使用this.info 如果你两者都想要，你不得不使用箭头函数了： 123456class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message; &#125;;&#125; 每个Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler 的原型链上。 它们在不同 Handler 对象间是共享的。 重载JavaScript 里函数根据传入不同的参数而返回不同类型的数据是很常见的。 123456789101112131415161718192021222324let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];&lt;!--参数为对象 == 返回 数字--&gt;function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;&lt;!--参数为数字== 返回对象 --&gt;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; if (typeof x == &quot;object&quot;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; else if (typeof x == &quot;number&quot;) &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: &quot;diamonds&quot;, card: 2 &#125;, &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit); 注意，function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』类","slug":"TypeScript系列类","date":"2019-08-31T16:00:00.000Z","updated":"2020-09-16T09:07:54.000Z","comments":true,"path":"2019/09/01/TypeScript系列类/","link":"","permalink":"http://mariogogogo.github.io/2019/09/01/TypeScript%E7%B3%BB%E5%88%97%E7%B1%BB/","excerpt":"ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。","text":"ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。 用 ES6 创建一个简单类1234567891011class Greeter &#123; greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet() &#123; return &#x27;Hello, &#x27; + this.greeting &#125;&#125;let greeter = new Greeter(&#x27;world&#x27;) 这个类有 3 个成员： 一个叫做 greeting 的属性， 一个构造函数 一个 greet 方法。 我们在引用任何一个类成员的时候都用了this。它表示我们访问的是类的成员。 继承12345678910111213141516class Animal &#123; move(distance: number = 0) &#123; console.log(`Animal moved $&#123;distance&#125;m.`) &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;Woof! Woof!&#x27;) &#125;&#125;const dog = new Dog()dog.bark()dog.move(10)dog.bark() 复杂版继承123456789101112131415161718192021222324252627282930313233343536class Animal &#123; name: string constructor(theName: string) &#123; this.name = theName &#125; move(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;m.`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 5) &#123; console.log(&#x27;Slithering...&#x27;) super.move(distanceInMeters) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 45) &#123; console.log(&#x27;Galloping...&#x27;) super.move(distanceInMeters) &#125;&#125;let sam = new Snake(&#x27;Sammy the Python&#x27;)let tom: Animal = new Horse(&#x27;Tommy the Palomino&#x27;)sam.move()tom.move(34) 与前一个例子的不同点是，派生类包含了一个构造函数，它必须调用super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。 重写move使得 move 方法根据不同的类而具有不同的功能。 注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse 里重写的方法： 公共，私有与受保护的修饰符默认为public 12345678class Animal &#123; public name: string; public constructor(theName: string) &#123; this.name = theName; &#125; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 理解private 表示不能在声明它的类的外部访问 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(&quot;Cat&quot;).name; // 错误: &#x27;name&#x27; 是私有的. 理解protected protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 readonly 修饰符可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 1234567891011// ===========》readonly 只读 修饰符class PresonOnly &#123; public readonly name: string constructor(name: string) &#123; this.name = name &#125;&#125;let john = new PresonOnly(&#x27;jon&#x27;)john.name = &#x27;&#x27; //error 不能修改 存取器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 123456789101112131415161718192021222324let passcode = &quot;secret passcode&quot;;class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) &#123; this._fullName = newName; &#125; else &#123; console.log(&quot;Error: Unauthorized update of employee!&quot;); &#125; &#125;&#125;let employee = new Employee();employee.fullName = &quot;Bob Smith&quot;;if (employee.fullName) &#123; alert(employee.fullName);&#125; 注意点: 首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有get不带有set的存取器自动被推断为 readonly 静态属性当类被实例化的时候才会被初始化的属性,我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上, 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样 1234567891011121314151617class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; //看这里 ⬇️ let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); 抽象类abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 12345678910111213141516171819202122232425262728293031323334abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(&#x27;Department name: &#x27; + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(&#x27;Accounting and Auditing&#x27;); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log(&#x27;The Accounting Department meets each Monday at 10am.&#x27;); &#125; generateReports(): void &#123; console.log(&#x27;Generating accounting reports...&#x27;); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』接口","slug":"TypeScript系列接口","date":"2019-08-29T16:00:00.000Z","updated":"2020-09-16T09:07:54.000Z","comments":true,"path":"2019/08/30/TypeScript系列接口/","link":"","permalink":"http://mariogogogo.github.io/2019/08/30/TypeScript%E7%B3%BB%E5%88%97%E6%8E%A5%E5%8F%A3/","excerpt":"在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约","text":"在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约 简单的接口我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松 123456789101112131415interface NameInfo &#123; firstname: string; lastname: string;&#125;const getFullName = (&#123; ...obj &#125;: NameInfo): string =&gt; &#123; return obj.firstname + obj.lastname;&#125;;console.log( getFullName(&#123; firstname: &quot;kac&quot;, lastname: &quot;123&quot; &#125;)); 如果方法中多添加属性则会报错 可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了 12345678910111213141516171819202122interface Vegetables &#123; color?: string; type: string; [prop: string]: any;&#125;const getVegetables = (&#123; color, type &#125;: Vegetables) =&gt; &#123; return color ? `color,+$&#123;color&#125;,$&#123;type&#125;` : &quot;没有传颜色&quot;;&#125;;console.log( getVegetables(&#123; color: &quot;red&quot;, type: &quot;看可是你&quot; &#125;));console.log( getVegetables(&#123; type: &quot;123&quot; &#125;)); 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用readonly来指定只读属性: 123456interface Point &#123; readonly x: number; readonly y: number;&#125;let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // error! readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。 添加一个字符串索引签名12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 讲到索引签名，但在这我们要表示的是 SquareConfig 可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"『TypeScript 系列』基础类型","slug":"TypeScript系列基础类型","date":"2019-08-28T16:00:00.000Z","updated":"2020-09-16T09:07:53.000Z","comments":true,"path":"2019/08/29/TypeScript系列基础类型/","link":"","permalink":"http://mariogogogo.github.io/2019/08/29/TypeScript%E7%B3%BB%E5%88%97%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/","excerpt":"最简单的数据单元：数字，字符串，结构体，布尔值等","text":"最简单的数据单元：数字，字符串，结构体，布尔值等 布尔值简单的 true/false 值 1let isBack: boolean = false 数字和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是number。 除了支持十进制和十六进制字面量，TypeScript还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 12345678910111213let decLiteral: number = 6let hexLiteral: number = 0xf00dlet binaryLiteral: number = 0b1010let octalLiteral: number = 0o744let x = [string, number]x = [&#x27;hje&#x27;, 10]//3.1版本之后就会报错 索引超过最大长度x[3] = 1 //errorx[6] = true // error 超过了2种类型 字符串我们使用string表示文本数据类型,用法与 JavaScript 无区别 12345let name: string = &quot;bob&quot;;name = &quot;smith&quot;;I&#x27;ll be $&#123; age + 1 &#125; years old next month.`; 数组有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： 1let arr: number[] = [1, 2, 3] 第二种方式是使用数组泛型，Array&lt;元素类型&gt; 1let arr: Array&lt;number&gt; = [1, 2, 3] 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 1234let x: [string, number]x = [&#x27;hello&#x27;, 10] // OKx = [10, &#x27;hello&#x27;] // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)) // OKconsole.log(x[1].substr(1)) // Error, &#x27;number&#x27; does not have &#x27;substr&#x27; 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = &#x27;world&#x27; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()) // OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString//但是不能越界x[6] = true // Error, 布尔不是(string | number)类型 枚举enum类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 任意值123let notSure: any = 4notSure = &#x27;maybe a string instead&#x27;notSure = false // okay, definitely a boolean 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let arr: any[] = [1, true, &#x27;free&#x27;]arr[1] = 100 空值某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void 123function error(): void &#123; console.log(&#x27;This is my warning message&#x27;)&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null： 1let unusable: void = undefined Null 和 UndefinedTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大： 12let u: undefined = undefinedlet n: null = null 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给number类型的变量。 Nevernever类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 1234567891011121314// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message)&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&#x27;Something failed&#x27;)&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; Symbols自 ECMAScript 2015 起，symbol成为了一种新的原生类型 symbol类型的值是通过 Symbol构造函数创建的。 123let sym1 = Symbol()let sym2 = Symbol(&#x27;key&#x27;) // 可选的字符串key Symbols 是不可改变且唯一的 1234let sym2 = Symbol(&#x27;key&#x27;)let sym3 = Symbol(&#x27;key&#x27;)sym2 === sym3 // false, symbols是唯一的 像字符串一样，symbols 也可以被用做对象属性的键。 1234567let prop2 = Symbol(&#x27;jack&#x27;)const info2 = &#123; [prop2]: &#x27;lison&#x27;, id: &#x27;1&#x27;, age: &#x27;99&#x27;&#125;console.table(info2) Symbols 也可以与计算出的属性名声明相结合来声明对象的属性和类成员。 12345678910const getClassNameSymbol = Symbol()class C &#123; [getClassNameSymbol]() &#123; return &#x27;C&#x27; &#125;&#125;let c = new C()let className = c[getClassNameSymbol]() // &quot;C&quot; Symbol.for123456789//静态方法let name2 = Symbol.for(&#x27;jack&#x27;)let name3 = Symbol.for(&#x27;jack&#x27;) //全局范围保护当前页面 （ifram serverWork） 它会去找之前有没有创建过symbol 如果有则不会创建新的console.log(name2 === name3) //truelet name4 = Symbol.keyFor(name3) //查询是否已经创建sysmbol值console.log(name4) // 返回属性名","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://mariogogogo.github.io/tags/TypeScript/"}]},{"title":"从零实现 react 之异步的 setState","slug":"从零实现react之异步的setState","date":"2019-08-19T16:00:00.000Z","updated":"2020-09-16T09:07:00.000Z","comments":true,"path":"2019/08/20/从零实现react之异步的setState/","link":"","permalink":"http://mariogogogo.github.io/2019/08/20/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%9A%84setState/","excerpt":"这篇文章的目标明确，我们要实现以下两个功能： 异步更新 state，将短时间内的多个 setState 合并成一个 为了解决异步更新导致的问题，增加另一种形式的 setState：接受一个函数作为参数，在函数中可以得到前一个状态并返回下一个状态","text":"这篇文章的目标明确，我们要实现以下两个功能： 异步更新 state，将短时间内的多个 setState 合并成一个 为了解决异步更新导致的问题，增加另一种形式的 setState：接受一个函数作为参数，在函数中可以得到前一个状态并返回下一个状态 React 中的 setState 是怎么做的? 123456789101112131415161718192021class Home extends Component &#123; constructor() &#123; super(); this.state = &#123; num: 0 &#125;; &#125; componentDidMount() &#123; for (let i = 0; i &lt; 10; i++) &#123; this.setState(&#123; num: this.state.num + 1 &#125;); console.log(this.state.num); // 会输出0 &#125; &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;&#123;this.state.num&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 结果: 组件渲染的结果是 1，并且在控制台中输出了 100 次 0，说明每个循环中，拿到的 state 仍然是更新之前的 这是 React 的优化手段，但是显然它也会在导致一些不符合直觉的问题（就如上面这个例子），所以针对这种情况，React 给出了一种解决方案：setState 接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。 我们可以通过这种方式来修正 App 组件： 1234567891011componentDidMount() &#123; for ( let i = 0; i &lt; 100; i++ ) &#123; this.setState( prevState =&gt; &#123; console.log( prevState.num ); return &#123; num: prevState.num + 1 &#125; &#125; ); &#125; console.log(num ); // 还是0&#125; 合并 setState我们先来看一下之前的写法 1234setState( stateChange ) &#123; Object.assign( this.state, stateChange ); renderComponent( this );&#125; 每次调用 setState 都会更新 state 并马上渲染一次。 模拟一个 setState 队列为了合并 setState，我们需要一个队列来保存每次 setState 的数据，然后在一段时间后，清空这个队列并渲染组件创建set_state_quene.js文件 123456789101112const queue = []; //队列数组function enqueueSetState( stateChange, component ) &#123; queue.push( &#123; stateChange, component &#125; );&#125;//修改Component.js中的setState方法setState( stateChange ) &#123; enqueueSetState( stateChange, this ); //this-&gt;Component实例&#125; 清空队列接下去思考如何清空队列 123456789101112131415161718192021222324function flush() &#123; let item; //取出最后一个值 while ((item = setStateQueue.shift())) &#123; /** * stateChange 可以是函数 或者 对象 */ const &#123; stateChange, component &#125; = item; //保存之前的状态 if (!component.prevState) &#123; component.prevState = Object.assign(&#123;&#125;, component.state); &#125; //setstate是个方法 回调函数 if (typeof stateChange === &quot;function&quot;) &#123; console.log(&quot;stateChange是个函数&quot;, stateChange); Object.assign(component.state, stateChange(component.prevState, component.props)); &#125; else &#123; // 是一个对象传入更新 Object.assign(component.state, stateChange); &#125; // 每次循环 保存当前一次的state作为前一次的state component.prevState = component.state - 1; &#125;&#125; 这只是实现了 state 的更新，我们还没有渲染组件。渲染组件不能在遍历队列时进行，因为同一个组件可能会多次添加到队列中，我们需要另一个队列保存所有组件，不同之处是，这个队列内不会有重复的组件。 我们在 enqueueSetState 时，就可以做这件事 12345678910111213141516export function enqueueSetState(stateChange, component) &#123; //如果renderQueue 没有 则添加队列 let r = renderQueue.some(item =&gt; &#123; return (item = component); &#125;); //r不存在证明是第一次添加 if (!r) &#123; renderQueue.push(component); //添加组件 &#125; // 短时间合并多个setState setStateQueue.push(&#123; stateChange, component &#125;);&#125; 在 flush 方法中，我们还需要遍历 renderQueue，来渲染每一个组件 12345678function flush() &#123; let item, component; ... while ((component = renderQueue.shift())) &#123; renderComponent(component); &#125;&#125; 异步执行我们需要合并一段时间内所有的 setState，也就是在一段时间后才执行 flush 方法来清空队列，这就表示需要异步执行,会想到什么呢? setTimeout,Promise ? 先来看这样一段代码： 1234567setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);Promise.resolve().then(() =&gt; console.log(1));console.log(3);//执行结果 3 1 2 我们可以利用事件队列，让 flush 在所有同步任务后执行 12345678910111213function enqueueSetState(stateChange, component) &#123; // 如果queue的长度是0，也就是在上次flush执行之后第一次往队列里添加 if (queue.length === 0) &#123; defer(flush); &#125; queue.push(&#123; stateChange, component &#125;); if (!renderQueue.some(item =&gt; item === component)) &#123; renderQueue.push(component); &#125;&#125; 创建 defer 方法，利用 Promise.resolve 123function defer(fn) &#123; return Promise.resolve().then(fn);&#125; 这样在一次“事件循环“中，最多只会执行一次 flush 了，在这个“事件循环”中，所有的 setState 都会被合并，并只渲染一次组件。","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"从零实现 react 之 diff 算法","slug":"从零实现react之diff算法","date":"2019-08-17T16:00:00.000Z","updated":"2020-09-16T09:07:00.000Z","comments":true,"path":"2019/08/18/从零实现react之diff算法/","link":"","permalink":"http://mariogogogo.github.io/2019/08/18/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8Bdiff%E7%AE%97%E6%B3%95/","excerpt":"这篇文章是采用 preact 的做法，对比真实 dom 和虚拟 dom，并且在对比的过程中直接更新真实 dom","text":"这篇文章是采用 preact 的做法，对比真实 dom 和虚拟 dom，并且在对比的过程中直接更新真实 dom diff 算法diff 算法?what?什幺玩意如何減少 DOM 更新:我們需要找出諠染前后真正変化的部分,只更新这一部分.而対比変化,找出需要更新部分的算法称之为diff算法対比策略在前面我們实现了render 方法,它能將虚似 DOM 装換成真正的 DOM但是我們需要改迸它,不要止它優乎乎地重新這染整个 DOM 村,而是找出真正変化的部分迸行替換.这部分很多类 React 框架实现方式都不太一样，有的框架会迭拝保存上次諠染的虚似 DOM，然后対比虚批 DOM 前后的変化，得到一系列更新的数 据，然后再將逑些更新到真正的 DOM上。 不管是 DOM 还是虚拟 DOM，它们的结构都是一棵树，完全对比两棵树变化的算法时间复杂度是 O(n^3)，但是考虑到我们很少会跨层级移动 DOM，所以我们只需要对比同一层级的变化。 总而言之，我们的 diff 算法有两个原则： 对比当前真实的 DOM 和虚拟 DOM，在对比过程中直接更新真实 DOM 只对比同一层级的变化 diff 方法我们需要实现一个 diff 方法，它的作用是对比真实 DOM 和虚拟 DOM，最后返回更新后的 DOM 我们先来简单看一下的三种虚拟 dom 结构 1234567891011121314151617181920// 原生DOM节点的vnode&#123; tag: &#x27;div&#x27;, attrs: &#123; className: &#x27;active&#x27; &#125;, children: []&#125;// 文本节点的vnode&quot;hello,world&quot;// 组件的vnode&#123; tag: ComponentConstrucotr, attrs: &#123; className: &#x27;active&#x27; &#125;, children: []&#125; 我们首先要改变render方法 123456//增加dom参数 初始为undefinedfunction render(vnode, container,dom) &#123; - const _vnode = _render(vnode); //返回js节点对象 + const _vnode = diff(dom,vnode,container) return container.appendChild(_vnode);&#125; 最简单的实现是先创建一个 diff 方法 123456789function diff(dom, vnode, container) &#123; //对比节点的变化 const ret = diffNode(dom, vnode); if (container) &#123; container.appendChild(ret); &#125; return ret;&#125;function diffNode(dom, vnode) &#123;&#125; 文本节点判断123456789101112131415161718192021222324function diffNode(dom, vnode) &#123; let out = dom; //初始dom为undefined //判断vnode是否为空 if (vnode === undefined || vnode === null) return; //如果vnode是数字类型则强制转化 string类型 if (typeof vnode === &quot;number&quot;) vnode = String(vnode); //判断vnode是否为字符串 if (typeof vnode === &quot;string&quot;) &#123; // 如果当前的DOM就是文本节点，则直接更新内容 if (dom &amp;&amp; dom.nodeType === 3) &#123; if (dom.textContent !== vnode) &#123; dom.textContent = vnode; &#125; // 如果DOM不是文本节点，则新建一个文本节点DOM，并移除掉原来的 &#125; else &#123; out = document.createTextNode(vnode); if (dom &amp;&amp; dom.parentNode) &#123; dom.parentNode.replaceChild(out, dom); &#125; &#125; return out; &#125;&#125; 它没有属性，也没有子元素，就可以直接返回结果了 非文本节点判断vnode 表示的是一个非文本的 DOM 节点，那就要分两种情况了：一：如果真实 DOM 不存在，表示此节点是新增的，或者新旧两个节点的类型不一样，那么就新建一个 DOM 元素，并将原来的子节点（如果有的话）移动到新建的 DOM 节点下。 1234if (!dom) &#123; out = document.createElement(vnode.tag); diffAttribute(out, vnode);&#125; diffAttribute 对比属性12345678910111213141516171819202122232425262728293031323334/* * dom 真实dom * vnode 虚拟dom */function diffAttribute(dom, vnode) &#123; //保存之前的dom所以属性 const oldAttrs = &#123;&#125;; //新的属性值 const newAttrs = vnode.attrs; console.log(&quot;newAttrs&quot;, newAttrs); // &#123; className: &quot;active&quot;, title: &quot;123&quot; &#125; // dom 原有节点对象 vnode 虚拟节点 const domAttrs = dom.attributes; console.log(&quot;domAttrs&quot;, domAttrs); [...domAttrs].forEach(item =&gt; &#123; console.log(item); oldAttrs[item.name] = item.value; //&#123;id:root&#125; &#125;); //如果原来的属性不在新的属性当中，则将其移除掉（属性值设为undefined） for (let key in newAttrs) &#123; if (!(key in oldAttrs)) &#123; //移除dom setAttribute(dom, key, undefined); &#125; &#125; //更新对应属性 class=&quot;abc&quot; ==&gt; class=&quot;cba&quot; for (let key in newAttrs) &#123; //属性值不相等的情况 if (oldAttrs[key] !== newAttrs[key]) &#123; //增加dom setAttribute(dom, key, newAttrs[key]); &#125; &#125;&#125; 二：如果真实 DOM 存在，并且和虚拟 DOM 是同一类型的，那我们暂时不需要做别的，只需要等待后面对比属性和对比子节点。 对比子节点的判断这里会面临一个问题，前面我们实现的不同 diff 方法，都是明确知道哪一个真实 DOM 和虚拟 DOM 对比，但是子节点是一个数组，它们可能改变了顺序，或者数量有所变化，我们很难确定要和虚拟DOM对比的是哪一个。为了简化逻辑，我们可以让用户提供一些线索：给节点设一个 key 值，重新渲染时对比key值相同的节点 12345//比较子节点(dom节点和组件)if ((vnode.children &amp;&amp; vnode.children.length &gt; 0) || (out.childNodes &amp;&amp; out.childNodes.length &gt; 0)) &#123; //对比组件和 子节点 diffChildren(out, vnode.children);&#125; diffChildren一开始 dom 为空值,只去加载 vchildren,对 vchildren 做相应操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function diffChildren(dom, vchildren) &#123; const domChildren = dom.childNodes; const children = []; const keyed = &#123;&#125;; // 将有key的节点和没有key的节点分开 if (domChildren.length &gt; 0) &#123; for (let i = 0; i &lt; domChildren.length; i++) &#123; const child = domChildren[i]; const key = child.key; if (key) &#123; keyed[key] = child; &#125; else &#123; children.push(child); &#125; &#125; &#125; //一开始先走这里 if (vchildren &amp;&amp; vchildren.length &gt; 0) &#123; let min = 0; let childrenLen = children.length; for (let i = 0; i &lt; vchildren.length; i++) &#123; const vchild = vchildren[i]; const key = vchild.key; let child; // 如果有key，找到对应key值的节点 if (key) &#123; if (keyed[key]) &#123; child = keyed[key]; keyed[key] = undefined; &#125; // 如果没有key，则优先找类型相同的节点 &#125; else if (min &lt; childrenLen) &#123; for (let j = min; j &lt; childrenLen; j++) &#123; let c = children[j]; if (c &amp;&amp; isSameNodeType(c, vchild)) &#123; child = c; children[j] = undefined; if (j === childrenLen - 1) childrenLen--; if (j === min) min++; break; &#125; &#125; &#125; // 对比 child = diff(child, vchild); // 更新DOM const f = domChildren[i]; if (child &amp;&amp; child !== dom &amp;&amp; child !== f) &#123; // 如果更新前的对应位置为空，说明此节点是新增的 if (!f) &#123; dom.appendChild(child); // 如果更新后的节点和更新前对应位置的下一个节点一样，说明当前位置的节点被移除了 &#125; else if (child === f.nextSibling) &#123; removeNode(f); // 将更新后的节点移动到正确的位置 &#125; else &#123; // 注意insertBefore的用法，第一个参数是要插入的节点，第二个参数是已存在的节点 dom.insertBefore(child, f); &#125; &#125; &#125; &#125;&#125; 在对比过程中我们在之前的createElement返回值中增加一个 key 值, 12345678910function createElement(tag,attrs,...childrens)&#123; + attrs = attrs || &#123;&#125; return &#123; tag, attrs, childrens, + key:attrs.key || null &#125;&#125; 组件的 diff如果 vnode 是一个组件，我们也单独拿出来作为一个方法: 1234//如果是 函数组件if (typeof vnode.tag === &quot;function&quot;) &#123; return diffComponent(dom, vnode);&#125; diffComponent 方法 123456789101112131415161718192021222324252627282930313233343536373839function diffComponent(dom, vnode) &#123; let comp = dom &amp;&amp; dom._component; let oldDom = dom; // 如果组件类型没有变化，则重新set props if (comp &amp;&amp; comp.constructor === vnode.tag) &#123; setComponentProps(comp, vnode.attrs); dom = comp.base; // 如果组件类型变化，则移除掉原来组件，并渲染新的组件 &#125; else &#123; if (comp) &#123; //卸载组件 unmountComponent(comp); oldDom = null; &#125; //创建新组件 comp = createComponent(vnode.tag, vnode.attrs); //设置组件属性 setComponentProps(comp, vnode.attrs); //挂载新组件 dom = comp.base; if (oldDom &amp;&amp; dom !== oldDom) &#123; oldDom._component = null; removeNode(oldDom); &#125; &#125; return dom;&#125;/** * 卸载组件 * @param &#123;*&#125; component */function unmountComponent(component) &#123; if (component.componentWillUnmount) component.componentWillUnmount(); removeNode(component.base);&#125; 重新修改 renderComponent当然我们还需要去改renderComponent方法 123456789101112131415161718192021222324export function renderComponent(comp) &#123; let base; const render = comp.render(); //返回jsx对象 if (comp.base &amp;&amp; comp.componentWillUpdate) &#123; comp.componentWillUpdate(); &#125; if (comp.base) &#123; //代表组件已经挂载了 if (comp.componentDidUpdate) comp.componentDidUpdate(); &#125; else if (comp.componentDidMount) &#123; comp.componentDidMount(); &#125; - base = _render(render); //返回js节点对象 + base = diffNode(comp.base,render) console.log(&quot;js节点对象&quot;, base); //原先整个dom替换的方案就被剔除 - if (comp.base &amp;&amp; comp.base.parentNode) &#123; - comp.base.parentNode.replaceChild(base, comp.base); - &#125; comp.base = base;&#125; 体验下 diff 与没有 diff","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"从零实现 react 之生命周期的方法","slug":"从零实现react之生命周期的方法","date":"2019-08-14T16:00:00.000Z","updated":"2020-09-16T09:06:59.000Z","comments":true,"path":"2019/08/15/从零实现react之生命周期的方法/","link":"","permalink":"http://mariogogogo.github.io/2019/08/15/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"React 生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在 React 不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下 React 的生命周期函数","text":"React 生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在 React 不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下 React 的生命周期函数 看一下流程图 12345678910111213141516171819202122232425262728293031323334353637383940414243class Home extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; num: 0 &#125;; &#125; componentWillMount() &#123; console.log(&quot;组件将要加载&quot;); &#125; componentWillReceiveProps(nextProps) &#123; console.log(&quot;componentWillReceiveProps&quot;, nextProps); &#125; componentWillUpdate() &#123; console.log(&quot;组件即将更新&quot;); &#125; componentDidUpdate(prevProps, prevState) &#123; console.log(&quot;组件更新完成&quot;); &#125; componentDidMount() &#123; console.log(&quot;组件加载完成&quot;); &#125; componentWillUnmount() &#123; console.log(&quot;组件卸载&quot;); &#125; add() &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; render() &#123; return ( &lt;div className=&quot;active&quot; title=&quot;123&quot;&gt; hello,&lt;span&gt;我是类组件react,&#123;this.state.num&#125;&lt;/span&gt; &lt;button onClick=&#123;this.add.bind(this)&#125;&gt;点击我,更新&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 首先我们在调用componentWillMount的时候组件是不是还没有被渲染,我们就可以考虑是否在renderComponent方法之前执行我们的将要更新的生命周期方法 setComponentProps如何判断组件是否已经挂载?可以使用comp.base 123456789101112131415function setComponentProps(comp, props) &#123; /** * 实现生命周期 */ if (!comp.base) &#123; if (comp.componentWillMount) comp.componentWillMount(); &#125; else if (comp.componentWillReceiveProps) &#123; comp.componentWillReceiveProps(); &#125; //挂载comp上属性 comp.props = props; // 渲染组件 renderComponent(comp);&#125; renderComponent那么继续考虑componentWillUpdate,componentDidUpdate,componentDidMount的生命周期在哪里实现? 应该在renderComponent方法中 12345678910111213141516171819202122232425export function renderComponent(comp) &#123; let base; const render = comp.render(); //返回jsx对象 if (comp.base &amp;&amp; ) &#123; comp.componentWillUpdate(); &#125; if (comp.base) &#123; //代表组件已经挂载了 if (comp.componentDidUpdate) comp.componentDidUpdate(); &#125; else if (comp.componentDidMount) &#123; comp.componentDidMount(); &#125; base = _render(render); //返回js节点对象 console.log(&quot;js节点对象&quot;, base); //更改状态 if (comp.base &amp;&amp; comp.base.parentNode) &#123; comp.base.parentNode.replaceChild(base, comp.base); &#125; comp.base = base; console.log(&quot;comp&quot;, comp);&#125; 当然这个生命周期是最简单的实现,并没有考虑很多情况,比如子组件更新完才能父组件更新…","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"从零实现 react 之组件实现","slug":"从零实现react之组件实现","date":"2019-08-11T16:00:00.000Z","updated":"2020-09-16T09:07:00.000Z","comments":true,"path":"2019/08/12/从零实现react之组件实现/","link":"","permalink":"http://mariogogogo.github.io/2019/08/12/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/","excerpt":"组件分为函数组件和类组件","text":"组件分为函数组件和类组件 函数组件12345678910/** * 函数式组件 */function Home() &#123; return ( &lt;div className=&quot;active&quot; title=&quot;123&quot;&gt; hello,&lt;span&gt;我是函数react&lt;/span&gt; &lt;/div&gt; );&#125; 类组件1234567891011121314151617class Home1 extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: &quot;jack&quot;, num: 0 &#125;; &#125; render() &#123; return ( &lt;div className=&quot;active&quot; title=&quot;123&quot;&gt; hello,&lt;span&gt;我是类组件react,&#123;this.state.num&#125;&lt;/span&gt; &lt;button onClick=&#123;this.add.bind(this)&#125;&gt;点击我,更新&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; Component组件基类 React.Component 包含了一些预先定义好的变量和方法，我们来一步一步地实现它：先定义一个 Component 类： 1234567class Component &#123; constructor(props = &#123;&#125;) &#123; this.props = props; this.state = &#123;&#125;; &#125;&#125;export default Component; 通过定义组件我们还可以添加state &amp; props属性,进行初始化 setState组件内部还有个setState方法修改数据 123456789import &#123; renderComponent &#125; from &#x27;../react-dom/render&#x27;...setState(stateChange) &#123; //更新数据 Object.assign(this.state,stateChange) //重新渲染组件 this指当前组件 console.log(&#x27;Component-this&#x27;, this); renderComponent(this) &#125; 当然我们知道 setState 是异步的,我们只是先实现一个最简单粗暴的 setState.后面会继续迭代这个方法. render我们继续分析一下render方法我们继续将 render 方法做一些改变,小小的封装一下,设置一个_render方法返回 jsx 节点对象 1234function render(vnode, container) &#123; const _vnode = _render(vnode); //返回js节点对象 return container.appendChild(_vnode);&#125; react 是如何区分如何区分一个类组件与函数组件 首先函数组件可以直接 new 函数组件.那么类组件如何判断? 1home.prototype &amp;&amp; home.prototype.render; _render123456789101112131415161718192021function _render(vnode) &#123; .... //判断组件是函数 if (typeof vnode.tag === &quot;function&quot;) &#123; //创建组件 const comp = createComponent(vnode.tag,vnode.attrs) console.log(&#x27;函数组件&#x27;,comp); //设置组件属性 setComponentProps(comp,vnode.attrs) //组件渲染节点 返回对象 return comp.base &#125; // 将虚拟dom转化成真实dom打印到页面中 vnode.childrens.forEach(child =&gt; &#123; render(child, dom); &#125;); return dom;&#125; 组件的渲染用到了createComponent和setComponentProps两个方法.我们来分析下 createComponentcreateComponent方法用来创建组件实例，并且将函数定义组件扩展为类定义组件进行处理，以免其他地方需要区分不同定义方式。 1234567891011121314151617181920//创建组件function createComponent(comp, props) &#123; let inst; // 如果是类定义组件，则直接返回实例 if (comp.prototype &amp;&amp; comp.prototype.render) &#123; //类组件 inst = new comp(props); &#125; else &#123; //函数组件 扩展成类组件 构造一个实例, 统一管理 inst = new Component(props); // 构造函数的指向 inst.constructor = comp; //定义render函数 inst.render = function() &#123; return this.constructor(props); //==&gt; 相当于执行 类组件仲 render()&#123;xxxxx&#125; 方法 &#125;; &#125; return inst;&#125; setComponentPropssetComponentProps 方法用来更新props，在其中可以实现componentWillMount，componentWillReceiveProps两个生命周期方法(生命周期我们下次再说) 12345function setComponentProps(comp, props) &#123; comp.props = props; // 渲染组件 renderComponent(comp);&#125; renderComponent12345678function renderComponent(comp) &#123; let base; //初始化一个属性用于存放节点对象 const render = comp.render(); //返回jsx对象 base = _render(render); //返回js节点对象 console.log(&quot;js节点对象&quot;, base); comp.base = base; console.log(&quot;comp&quot;, comp);&#125; 现在大部分工作已经完成，我们可以用它来渲染组件了。","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"从零实现 react 之 JSX 和虚拟 DOM","slug":"从零实现react之JSX和虚拟DOM","date":"2019-08-10T16:00:00.000Z","updated":"2020-09-16T09:07:00.000Z","comments":true,"path":"2019/08/11/从零实现react之JSX和虚拟DOM/","link":"","permalink":"http://mariogogogo.github.io/2019/08/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8BJSX%E5%92%8C%E8%99%9A%E6%8B%9FDOM/","excerpt":"我们可以从最简单分析一下 1ReactDOM.render(&quot;ele&quot;, document.getElementById(&quot;root&quot;));","text":"我们可以从最简单分析一下 1ReactDOM.render(&quot;ele&quot;, document.getElementById(&quot;root&quot;)); 以上代码的意思就是说传入一个字符串和一个节点对象,将字符串挂载到节点对象中并显示到页面中 那 render 的含义其实就是渲染 123456789101112const ReactDOM = &#123; render&#125;;/** * * @param &#123;虚拟dom/root节点&#125; vnode * @param &#123;容器&#125; container */function render(vnode, container) &#123; return container.appendChild(dom);&#125; 这样我们的元素就挂载完成 但 react 远远不止那么简单对吧.我们render第一个参数中还可以传函数组件和类组件 jsx 对象1234567891011121314const ele = ( &lt;div className=&quot;active&quot; title=&quot;123&quot;&gt; hello,&lt;span&gt; react&lt;/span&gt; &lt;/div&gt;);/** 模拟出以下代码 var ele = React.createElement(&quot;div&quot;, &#123; cl: true, as: true, sName: &quot; active&quot;, title: &quot; 123 &quot;&#125;, &quot;hello, &quot;, React.createElement(&quot;span&quot;, null, &quot; react&quot;)); */ 经过转化,应该是这样的 我们来看看 render 函数是如何实现? render方法的作用就是将虚拟 DOM 渲染成真实的 DOM 我们首先要将 ele 中的 dom 对象解析成 jsx 对象 123456789101112const React = &#123; createElement&#125;;function createElement(tag, attrs, ...childrens) &#123; return &#123; tag, attrs, childrens &#125;;&#125;export default React; 如下代码实现ReactDOM.render 1234567//最简单的实现const ReactDOM = &#123; render&#125;;function render(vnode, container) &#123;&#125;export default ReactDOM; 虚拟节点的校验接下来继续细化每一个细节,render中要校验一下vnode 123456789101112131415161718function render(vnode, container) &#123; //判断vnode是否为空 if (vnode === undefined || vnode === null) return; //如果vnode是数字类型则强制转化 string类型 if (typeof vnode === &quot;number&quot;) vnode = String(vnode); //判断vnode是否为字符串 if (typeof vnode === &quot;string&quot;) &#123; //创建文本节点 const textNode = document.createTextNode(vnode); return container.appendChild(textNode); &#125; // 否则就是虚拟dom对象 const &#123; tag, attrs &#125; = vnode; //创建节点对象 const dom = document.createElement(tag); // &lt;div&gt;&lt;/div&gt; return container.appendChild(dom);&#125; 文本节点渲染继续我们可以考虑&lt;div className=&quot;box&quot;,title=&quot;文本&quot;&gt;节点对象上的属性如何添加呢饿? 12345678910...... const dom = document.createElement(tag); //判断如果有属性值if (attrs) &#123; Object.keys(attrs).forEach(key =&gt; &#123; const value = attrs[key]; //添加节点属性 setAttribute(dom, key, value); &#125;);&#125; 我们继续分析一下setAttribute添加属性的方法 12345678910111213141516171819202122232425262728293031323334353637// 对dom中的标签设置属性名 div class=&quot;root&quot; or div onclick=&quot;add()&quot;function setAttribute(dom, key, value) &#123; //判断class属性名 if (key === &quot;className&quot;) &#123; key = &quot;class&quot;; &#125; //判断是否是点击事件 if (/on\\w/.test(key)) &#123; key = key.toLocaleLowerCase(); //onClick -&gt; onclick dom[key] = value || &quot;&quot;; &#125; else if (key === &quot;style&quot;) &#123; //例如 div style=&quot;xxxx:xxxx&quot; or stlye=&#123;&#123;&#125;&#125; if (!value || typeof value === &quot;string&quot;) &#123; dom.style.cssText = value || &quot;&quot;; &#125; else if (value &amp;&amp; typeof value === &quot;object&quot;) &#123; for (const k in value) &#123; // &#123;width:20&#125; if (typeof value[k] === &quot;number&quot;) &#123; dom.style[k] = value[k] + &quot;px&quot;; &#125; else &#123; dom.style[k] = value[k]; &#125; &#125; &#125; &#125; else &#123; //其他属性 if (key in dom) &#123; dom[key] = value || &quot;&quot;; &#125; //更新值 if (value) &#123; dom.setAttribute(key, value); &#125; else &#123; dom.removeAttribute(key); &#125; &#125;&#125; 子节点渲染我们在createElement中有childrens属性,代表其他子节点可以是字符串也可能是数组 1234567function createElement(tag, attrs, ...childrens) &#123; return &#123; tag, attrs, childrens //其他子节点 &#125;;&#125; 所以我们需要利用递归 12345678910/** 渲染子节点 用递归 * &lt;div&gt;hello,&lt;span&gt;123&lt;/span&gt;&lt;/div&gt; */if (vnode.childrens) &#123; vnode.childrens.forEach(child =&gt; &#123; render(child, dom); &#125;);&#125;return container.appendChild(dom); 到这里最简单的 jsx 与虚拟 dom 就分析到这里","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"从零实现 react 之介绍以及相关配置","slug":"从零实现react之介绍以及相关配置","date":"2019-08-08T16:00:00.000Z","updated":"2020-09-16T09:06:59.000Z","comments":true,"path":"2019/08/09/从零实现react之介绍以及相关配置/","link":"","permalink":"http://mariogogogo.github.io/2019/08/09/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0react%E4%B9%8B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"我们要配置一下创建一个miniReact文件夹,初始化配置 1yarn init -y","text":"我们要配置一下创建一个miniReact文件夹,初始化配置 1yarn init -y 下载一些依赖 123yarn add -g parcel-bundleryarn add babel-core babel-preset-env babel-plugin-transform-react-jsx --dev parcel 是一个非常好用的零配置打包工具 接下来新建 index.js 和 index.html，在 index.html 中引入 index.js。 注意一下 babel 的配置 .babelrc 12345678&#123; &quot;presets&quot;: [&quot;env&quot;], &quot;plugins&quot;: [ [&quot;transform-react-jsx&quot;, &#123; &quot;pragma&quot;: &quot;React.createElement&quot; &#125;] ]&#125; 这个transform-react-jsx就是将jsx转换成js的 babel 插件，它有一个 pragma 项，可以定义 jsx 转换方法的名称，你也可以将它改成 h（这是很多类 React 框架使用的名称) 准备工作完成后，我们可以用命令 parcel index.html 将它跑起来了，当然，现在它还什么都没有。 我们再下一次介绍如何解析 jsx","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"VSCode书写项目配置eslint+prettier 统一代码风格","slug":"VS Code书写项目配置 eslint+prettier 统一代码风格","date":"2019-08-07T16:00:00.000Z","updated":"2020-09-16T09:07:55.000Z","comments":true,"path":"2019/08/08/VS Code书写项目配置 eslint+prettier 统一代码风格/","link":"","permalink":"http://mariogogogo.github.io/2019/08/08/VS%20Code%E4%B9%A6%E5%86%99%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%20eslint+prettier%20%E7%BB%9F%E4%B8%80%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/","excerpt":"项目写的人越来越多，统一代码规范的趋势越来越重要，研究下eslint吧","text":"项目写的人越来越多，统一代码规范的趋势越来越重要，研究下eslint吧 关于eslint的历史谷歌吧 安装1yarn global add eslint 初始化项目12345mkdir eslint-democd eslint-demoeslint --init 然后进入智能问答时间O(∩_∩)O~~ 123456789101112? How would you like to configure ESLint? Answer questions about your style? Are you using ECMAScript 6 features? Yes? Are you using ES6 modules? Yes? Where will your code run? Browser? Do you use CommonJS? Yes? Do you use JSX? No? What style of indentation do you use? Tabs? What quotes do you use for strings? Single? What line endings do you use? Windows? Do you require semicolons? No? What format do you want your config file to be in? JavaScript 全部回答之后生成一个.eslint.js文件，内容里面很多 1234567891011121314151617181920212223242526272829module.exports = &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;commonjs&quot;: true, &quot;es6&quot;: true &#125;, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parserOptions&quot;: &#123; &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;rules&quot;: &#123; &quot;indent&quot;: [ &quot;error&quot;, &quot;tab&quot; ], &quot;linebreak-style&quot;: [ &quot;error&quot;, &quot;windows&quot; ], &quot;quotes&quot;: [ &quot;error&quot;, &quot;single&quot; ], &quot;semi&quot;: [ &quot;error&quot;, &quot;never&quot; ] &#125;&#125;; 里面很多参数一脸懵逼，没关系全删了，只留下一个 123module.exports = &#123; &quot;extends&quot;: &quot;eslint:recommended&quot; &#125;; 测试我们写一个简单的demo.js 1234567891011121314151617181920212223242526function merge() &#123; var ret = &#123;&#125; for (var i in arguments) &#123; var m = arguments[i] for (var j in m) ret[j] = m[j] &#125; return ret&#125;console.log(merge(&#123; a: 123 &#125;, &#123; b: 456 &#125;))var a = &#x27;123&#x27;, b = &#x27;23444&#x27;function add(a, b) &#123; return a &gt;= b&#125;add(a, b)let aaa = () =&gt; &#123; return true&#125;console.log(aaa()) 然后终端输入 1eslint demo.js 结果显示 解决no-undef:出错的原因是因为JavaScript有很多种运行环境,比如常见的有浏览器和Node.js，另外还有很多软件系统使用JavaScript作为其脚本引擎，比如PostgreSQL就支持使用JavaScript来编写存储引擎，而这些运行环境可能并不存在console这个对象。另外在浏览器环境下会有window对象，而Node.js下没有；在Node.js下会有process对象，而浏览器环境下没有。 12345678910module.exports = &#123; extends: &#x27;eslint:recommended&#x27;, env: &#123; node: true, //程序的运行环境 &#125;, rules: &#123; &#125;&#125;; 再运行 1eslint demo.js 就没有错误了 常用参数env当然env也可以加入其他环境12345env: &#123; &#x27;browser&#x27;: true, &#x27;commonjs&#x27;: true, &#x27;es6&#x27;: true&#125;, rulues规则错误等级有三种12345670或’off’：关闭规则。 1或’warn’：打开规则，并且作为一个警告（并不会导致检查不通过）。 2或’error’：打开规则，并且作为一个错误 (退出码为1，检查不通过)。参数说明： 参数1 ： 错误等级 参数2 ： 处理方式 配置代码注释方式123456789忽略 no-undef 检查 /* eslint-disable no-undef */忽略 no-new 检查 /* eslint-disable no-new */设置检查 /*eslint eqeqeq: off*/ /*eslint eqeqeq: 0*/ 项目中配置eslintrc1234567891011121314module.exports = &#123; extends: &#x27;eslint:recommended&#x27;, env: &#123; node: true &#125;, parser: &#x27;babel-eslint&#x27;, rules: &#123; &#x27;no-console&#x27;: &#x27;off&#x27;, //强制使用单引号 quotes: [&#x27;error&#x27;, &#x27;single&#x27;], //强制不使用分号结尾 semi: [&#x27;error&#x27;, &#x27;never&#x27;] &#125;&#125; vscode中全局配置必须安装项目配置了使用eslint必须安装Document This插件 12345678910111213141516171819202122232425262728&quot;workbench.iconTheme&quot;: &quot;vscode-icons-mac&quot;,&quot;editor.renderIndentGuides&quot;: false,&quot;cSpell.ignoreWords&quot;: [&quot;antd&quot;],//编辑器失去焦点时自动保存更新后的文件&quot;files.autoSave&quot;: &quot;onFocusChange&quot;,&quot;workbench.colorTheme&quot;: &quot;Monokai&quot;,&quot;git.confirmSync&quot;: false,&quot;window.title&quot;: &quot;$&#123;activeEditorLong&#125;$&#123;separator&#125;$&#123;rootName&#125;&quot;,&quot;window.zoomLevel&quot;: 0,&quot;editor.fontSize&quot;: 14,//为了符合eslint的两个空格间隔原则&quot;editor.tabSize&quot;: 2,// 文件头部注释&quot;fileheader.Author&quot;: &quot;Mario&quot;,&quot;fileheader.LastModifiedBy&quot;: &quot;mario&quot;,//关闭编辑器默认代码检查,为了不跟eslint配置冲突&quot;editor.formatOnSave&quot;: false,&quot;javascript.format.enable&quot;: false,//eslint 格式化插件，保存时应用eslint规则自动格式化后保存&quot;eslint.autoFixOnSave&quot;: true,&quot;prettier.eslintIntegration&quot;: true,// 去掉代码结尾分号&quot;prettier.semi&quot;: false,&quot;git.path&quot;: &quot;/usr/bin/git&quot;,&quot;editor.fontFamily&quot;: &quot;Microsoft YaHei，Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;,&quot;editor.fontWeight&quot;: &quot;bold&quot;,&quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;never&quot;,&quot;explorer.confirmDragAndDrop&quot;: false","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"HTML 获取屏幕&浏览器&页面的高度宽度","slug":"HTML 获取屏幕&浏览器&页面的高度宽度","date":"2019-08-04T16:00:00.000Z","updated":"2020-12-08T06:36:55.000Z","comments":true,"path":"2019/08/05/HTML 获取屏幕&浏览器&页面的高度宽度/","link":"","permalink":"http://mariogogogo.github.io/2019/08/05/HTML%20%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95&%E6%B5%8F%E8%A7%88%E5%99%A8&%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%AB%98%E5%BA%A6%E5%AE%BD%E5%BA%A6/","excerpt":"本篇主要介绍Web环境中屏幕、浏览器及页面的高度、宽度信息。 目录\\1. 介绍：介绍页面的容器(屏幕、浏览器及页面)、物理尺寸与分辨率、展示等内容。 \\2. 屏幕信息：介绍屏幕尺寸信息；如：屏幕、软件可用以及任务栏的高度和宽度。 \\3. 浏览器信息：介绍浏览器尺寸信息；如：浏览器、内部页面以及工具栏的高度和宽度。 \\4. 页面信息：介绍HTML页面尺寸信息；如：body总的、展示的高度和宽度。","text":"本篇主要介绍Web环境中屏幕、浏览器及页面的高度、宽度信息。 目录\\1. 介绍：介绍页面的容器(屏幕、浏览器及页面)、物理尺寸与分辨率、展示等内容。 \\2. 屏幕信息：介绍屏幕尺寸信息；如：屏幕、软件可用以及任务栏的高度和宽度。 \\3. 浏览器信息：介绍浏览器尺寸信息；如：浏览器、内部页面以及工具栏的高度和宽度。 \\4. 页面信息：介绍HTML页面尺寸信息；如：body总的、展示的高度和宽度。 一、介绍1. 容器一个页面的展示，从外到内的容器为：屏幕、浏览器以及页面本身。 HTML元素展现在页面内，页面展现在浏览器内，而浏览器展现在屏幕内。 通过Js的一些对象可以获取这些容器的高度、宽度。 2. 物理尺寸和分辨率容器的尺寸是指当前分辨率下的高度、宽度，而不是物理高度、宽度。 如：一个22寸的显示器，屏幕分辨率为1366 * 768，那么获取到的屏幕高度为1366px，宽度为768px。 3. 展示图 二、屏幕信息 screen.height ：屏幕高度。 screen.width ：屏幕宽度。 screen.availHeight ：屏幕可用高度。即屏幕高度减去上下任务栏后的高度，可表示为软件最大化时的高度。 screen.availWidth ：屏幕可用宽度。即屏幕宽度减去左右任务栏后的宽度，可表示为软件最大化时的宽度。 任务栏高/宽度 ：可通过屏幕高/宽度 减去 屏幕可用高/宽度得出。如：任务栏高度 = screen.height - screen.availHeight 。 三、浏览器信息 window.outerHeight ：浏览器高度。 window.outerWidth ：浏览器宽度。 window.innerHeight ：浏览器内页面可用高度；此高度包含了水平滚动条的高度(若存在)。可表示为浏览器当前高度去除浏览器边框、工具条后的高度。 window.innerWidth ：浏览器内页面可用宽度；此宽度包含了垂直滚动条的宽度(若存在)。可表示为浏览器当前宽度去除浏览器边框后的宽度。 工具栏高/宽度 ：包含了地址栏、书签栏、浏览器边框等范围。如：高度，可通过浏览器高度 - 页面可用高度得出，即：window.outerHeight - window.innerHeight。 四、页面信息 body.offsetHeight ：body总高度。 body.offsetWidth ：body总宽度。 body.clientHeight ：body展示的高度；表示body在浏览器内显示的区域高度。 body.clientWidth ：body展示的宽度；表示body在浏览器内显示的区域宽度。 滚动条高度/宽度 ：如高度，可通过浏览器内页面可用高度 - body展示高度得出，即window.innerHeight - body.clientHeight。","categories":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"}]},{"title":"理解SQL","slug":"理解SQL","date":"2019-08-03T16:00:00.000Z","updated":"2020-09-16T09:07:07.000Z","comments":true,"path":"2019/08/04/理解SQL/","link":"","permalink":"http://mariogogogo.github.io/2019/08/04/%E7%90%86%E8%A7%A3SQL/","excerpt":"如何高效的存储和使用这些数据，让页面可以看起来不卡","text":"如何高效的存储和使用这些数据，让页面可以看起来不卡 cookie与localStorage cookie localStorage 限制4k 限制最大5M — — 浏览器 存放在本地文件中 字符串方式存取 webSQL什么是关系型数据库？由一张张二维表组成的数据库 什么是SQL呢？一种操作关系型的DB语言，支持创建表，插入表，修改，删除，查询常见的关系型数据库有：MySQL,SQLite,SQLSever,Oracle 创建一个DB123456var db = window.openDatabase( &quot;order_test&quot;, &lt;----数据库名称 &quot;1.0&quot;, &lt;----版本 &quot;order map data&quot;,&lt;----描述 &quot;2*1024*1024&quot; &lt;----可用空间) 返回一个db对象 创建表1create table if not exists order_data(order_id primary key,format_city,lat,lng,price,create_time) 插入数据1insert into order_data values($&#123;order.orderId&#125;,&#x27;$&#123;order.format_city&#125;&#x27;,$&#123;order.lat&#125;,$&#123;order.lng&#125; ...); 主键唯一约束一般我们认为主键是自动生成的，myslq可以指定某个整数字段为auto_increment;而webSQL不能指定，需要创建指定当前字段为integer1create table student(id integer primary key,age,score) Select查询1select format_city as city,count(order_id) as &#x27;count&#x27;,sum(price) as amount from order_data by format_city order by date 我们也可以查询某个order是否存在，判断满足动态更新的需求 1select order_id from order_data where order_id = $&#123;order.orderId&#125; 建立索引为什么要创建索引？为了提高搜索效率，如果没有建立索引查询某个字段是否等于某个值的数据需要遍历所有的数据，查找复杂度O(N),但是如果建立索引使用二叉查找树或者它的变种，查找复杂度变O(logN),Mysql使用的B+树，另外字符串可以使用哈希变数字，字符串所以要比数字低效很多 关系型数据库的优缺点优点1.支持复杂的查询，可以联表查询，表达式查询，嵌表查询 缺点1.不方便横向扩展，给数据库添加一个字段，如果数据库达到亿级，那么这个操作复杂性就很差了2.海量数据SQL联表查询，性能会非常差3.为了保持事务的一致特性，难以应对高并发 非关系型数据库也叫NoSQL数据库特点： 存储比较灵活，查找没有像关系型数据库那么好用，适用于数据量很大，只需要单表key查询，一致性不很高的场景 IndexedDB为什么要叫IndexedDB或者索引数据库呢？因为它主页通过创建索引惊喜查询 IndexedDB可以支持插入JSON格式的不一样的数据 非关系型数据库的横向扩展因为可以每个数据的类型不一样，所以不存在添加字段的问题，而相同的类型可以创建索引，提高搜索效率；但是也又小问题，NoSql做不了复杂查询，如果要比如按照city/日期归类，那么需要开一个游标循环处理。时间和性能开销很大； 兼容性 数据库与Promise我们都知道数据库是异步操作；如果我们先发一个请求获取数据，然后插入数据，重复N次后，再查询数据。如何保证每次都成功写入数据库呢？ 我们可以使用Promise来解决 123456789101112131415161718192021var promises = []for(let i=0 ; i&lt;orders.length;i++)&#123; var order = orders[i] var promise = new Promise((resolve,reject)=&gt;&#123; dataProcess.executeSql(&#x27;插入sql语句&#x27;,(tx,results)=&gt;&#123; //数据库返回 if(results.rows.length）&#123; resolve() return &#125; //如果不存在，则向服务器继续请求查询 var order = orders[i] dataProcess.queryAdderss(order) &#125;） &#125;) //添加进数组 promise.push(promise)&#125;//所有的Prmise都返回了则调用finished函数Prmise.all(promises).then(dataPromcess.finished) SQL注入攻击比如网页链接存在参数传递，后台并没有对用户的输入进行过滤，导致用户的输入直接被SQL解释器执行。SQL注入的产生条件：输入一段sql片段 最终拼接成一段攻击代码 防御SQL注入归根到底，需要对用户的输入进行过滤，因为在Web攻防中，我们永远不要相信用户的输入 1。1.使用预编译语句，绑定变量。2.使用安全的存储过程对抗SQL注入。3.检查数据类型。4.使用安全函数。 分布式数据库简单介绍下：如果一个网站越来越火🔥，一个数据库服务很可能会扛不住，需要多搞几台服务器缓解压力，这时候需要几个数据库一致性，解决方案很多，最简单的是Mysql的replication； 主要工作原理假如有三台服务器，三个数据库，用户一个操作写到了其中一个主服务器，这个库叫master，其他二个库叫slave，主库会把数据库远程复制到另外二个库。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://mariogogogo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"理解HTTPS连接前几毫米发生了什么","slug":"理解HTTPS连接前几毫秒发生了什么","date":"2019-07-31T16:00:00.000Z","updated":"2020-09-16T09:07:07.000Z","comments":true,"path":"2019/08/01/理解HTTPS连接前几毫秒发生了什么/","link":"","permalink":"http://mariogogogo.github.io/2019/08/01/%E7%90%86%E8%A7%A3HTTPS%E8%BF%9E%E6%8E%A5%E5%89%8D%E5%87%A0%E6%AF%AB%E7%A7%92%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"1.为什么说HTTPS安全，安全在哪里？ 2.HTTPS使用证书保证它的安全吗？ 3.为什么证书需要购买？","text":"1.为什么说HTTPS安全，安全在哪里？ 2.HTTPS使用证书保证它的安全吗？ 3.为什么证书需要购买？ HTTPS解决了什么问题？HTTPS解决了中间人攻击 什么是中间人攻击你和服务器传输数据之间经过了一个中间人，数据都被中间人拦截或者纂改你根本不知道，中间人对你来说是透明的 中间人攻击方法1.域名污染2.ARP欺骗 HTTPS是应对中间人攻击的唯一方法HTTPS连接过程简单描述：HTTPS链接，服务器发送它的证书给浏览器，浏览器确认证书正确，并检查证书中对应的主机名是否正确，如果正确则双方加密数据后发送给对方，对方再进行解密，保证数据是不透明的。 完整连接建立过程客户端1.建立TCP连接2.手机端发送一个hello 给服务端，我们再抓包中观察，将hello里面手机端发给服务端的信息罗列出来：A.使用了TLS版本为1.2 其他版本有1.0 1.1 1.2，HTTPS加密靠TLS安全传输层协议B.手机端当前的时间和一个随机密码串，C.SessionID 第一次连接为0，如果有SessionID则可以恢复会话，而不用重复握手过程。服务端会告知SessionID，再刷新页面的时候，客户端就会把这个SessionID带上D.浏览器支持加密组合方式。浏览器一共支持22种加密组合方式，发送给服务器让服务器选一个E.服务器根据域名发送相应的证书。HTTPS= HTTP + TLS TLS与SSL什么关系？ SSL是TLS的前身 服务端1.时间 随机数等，注意服务器还发送一个SessionID给浏览器2.服务器加密方式，服务器在客户端提供的方式里面选择了某种方式， 证书接着服务器发送一个证书的包过去给手机端，服务器可能发三个包，三个证书是相互依赖证书里面有什么内容：1.签名2.每个证书包含签名的算法3.被签名的证书 证书包括申请证书的国家省份城市组织名称，还有有效期，证书的公钥 证书的公钥是一个16进制的代码；公钥由N 和 e组成 ===&gt; publicKey = (N,e)；其中N是一个大整数，由2个质数相乘得到： N = p * q 使用的技术是RSA又可以叫做非对称加密算法 当我访问HTTP的时候，为什么会自动跳转到HTTPS？ 这是因为后端做的重定向，通过Nginx的rewrite或者return规则做的重定向，返回3开头的状态码让浏览器重定向 RSA与密钥交换是什么关系？ RSA是非对称加密算法，而密钥交换用的是对称加密，在抓包中我们看到它们用的是迪菲-赫尔曼密钥交换，为了让交换不受中间人攻击，双方需要进行身份验证。即RSA对密钥加密。只有拥有正确RSA密钥的一方，才能知道交互的密钥是什么？ TLS是传输层协议吗？一般把TLS归为安全传输层协议 使用HTTPS的代价从最开始的手机端hello ， 到最后的包，总耗时从4.99s到5.299s；这个建立HTPPS的连接过程为0.3s；所以使用HTPPS的代价：1.建立HTTPS的花费时间2.数据需要加密和解密，占更多的CPU3.数据加密后比原信息更大，占用更多的带宽 怎么绕过HTTPS使用ssltrip，这个工具的实现原理是使用ARP欺骗与用户建立链接，然后强制将用户访问的HTTPS替换成HTTP，这样中间人和用户之间使用HTTP，而和服务端还是用HTTPS","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://mariogogogo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"NodeJS中间件原理","slug":"Nodejs中间件原理","date":"2019-07-30T16:00:00.000Z","updated":"2020-09-16T09:07:43.000Z","comments":true,"path":"2019/07/31/Nodejs中间件原理/","link":"","permalink":"http://mariogogogo.github.io/2019/07/31/Nodejs%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/","excerpt":"在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。","text":"在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。 中间件的行为比较类似Java中过滤器的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。它的工作模型下图所示。 分析 实现原理首页设计一个类12345678910111213141516171819202122232425262728const http = require(&quot;http&quot;);const slice = Array.prototype.slice;class LikeExpress &#123; constructor() &#123; this.routes = &#123; all: [], get: [], post: [] &#125;; &#125; register(path) &#123; &#125; use() &#123; &#125; get() &#123; &#125; post() &#123; &#125; //监听 listen(...args) &#123; &#125;&#125;module.exports = () =&gt; &#123; return new LikeExpress();&#125;; 填充register方法1234567891011121314151617181920/*path 路径*/register(path) &#123; let info = &#123;&#125;; if (typeof path === &quot;string&quot;) &#123; info.path = path; info.stack = slice(argument, 1); //数组 &#125; else &#123; info.path = &quot;/&quot;; info.stack = slice(argument, 0); //数组 &#125; return info;&#125;//use方法中调用封装好的registeruse() &#123; const info = this.register.apply(this, arguments); //存入all数组 this.routes.all.push(info);&#125; 添加listen123456//监听 listen(...args) &#123; //添加个回调函数 const server = http.createServer(this.callback()); server.listen(...args); &#125; 添加callback123456789101112131415callback() &#123; return (req, res) =&gt; &#123; res.json = data =&gt; &#123; res.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); res.end(JSON.stringify(data)); &#125;; const url = req.url; const method = req.method.toLowerCase(); //区分匹配的路径 const resultList = this.match(method, url); //核心 this.handle(req, res, resultList); &#125;;&#125; match匹配一个中间件列表符合哪些请求是可以继续执行1234567891011121314151617181920212223match(method, url) &#123; let stack = []; if (url === &quot;/favicon.ico&quot;) &#123; return stack; &#125; // 获取routes let curRouters = []; curRouters = curRouters.concat(this.routes.all); curRouters = curRouters.concat(this.routes[method]); curRouters.forEach(item =&gt; &#123; if (url.indexOf(item.path) === 0) &#123; // url === &quot;/api/user&quot; &amp;&amp; item.path === &quot;/&quot; stack = stack.concat(item.stack); &#125; &#125;); return stack; &#125; 核心方法写next方法1234567891011121314//核心 handle(req, res, resultList) &#123; const next = () =&gt; &#123; //每次执行获取第一个中间件 const middleware = resultList.shift(); if (middleware) &#123; //执行中间件 middleware(req, res, next); &#125; &#125;; //立即执行 next(); &#125; 解析图","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"理解WebSocket与TCP/IP🔥","slug":"理解WebSocket与TCP-IP","date":"2019-07-29T16:00:00.000Z","updated":"2020-09-16T09:07:07.000Z","comments":true,"path":"2019/07/30/理解WebSocket与TCP-IP/","link":"","permalink":"http://mariogogogo.github.io/2019/07/30/%E7%90%86%E8%A7%A3WebSocket%E4%B8%8ETCP-IP/","excerpt":"TCP/IP首先介绍下Mac下抓取端口包的工具角tcpdump命令：1sudo tcpdump port 8080 -n","text":"TCP/IP首先介绍下Mac下抓取端口包的工具角tcpdump命令：1sudo tcpdump port 8080 -n 一个完整的http链接我们先来看下抓到包的数据分析 TCP的三次握手 手机端–&gt;服务器发送了一个tcp包，带上了SYN标志位，表示建立连接，并指名包开始序列号seq（单位字节） 服务器–&gt;手机端进行回复，发送了一个SYN+ACK的报文段，表示同意建立连接 手机端–&gt;服务端发送一个ACK，同时改变接受窗口大小，完成三次握手 TCP的为什么是三次握手？为什么不是二次或者四次呢？ 如果采取两次握手，相当于第二次握手结束便建立连接，如果发送SYN的一方不想连接了，也不会有反馈，另一方却一直在等待，浪费了时间。当然可以采取4次甚至N次握手，但是有必要吗？建立连接的时间太长，效果也会大打折扣。所以3次只是折中方案，保证了可靠性，又节俭了建立连接的时间。 什么是接收窗口呢？tcp报文头，窗口大小只有2个字节16位，最大只能2^16-1 = 64kb大小，当初设计tcp的人没有想到现代网速那么快，所以可选项加了一个wscale指数字段，最大为14，最大窗口大小为1G 接受窗口用来做什么呢？它根据自身网络情况设置不同大小的值用来控制对方发送速度，避免对方发送太快，导致网络拥塞 发送数据建立好tcp之后 手机端–&gt;服务端发送一个http请求，带上PUSH标志位：表示一个比较紧急的报文，告诉服务器立即把数据从缓存里发送给程序，不能再继续缓存了 TCP的四次挥手为什么要挥手四次？前二次挥手让连接处于半关闭状态，此时手机端不可向服务端发送数据，而服务器可以继续向手机端发送数据，所以四次的原因是可以有一个处于半关闭的状态 手机端–&gt;服务端 发送一个FIN，要等30s才能关闭，为什么要等30秒?因为这个是由keep-alive字段影响，同一个域可能要请求多个资源，不能一个请求完了就马上关闭 服务端–&gt;手机端 发送ACK 这个时候连接处于半关闭状态，手机端不能再发送数据给服务端，但服务端可以向手机端发送 服务端–&gt;手机端 把连接关闭了 于是向手机端发送FIN 手机端–&gt;服务端 发送了一个ACK，此时链接完全关闭，手机端关闭了进入TIME_WAIT状态 为什么服务端不用进入TIME_WAIT状态? 因为一个完整的套接字包括四个元素：互联双方的IP+端口号，只要一方被破坏了就不能构成相同的套接字。限制手机端应该比较合理，因为服务端可能还要继续监听那个端口 发送窗口是怎么算的? wscale是一个二进制指数，wscale=5 表示左移5位 === 2的5次幂 四层网络协议 假如要发送一个http文本，最后会被包装成物理帧头 | IP报头文 | TCP报头文 | HTTP报头文 | 文本数据1.物理地址每个网卡都有一个全球唯一的物理地址。路由器向局域网所有主机发送数据，网卡会比较物理地址是否与自己地址一致，如果一致就接受，否则丢弃。 2.网际层ARPARP是一个地址解析协议，当我访问10.2.200.140的时候我需要知道它的物理路径地址，如果是个局域网我就局域网广播一个ARP请求，然后就会告诉我，物理地址 3.网际层traceroute可以追踪路由路径，原理是向目标主机发送ICMP报文，发送第一个报文时，设置TTL=0 报文生存时间为0，下一个路由器收到这个报文后，不会继续转发了，会给原主机发送出错的报文。就可知道第一个路由的ip地址，同里TTL为1 就可以知道第二个路由的IP地址 拥塞控制什么阻塞控制？ 比如我想上传一个文件观察报文的发送情况，在0，7s的时间内 发送1448*9 = 17kb的数据；这个时候网络卡顿了，又会这样呢？在1.45s的时间内，总共发送了9个包===5kb数据 1.接受窗口上传过程中，服务器不断调整它接受的窗口大小2.拥塞窗口我本地有自己的一个拥塞窗口cwnd 当cwmd &gt; rwnd的时候对方接收能力限制了我的发送速度，当rwnd &gt; cwnd的时候，是我的网络情况造成发送比较慢 慢启动与阻塞避免当我们访问一个Linux服务器，服务在收到get请求后进行响应，第一次同时只发3个包，并且从时间间隔上看肯定它是故意的。为什么第一个会是3个呢。因为Linux初始化窗口就是3MSS，说明第一次只能发3个包 HTTP请求头大小限制1.请求头大小限制 Nginx Tomact 4k~8k 8k 2.URL长度限制一个比较安全的值应该是8K，同时注意get请求参数是在URL里数据不能太大。3.Cookie的长度限制一般一个domain的cookie不能超过4kb，50个cookie，不然浏览器可能不会支持。 理解WebSocket怎么实现一个HTTP的web实时聊天？怎么知道对方有没有收到发送消息给我呢？1.使用轮询，每隔2s发一个请求给服务端查询，缺点浪费资源2.使用Service Worker实现浏览器的Push 这种方法要先注册Fcm账号获取一个id，用ServiceWorker监听，服务向 Android.com/send发送消息，谷歌服务器收到消息向那个id发送一个推送，实现了浏览器的push，缺点兼容性不好3.WebSocket建立长连接 代码：1234567var socket = new WebSocket(&quot;ws://192.168.8.88:8080&quot;)socket.open = ()=&gt;&#123; socket.send(&quot;长江长江，我是黄河&quot;)&#125;socket.onmessage = (event)=&gt;&#123; document.title = &quot;收到来自黄河的消息：&quot;+event.data&#125; 谈谈WebSocket和WebRTCWebSocket可以发数据，也可以接收数据，不保证传送的效率和质量。WebRTC可用于可靠的传输音频视频，建立P2P链接，不需要服务端进行转发数据，虚拟电话，在线面试等现在很多用它实现","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://mariogogogo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"NodeJs的MVC模型","slug":"NodeJs的MVC模型","date":"2019-07-25T16:00:00.000Z","updated":"2020-09-16T09:07:41.000Z","comments":true,"path":"2019/07/26/NodeJs的MVC模型/","link":"","permalink":"http://mariogogogo.github.io/2019/07/26/NodeJs%E7%9A%84MVC%E6%A8%A1%E5%9E%8B/","excerpt":"MVC模型主要的思想是将业务逻辑按职能分离 控制器—一组行为的集合 模型 —-数据相关的操作和封装 视图 —-视图的渲染（nodejs的后台虽然不需要视图可以视为接口的输出参数）这是目前最经典的分层模式，工作模式说明 路由解析url寻找对应控制器和行为 行为调用相关的模型，进行数据操作 数据操作结束后，调用视图和相关数据进行页面渲染，输出给客户端","text":"MVC模型主要的思想是将业务逻辑按职能分离 控制器—一组行为的集合 模型 —-数据相关的操作和封装 视图 —-视图的渲染（nodejs的后台虽然不需要视图可以视为接口的输出参数）这是目前最经典的分层模式，工作模式说明 路由解析url寻找对应控制器和行为 行为调用相关的模型，进行数据操作 数据操作结束后，调用视图和相关数据进行页面渲染，输出给客户端 www.js12345678910const http = require(&#x27;http&#x27;)//参数配置层const serverHandle = require(&#x27;./app&#x27;)const PORT = 8080const server = http.createServer(serverHandle)server.listen(PORT,()=&gt;&#123; console.log(&#x27;链接上了&#x27;+PORT);&#125;)app.js 1234567891011121314151617181920212223//根据不同功能分不同路由路径const querystring = require(&quot;querystring&quot;);const handleBlogRouter = require(&quot;./src/router/blog&quot;);const serverHandle = (req, res) =&gt; &#123; //设置返回格式 res.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); const url = req.url; req.path = url.split(&quot;?&quot;)[0]; //如果get解析query req.query = querystring.parse(url.split(&quot;?&quot;)[1]); const blogData = handleBlogRouter(req, res); res.end(JSON.stringify(blogData)); return; &#125; //处理404 res.writeHead(404, &#123; &quot;Content-type&quot;: &quot;text/plain&quot; &#125;); res.write(&quot;404 Not Found\\n&quot;); res.end();module.exports = serverHandle; /router/blog.js路由功能 12345678910111213141516171819202122232425262728293031323334353637const &#123;getList,getDetail,createNewBlog&#125; = require(&#x27;../controller/blog&#x27;)const &#123;SuccessModal,ErrorModal&#125; = require(&#x27;../modal/resModal&#x27;)const handleBlogRouter = (req, res) =&gt; &#123; const method = req.method; //获取博客列表 if (method === &quot;GET&quot; &amp;&amp; req.path === &quot;/api/blog/list&quot;) &#123; const author = req.query.author || &#x27;&#x27; const keyword = req.query.keyword || &#x27;&#x27; const listData = getList(author,keyword) return new SuccessModal(listData) &#125; //获取博客详情 if (method === &quot;GET&quot; &amp;&amp; req.path === &quot;/api/blog/detail&quot;) &#123; return &#123; msg: &quot;获取博客api&quot; &#125;; &#125; //新建一篇博客 if (method === &quot;POST&quot; &amp;&amp; req.path === &quot;/api/blog/new&quot;) &#123; return &#123; msg: &quot;新建博客api&quot; &#125;; &#125; //更新一篇博客 if (method === &quot;POST&quot; &amp;&amp; req.path === &quot;/api/blog/update&quot;) &#123; return &#123; msg: &quot;更新博客api&quot; &#125;; &#125;&#125;;module.exports = handleBlogRouter model层操作 12345678910111213141516171819202122232425262728class BaseModal &#123; constructor(data, message) &#123; if (typeof data === &quot;string&quot;) &#123; this.message = data; data = null message = null &#125; if (data) &#123;this.data = data&#125; if (message) &#123;this.message = message&#125; &#125;&#125;class SuccessModal extends BaseModal &#123; constructor(data, message) &#123; super(data, message); this.errno = 0 &#125;&#125;class ErrorModal extends BaseModal &#123; constructor(data, message) &#123; super(data, message); this.errno = 1 &#125;&#125;module.exports = &#123; SuccessModal, ErrorModal &#125;; controller层操作12345678910111213const getDetail = (id) =&gt;&#123; //返回假数据，以后这里增加数据库操作代码 return &#123; id:1, title:&#x27;标题C&#x27;, content:&#x27;内容C&#x27;, createTime:1564065988099, author:&#x27;周杰伦&#x27; &#125;&#125;module.exports = &#123; getDetail&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"React中使用Mobx","slug":"React中使用Mobx","date":"2019-06-22T16:00:00.000Z","updated":"2020-09-16T09:07:49.000Z","comments":true,"path":"2019/06/23/React中使用Mobx/","link":"","permalink":"http://mariogogogo.github.io/2019/06/23/React%E4%B8%AD%E4%BD%BF%E7%94%A8Mobx/","excerpt":"为什么要使用Mobx 状态管理库的区别:网上某位大牛的 ppt, 链接有机会再补上。此处的自己为库的开发者，别人是指库的使用者，也就是我等码农。","text":"为什么要使用Mobx 状态管理库的区别:网上某位大牛的 ppt, 链接有机会再补上。此处的自己为库的开发者，别人是指库的使用者，也就是我等码农。 MobX恶心自己，成全别人 Redux成全自己，恶心别人 Rxjs恶心自己，也恶心别人 首先安装修饰器创建一个项目12345create-react-app mobx-todo-list //创建项目 yarn add mobx mobx-react //安装 mobx 的相关依赖 npm run eject 安装安装 decorators1npm install --save-dev @babel/plugin-proposal-decorators 修改package.json中的babel配置12345678910111213&quot;babel&quot;: &#123; &quot;presets&quot;: [ &quot;react-app&quot; ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ] ] &#125; 完成后, 就可以使用装饰器语法了. 在React如何使用呢 Provider—-Provider的作用与react-redux提供的Provider组件是相同的 inject —- 用于从Provider提供的state中选取数据作为props传递给目标组件。常用的方式 12@inject(&quot;store1&quot;,&quot;store2&quot;) @observer MyComponent 创建AppStore12345678910111213141516171819202122import &#123; observable, computed, action &#125; from &#x27;mobx&#x27;;class AppStore &#123; @observable todos = []; //todos列表 @observable newtodo = &quot;232&quot;; //新添加的todo @observable selectedRowKeys = []; //选择行的key @observable loading = true; //Table-loading @observable _key = 0; //key @observable total = 0; //数据量 //添加 注意this的执行 必须用剪头函数 @action AddTodo = () =&gt; &#123; this._key += 1; &#125;; //计算长度 接受一个函数 @computed get TodoListCount() &#123; return this._key; &#125;&#125;export default AppStore; 载入index.js12345678910111213141516import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import * as serviceWorker from &#x27;./serviceWorker&#x27;;import AppStore from &#x27;./stores/AppStore&#x27;;import App from &#x27;./components/App&#x27;;// 创建一个store实例const store = new AppStore();ReactDOM.render( &lt;App store=&#123;store&#125; /&gt;, document.getElementById(&#x27;root&#x27;));serviceWorker.unregister(); Mobx在react使用中的优化尽可能使用小组件before12345678910111213141516@observer class PostList extends Component&#123; render() &#123; const &#123;user,todos,homeStore&#125; = this.props return ( &lt;div&gt; &lt;h1&gt;PostList关于系列&lt;/h1&gt; &lt;span&gt;&#123;homeStore.user&#125;&lt;/span&gt; &lt;ul&gt; &#123;todos.map(todo=&gt; (&lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;) )&#125; &lt;/ul&gt; &lt;button onClick=&#123;homeStore.setUser&#125;&gt;更新user&lt;/button&gt; &lt;/div&gt; ); 减少新旧组件的diff对比过程也是消耗性能after123456789101112@observer class PostList extends Component&#123; render() &#123; const &#123;user,todos,homeStore&#125; = this.props return ( &lt;div&gt; &lt;h1&gt;PostList关于系列&lt;/h1&gt; &lt;span&gt;&#123;homeStore.user&#125;&lt;/span&gt; &lt;TodoView todos=&#123;todos&#125;/&gt; &lt;button onClick=&#123;homeStore.setUser&#125;&gt;更新user&lt;/button&gt; &lt;/div&gt; ); 尽可能晚的引用对象属性before12345678910111213@observer class B extends Component&#123; render()&#123; const &#123;name&#125; = this.props; return &lt;div&gt;&#123;name&#125;&lt;/div&gt; &#125;&#125;class A extends Component&#123; render()&#123; const &#123;p&#125; = this.props; return &lt;B name=&#123;p.name&#125;&gt;&lt;/B&gt; &#125;&#125; 组件B渲染的条件必须是组件A重新渲染，然后会让B也渲染.如果p是个可观察的对象，只需重新渲染B组件，不需要渲染A组件after12345678910111213@observer class B extends Component&#123; render()&#123; const &#123;p&#125; = this.props; return &lt;div&gt;&#123;p.name&#125;&lt;/div&gt; &#125;&#125;class A extends Component&#123; render()&#123; const &#123;p&#125; = this.props; return &lt;B p=&#123;p&#125;&gt;&lt;/B&gt; &#125;&#125; 提前绑定函数before1234567@observer class B extends Component&#123; render()&#123; const &#123;p&#125; = this.props; return &lt;div onClick=&#123;alert(&#x27;hi&#x27;)&#125;&gt;&#123;p.name&#125;&lt;/div&gt; &#125;&#125; B中的render每次调用，onclick会生成一个新的函数，导致C的render方法被重新调用，无论其他属性发生变化after12345678910@observer class B extends Component&#123; handleClick=()=&gt;&#123; alert(&#x27;hi&#x27;) &#125; render()&#123; const &#123;p&#125; = this.props; return &lt;C onClick=&#123;this.handleClick&#125;&gt;&#123;p.name&#125;&lt;/C&gt; &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"『由浅入深 Webpack 系列』性能优化","slug":"『由浅入深Webpack系列』性能优化","date":"2019-06-07T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/06/08/『由浅入深Webpack系列』性能优化/","link":"","permalink":"http://mariogogogo.github.io/2019/06/08/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"跟上速度的迭代当 webpack 升级优化，相关 node yarn npm 包应该也需要升级已获得更好的优化性能","text":"跟上速度的迭代当 webpack 升级优化，相关 node yarn npm 包应该也需要升级已获得更好的优化性能 减少 loader1234567module: &#123; rules: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, // include: path.reslove(__dirname,&#x27;../src&#x27;), //指定编译的文件路径 loader: &#x27;babel-loader&#x27;, &#125; exclude：排除文件夹内文件使用babel-load，避免再次编译打包，加快打包速度或者可以用include参数 上面jsx?表示的是如果 js 文件可以走babel-load，如果是 jsx 文件也可以走babel-load文件 css 文件压缩 123optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)]&#125;, 插件的选择尽量使用官方认可的插件 reslove 合理的配置文件后缀的简写配置12import app from &quot;./src/app.js&quot;;import style from &quot;./src/style.css&quot;; 如果不写后缀会报错，如何用 webpack 配置呢？ 12345678module.exports=&#123; ... resolve:&#123; extensions:[&#x27;.js&#x27;,&#x27;.jsx&#x27;] &#125;, ...&#125; 这样 webpack 就会去找 js 文件是否存在，不存在？ 则去找 jsx 文件是否存在,但是 extensions 不建议存很多后缀名,影响性能，建议资源类文件还是代后缀。 简写路径名一如果我们每次这样写路径是不是很繁琐？ 1import list from &#x27;../src/common/listwarpper/list/item.jsx&#x27; webpack 如何优化呢？增加mainFiles参数 123456789module.exports=&#123; ... resolve:&#123; extensions:[&#x27;.js&#x27;,&#x27;.jsx&#x27;], mainFiles:[&#x27;common&#x27;,&#x27;image&#x27;] &#125;, ...&#125; mainFiles表示 webpack 去根据数组长度去查找对应文件夹是否存在，所以我们存放的文件夹数组长度不可以太长，影响性能 简写路径名二12345678910module.exports=&#123; ... resolve:&#123; extensions:[&#x27;.js&#x27;,&#x27;.jsx&#x27;], alias:&#123; //别名的意思 listwarpper:path.resolve(__dirname,&#x27;../src/common/listwarpper&#x27;) &#125; &#125;, ...&#125; 当 webpack 看到 listwarpper 的路径名就表示去查找../src/common/listwarpper; 使用 DllPlugin 提高打包速度我们知道项目会引入越来越的第三方模块，打包速度会越来越慢，每一次重新打包重新分析 loader，plugin。 123import React, &#123; Component &#125; from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;import _ from &quot;lodash&quot;; 打包时间会比较多 可不可以单独打包生成一个文件，只在第一次打包的时候分析这些代码，后面打包就不需要分析了？ 我们得先创建一个[name].dll.js文件 12345678910111213141516const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);module.exports = &#123; mode: &quot;production&quot;, entry: &#123; vendors: [&quot;lodash&quot;], //需要使用得第三方模块分别写在这里 react: [&quot;react&quot;, &quot;react-dom&quot;], jquery: [&quot;jquery&quot;] &#125;, output: &#123; filename: &quot;[name].dll.js&quot;, path: path.resolve(__dirname, &quot;../dll&quot;), library: &quot;[name]&quot; //全局变量 暴露出去 &#125;&#125;; 然后在 webpack.json 继续配置 AddAssetHtmlWebpackPlugin是一个非常好用 12345678910111213141516171819const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;);const files = fs.readdirSync(path.resolve(__dirname, &quot;../dll&quot;));files.forEach(file =&gt; &#123; if (/.*\\.dll.js/.test(file)) &#123; plugins.push( new AddAssetHtmlWebpackPlugin(&#123; filepath: path.resolve(__dirname, &quot;../dll&quot;, file) &#125;) ); &#125; if (/.*\\.manifest.json/.test(file)) &#123; plugins.push( new webpack.DllReferencePlugin(&#123; manifest: path.resolve(__dirname, &quot;../dll&quot;, file) &#125;) ); &#125;&#125;); 然后配置 plugins,让第三方模块去做一个映射,把库文件去做分析中得分析模块映射关系结果放在 json 文件中。 123456plugins: [ ...new webpack.DllPlugin(&#123; name: &quot;[name]&quot;, path: path.resolve(__dirname, &quot;../dll/[name].manifest.json&quot;) &#125;)]; 然后我们yarn run build-dll一下会发生生成很多文件 控制包得大小剔除无用插件我们项目中经常会引用一些第三方包，可是我们版本迭代又不去用了，然后忘记删除。继续打包包得体积会把多余得包打包进去，是多余得。 合理使用 sourceMap1234const prodConfig = &#123; mode: &quot;production&quot;, devtool: &quot;cheap-module-source-map&quot;&#125;;","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深 Webpack 系列』用 HMR 提高效率","slug":"『由浅入深Webpack系列』用 HMR 提高效率","date":"2019-06-06T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/06/07/『由浅入深Webpack系列』用 HMR 提高效率/","link":"","permalink":"http://mariogogogo.github.io/2019/06/07/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8F%E7%94%A8%20HMR%20%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/","excerpt":"HMR 全称是 Hot Module Replacement，即模块热替换。不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，HMR 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率。","text":"HMR 全称是 Hot Module Replacement，即模块热替换。不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，HMR 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率。 基础配置123plugins: [ new webpack.HotModuleReplacementPlugin() ], 添加其他 HotModuleReplacementPlugin 插件配合执行 12345678910111213const webpack = require(&quot;webpack&quot;);module.exports = &#123; // ... devServer: &#123; hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启 &#125;, plugins: [ // ... new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径 new webpack.HotModuleReplacementPlugin() // Hot Module Replacement 的插件 ]&#125;; 举个栗子webpack 如何保证 HMR 接口中的引用是最新的模块代码？ 1234567891011import &quot;./index.css&quot;;import hello from &quot;./bar&quot;;hello();if (module.hot) &#123; module.hot.accept(&quot;./bar&quot;, () =&gt; &#123; // console.log(&#x27;Accepting the updated bar module!&#x27;) hello(); &#125;);&#125; 如果 bar 文件发生变化，就会执行后面得回调函数重新执行 hello","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深 Webpack 系列』JS 或 CSS 文件代码分割","slug":"『由浅入深Webpack系列』CSS文件代码分割","date":"2019-06-05T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/06/06/『由浅入深Webpack系列』CSS文件代码分割/","link":"","permalink":"http://mariogogogo.github.io/2019/06/06/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8FCSS%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/","excerpt":"为什么要分离先简单解释一下要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。","text":"为什么要分离先简单解释一下要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。 假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。 还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观。 js 代码分割12345678module.exports = &#123; // ... optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot; // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件 &#125; &#125;&#125;; 拆分文件得目的是为了更好地利用缓存,分离公共类库很大程度上是为了让多页面利用缓存，从而减少下载的代码量，同时，也有代码变更时可以利用缓存减少下载代码量的好处 基础配置可以使用MiniCssExtractPlugin,让 css 代码分割 123456plugins: [ new MiniCssExtractPlugin(&#123; filename: &quot;[name].css&quot;, chunkFilename: &quot;[name].chunk.css&quot; &#125;)]; 这个插件目前还有一个问题不支持 HMR，就是热更新，所以当我们改变本地 css 无法立即查看效果，所以建议只在线上环境用这个插件 常用配置我们在 webpack.pro.js 中配置 1234567891011121314151617181920212223242526272829module: &#123; rules:[&#123; test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;, &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &#x27;[name].css&#x27;, chunkFilename: &#x27;[name].chunk.css&#x27; &#125;) ] filename表示如果页面需要直接应用的文件则直接生成 xxx.css 如果是某个组件的 css 样式，不是主文件 css 那么它就会编译成xxx.chunk.css","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深Webpack系列』webpackDevServer提升效率","slug":"『由浅入深Webpack系列』webpackDevServer提升效率","date":"2019-06-04T16:00:00.000Z","updated":"2020-09-16T09:06:52.000Z","comments":true,"path":"2019/06/05/『由浅入深Webpack系列』webpackDevServer提升效率/","link":"","permalink":"http://mariogogogo.github.io/2019/06/05/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8FwebpackDevServer%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/","excerpt":"默认情况下开启了服务器后，只要入口文件有更新那整个页面就会重新刷新。如果页面里引入的模块非常多的情况下让整个页面刷新就会变得有些慢，这个问题可以交给热更新去解决。热更新的意思就是只更新有改动的模块（像ajax一样局部刷新），如果我们需要自动打开浏览器，并实时刷新代码我们需要devserver","text":"默认情况下开启了服务器后，只要入口文件有更新那整个页面就会重新刷新。如果页面里引入的模块非常多的情况下让整个页面刷新就会变得有些慢，这个问题可以交给热更新去解决。热更新的意思就是只更新有改动的模块（像ajax一样局部刷新），如果我们需要自动打开浏览器，并实时刷新代码我们需要devserver 123456devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true, port: 8080, hot: true&#125;, 参数 说明 contentBase 静态文件路径 open 是否自动打开浏览器 端口号 自定义，默认8080 hot 热更新 跨域请求12345678910devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true, port: 8080, hot: true, proxy:&#123; &#x27;/api&#x27;:&#x27;http://localhost:3000&#x27; &#125;&#125;, 参数 说明 contentBase 静态文件容器 open 是否打开浏览器 port 端口 hot 是否要打开热更新 proxy 请求代理 重写api如果服务端，处理的api不是以/api开头的方式进行处理，需要在webpack的proxy重写请求api 12345678devServer:&#123; proxy:&#123; &#x27;/api&#x27;:&#123; target:&#x27;http://localhost:9000&#x27;, pathRewrite:&#123;&#x27;/api&#x27;:&#x27;&#x27;&#125; &#125; &#125;&#125;, 参数 说明 target 为请求域 pathRewrite 将开发模块中的以/api请求的接口，去掉/api进行代理请求 引入Mock数据123456789101112131415161718192021222324252627282930// 引入mock.jsconst Mock = require(&#x27;./mock.js&#x27;);module.exports = &#123; devServer: &#123; port: 8080, host: &#x27;0.0.0.0&#x27;, headers: &#123; &#x27;X-foo&#x27;: &#x27;112233&#x27; &#125;, inline: true, overlay: true, stats: &#x27;errors-only&#x27;, before: function(app) &#123; console.log(app); //该函数会判断当前的环境是否是mock命令 if (process.env.NODE_ENV === &#x27;mock&#x27;) &#123; Mock(app); &#125; &#125; &#125;, plugins: [ // 设置环境变量信息 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(process.env.NODE_ENV) &#125; &#125;) ]&#125; 引入mock.js12345678910111213141516171819202122232425const getPower = require(&#x27;./json/parent_getPower.json&#x27;);const reConfig = require(&#x27;./json/parent_reConfig.json&#x27;);const reConList = require(&#x27;./json/parent_reconlist.json&#x27;);const reGroup = require(&#x27;./json/parent_reGroup.json&#x27;);function Mock(app) &#123; app.get(&#x27;/xxxx/yyy&#x27;, function(req, res) &#123; console.log(&#x27;getPower111&#x27;); res.json(getPower); &#125;); app.post(&#x27;/reconfig&#x27;, function(req, res) &#123; console.log(&#x27;reConfig111&#x27;); res.json(reConfig); &#125;); app.post(&#x27;/conlist&#x27;, function(req, res) &#123; console.log(&#x27;reConList111&#x27;); res.json(reConList); &#125;); app.post(&#x27;/regroup&#x27;, function(req, res) &#123; console.log(&#x27;reGroup111&#x27;); res.json(reGroup); &#125;);&#125;module.exports = Mock;","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深 Webpack 系列』SourceMap 的配置","slug":"『由浅入深Webpack系列』SourceMap的配置","date":"2019-06-03T16:00:00.000Z","updated":"2020-09-16T09:06:52.000Z","comments":true,"path":"2019/06/04/『由浅入深Webpack系列』SourceMap的配置/","link":"","permalink":"http://mariogogogo.github.io/2019/06/04/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8FSourceMap%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"什么是 SourceMap当我们发现打包后程序出现错误时候会一般用 chromse","text":"什么是 SourceMap当我们发现打包后程序出现错误时候会一般用 chromse 当点击之后代码中发现是 96 行，这个 main.js 是打包的 我希望是我打包前那个文件的那一行错误了。我们如何让 webpack 做到呢？ 我们要用 sourceMap 它是一个映射关系，它知道 dist 目录下 main.js96 行就是 src 中 index.js 文件中第一行 加入配置12345678910111213const prodConfig = &#123; mode: &#x27;production&#x27;, devtool: &#x27;source-map&#x27;,&#125;如果我们只想知道行 不需要告诉我第几列const prodConfig = &#123; mode: &#x27;production&#x27;, devtool: &#x27;cheap-module-source-map&#x27;,&#125; 参数 说明 cheap-module-source-map 只显示行数（提高性能） 笔者推荐 参数 说明 dev 模式 cheap-module-eval-source-map production devtool 不需要配置默认即刻或者(cheap-module-source-map) 作用解决了如果打包出错，快速定位错误提高效率","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深Webpack系列』plugins实践","slug":"『由浅入深Webpack系列』plugins实践","date":"2019-06-02T16:00:00.000Z","updated":"2020-09-16T09:06:52.000Z","comments":true,"path":"2019/06/03/『由浅入深Webpack系列』plugins实践/","link":"","permalink":"http://mariogogogo.github.io/2019/06/03/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8Fplugins%E5%AE%9E%E8%B7%B5/","excerpt":"我们可以把plugin 用于处理更多其他的一些构建任务让打包更加便捷，也可以叫做webpack的插件，例如：要使用压缩 JS 代码","text":"我们可以把plugin 用于处理更多其他的一些构建任务让打包更加便捷，也可以叫做webpack的插件，例如：要使用压缩 JS 代码 之前我们没有配置前我们要手动输入html页面到dist目录然后用chrome运行 我们考虑如何让html自动生成到dist目录下呢？ 安装1yarn add html-webpack-plugin clean-webpack-plugin 它的作用打包结束后自动生成html文件，并把js自动引入到html文件； 123456789101112131415161718192021const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &#123; main: &quot;./src/index.js&quot; &#125;, output: &#123; filename: &quot;[name].js&quot;, path: path.resolve(__dirname, &quot;../dist&quot;) &#125;, module: &#123; rules: [...] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;src/index.html&quot; &#125;) ]&#125;; header 1 header 2 template 参考src目录下html模板生成 如果我们要每次build前清除dist目录那我们还可以 1234567891011const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);...plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;src/index.html&quot; &#125;), new CleanWebpackPlugin([&quot;dist&quot;], &#123; root: path.resolve(__dirname, &quot;../&quot;) &#125;) ]","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深Webpack系列』loader实践","slug":"『由浅入深Webpack系列』loader实践","date":"2019-06-01T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/06/02/『由浅入深Webpack系列』loader实践/","link":"","permalink":"http://mariogogogo.github.io/2019/06/02/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8Floader%E5%AE%9E%E8%B7%B5/","excerpt":"Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。","text":"Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 如果我们之前的项目中加入了jpg文件12345678import avatar from &#x27;./avatar.jpg&#x27;;var img = new Image();img.src = avatar;var root = document.getElementById(&#x27;root&#x27;);root.append(img);然后使用yarn run build会发生什么呢？ 编译失败告诉我们不能识别jpg图片； 所以我们就需要使用上loader了，我们可以把 loader 理解为是一个解析器，负责把某种文件格式的内容(jsx vue css es6…)转换成 webpack 可以支持打包的模块。 当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 module.rules 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件 首先安装1npm install file-loader style-loader 基础配置12345678910111213141516171819module: &#123; // ... rules: [ &#123; test: /\\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, &#x27;src&#x27;) // 指定哪些路径下的文件需要经过 loader 处理 ], use: &#x27;babel-loader&#x27;, // 指定使用的 loader &#125;, &#123; test: /\\.jpg$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125; ],&#125; 参数 说明 rules 规则（数组） test 表示文件后缀（正则） include 包含（数组）指定哪些路径下才处理 use 指定用什么loader解析器（可以数组） 现在打包就没有问题了 loader进阶jpg less处理123456789101112131415161718192021222324252627282930313233343536373839404142module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, //排除某个文件 loader: &#x27;babel-loader&#x27;, &#125;, &#123; test: /\\.(jpg|png|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name]_[hash].[ext]&#x27;, outputPath: &#x27;images/&#x27;, limit: 10240 &#125; &#125; &#125;, &#123; test: /\\.(eot|ttf|svg)$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;, &#123; test: /\\.less$/, use: [ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#x27;less-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;, &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;]&#125;, 参数 说明 exclude 排除某个文件 importLoaders 如果多层嵌套引入less或sass文件 1234567//如果index.js中import less from &#x27;index.less&#x27;;//index.lessimport aa from &#x27;a.less&#x27;其他样式 在import引入的less文件，在引入之前也重新走postcss和less-loader 样式冲突当甲和乙都开发同一个项目，难免会碰到类似组件起同一个名字的情况，比如列表组件：listWarpper,这样打包后会有样式冲突的问题。那么webpack如何解决呢？ 12345678910111213141516&#123; test: /\\.scss$/, use: [ &quot;style-loader&quot;, &#123; loader: &quot;css-loader&quot;, options: &#123; importLoaders: 2, modules:true //开启css的模块化打包 &#125; &#125;, &quot;sass-loader&quot;, &quot;postcss-loader&quot; ] &#125; 当avatar用style.avatar来代替后，冲突就不会发生了","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"『由浅入深Webpack系列』概念和基础使用","slug":"『由浅入深Webpack系列』概念和基础使用","date":"2019-05-31T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/06/01/『由浅入深Webpack系列』概念和基础使用/","link":"","permalink":"http://mariogogogo.github.io/2019/06/01/%E3%80%8E%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Webpack%E7%B3%BB%E5%88%97%E3%80%8F%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"之前的对于Webpack知识都很零散希望做一个系列梳理巩固下知识框架，废话不多说，开始吧","text":"之前的对于Webpack知识都很零散希望做一个系列梳理巩固下知识框架，废话不多说，开始吧 webpack是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 安装和使用1234567npm install webpack webpack-cli -g # 或者yarn global add webpack webpack-cli# 然后就可以全局执行命令了webpack --help 确保你的项目中有 package.json 文件，如果没有可以使用 yarn init -y 来创建。 12345678910111213141516//package.json&#123; &quot;name&quot;: &quot;learncodewebpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &#125;, &quot;dependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.34.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack-cli&quot;: &quot;^3.3.4&quot; &#125;&#125; 然后我们写个最简单的webpack.config.js配置文件 1234567891011const path = require(&#x27;path&#x27;);module.exports = &#123; entry:&quot;./src/index.js&quot;, output:&#123; filename:&quot;bundle.js&quot;, path:path.resolve(__dirname,&#x27;dist&#x27;) &#125; &#125; 说明下： 参数 说明 entry 入口文件路径 output Object(打包后的文件名，打包后的路径) 之后执行 npm run build 或者 yarn build 命令，你就会发现新增了一个 dist 目录，里边存放的是 webpack 构建好的bundle.js 文件。 我们还可以继续增加参数1234module.exports = &#123; mode:&quot;development&quot;, //开发者模式 不会压缩js 默认是production entry: &#x27;./src/index.js&#x27; &#125; 增加多个入口文件1234567module.exports = &#123; entry: &#123; foo: &#x27;./src/page-foo.js&#x27;, bar: &#x27;./src/page-bar.js&#x27;, // ... &#125;&#125; 使用数组来对多个文件进行打包12345678910//可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包module.exports = &#123; entry: &#123; main: [ &#x27;./src/foo.js&#x27;, &#x27;./src/bar.js&#x27; ] &#125;&#125; Entry与Output的进阶 我们有需求打包出来的文件需要自定义 我们有需求打包出来多个文件main2.js,main2.js 1234567891011entry:&#123; main:&#x27;./src/index.js&#x27;, sub:&#x27;./src/index.js&#x27;&#125;output: &#123; publicPath：&quot;https://cdn.xxx.com&quot; filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[name].chunk.js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;) &#125; 参数 说明 publicPath 这个是cdn挂载的域名可以负载均衡 filename [name]所对应的就是entry[key]值 chunkFilename 同上","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"如何在ReactHooks中请求数据","slug":"ReactHooks中请求数据","date":"2019-05-28T16:00:00.000Z","updated":"2020-09-16T09:07:49.000Z","comments":true,"path":"2019/05/29/ReactHooks中请求数据/","link":"","permalink":"http://mariogogogo.github.io/2019/05/29/ReactHooks%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/","excerpt":"一起学习ReactHooks","text":"一起学习ReactHooks 先说下错误使用123456789101112131415161718192021222324252627282930import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;function App() &#123; //初始化data 和setData方法 const [data,setData] = useState(&#123;hits:[]&#125;); useEffect(()=&gt;&#123; async function axiosData() &#123; const response = await axios(&#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;); console.log(&#x27;执行次数&#x27;+response.data) //改变数据 setData(response.data) // data：&#123;hits:[xxxx]&#125; &#125; axiosData() &#125;,[]) return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; 但这样会有问题，请求次数循环 因为effect hook不仅在组件挂载是执行，在组件更新过程中也会执行。因为我们在每一次的数据获取后都会重新设置状态，这时候组件update然后effect hook就会重新运行一遍，这就造成了数据一次又一次的获取 我们只想在组件挂载阶段时获取数据。这就是你要给effect hook的第二个参数传入一个空数组的原因，这样做可以避免组件更新阶段执行 effect hook ，但是依然会在挂载阶段执行它 1234567891011121314function App() &#123; //初始化data 和setData方法 const [data,setData] = useState(&#123;hits:[]&#125;); useEffect(()=&gt;&#123; async function axiosData() &#123; const response = await axios(&#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;); console.log(&#x27;执行次数&#x27;+response.data) //改变数据 setData(response.data) // data：&#123;hits:[xxxx]&#125; &#125; axiosData() &#125;,[]) 但还是存在一个问题：第二个参数用来定义hooks所依赖的全部变量（存放在数组中），如果一个变量改变了，effect hook就会被执行一次，如果是一个空数组的话，hooks将不会在组件更新的时候执行，因为它没有监听到任何的变量。 如何自动触发一个 hook？我们在组件挂载后获取了一次数据。但是如何使用输入字段告诉API我们感兴趣的主题？“Redux”做为默认查询。但是如果想要查询关于“React”的呢？让我们实现一个input元素，可以获得“Redux”之外的话题。因此，就要为input元素引入一个新的state。 二步操作：1.输入框输入的值动态改变传入axios请求中2.当你在input中输入一些内容时，在挂载后就不会再获取任何数据了，因为我们提供了[]作为第二个参数，但是现在的effect应该依赖query，每当query改变的时候，就应该重新获取数据。 1234567891011121314151617181920212223function App() &#123; //初始化data 和setData方法 const [data,setData] = useState(&#123;hits:[]&#125;); const [query, setQuery] = useState(&#x27;redux&#x27;); useEffect(()=&gt;&#123; async function axiosData() &#123; console.log(query) const response = await axios(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`); console.log(&#x27;执行次数&#x27;+response.data) setData(response.data) // data：&#123;hits:[xxxx]&#125; &#125; axiosData() //改变数据 &#125;,[query]) //html &lt;input type=&quot;text&quot; value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; 如何手动触发请求？现在input的值改变就会重新获取数据。但是又出现另外一个问题：每次输入一个新字符，就会触发 effect 进行一次新的请求。那么我们如何提供一个按钮来手动触发数据请求呢？ 12345678910111213141516171819202122function App() &#123; //初始化data 和setData方法 const [data,setData] = useState(&#123;hits:[]&#125;); const [query, setQuery] = useState(&#x27;redux&#x27;); const [search, setSearch] = useState(&#x27;&#x27;); useEffect(()=&gt;&#123; async function axiosData() &#123; const response = await axios(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`); console.log(&#x27;执行次数&#x27;+response.data) setData(response.data) // data：&#123;hits:[xxxx]&#125; &#125; axiosData() console.log(&#x27;search&#x27;,search) //改变数据 &#125;,[search]) //html &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setSearch(query)&#125;&gt; Search &lt;/button&gt; React Hooks中的loading一旦调用了effect获取了数据，（在组件挂载阶段或URL状态更改时发生），则加载状态设置为true。请求完成后，加载状态再次设置为false。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Fragment, useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(&#x27;redux&#x27;); const [url, setUrl] = useState( &#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;, ); const [isLoading, setIsLoading] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; //loading显示 setIsLoading(true); const result = await axios(url); setData(result.data); //loadding隐藏 setIsLoading(false); &#125;; fetchData(); &#125;, [url]); return ( &lt;Fragment&gt; &lt;input type=&quot;text&quot; value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`) &#125; &gt; Search &lt;/button&gt; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; React Hooks中的错误处理使用async/await时，通常使用try/catch块进行错误处理。你可以在effect内做到123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(&#x27;redux&#x27;); const [url, setUrl] = useState( &#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;, ); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; setIsError(false); setIsLoading(true); try &#123; const result = await axios(url); setData(result.data); &#125; catch (error) &#123; setIsError(true); &#125; setIsLoading(false); &#125;; fetchData(); &#125;, [url]); return ( &lt;Fragment&gt; &lt;input type=&quot;text&quot; value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v2/search?query=$&#123;query&#125;`) &#125; &gt; Search &lt;/button&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; 自定义 hook 获取数据我们可以定义一个自定义的hook，提取出所有与数据请求相关的东西，除了输入框的 query state，以及 Loading 状态、错误处理。还要确保返回组件中需要用到的变量。 理想代码12345678910function App() &#123; const [query, setQuery] = useState(&#x27;redux&#x27;); const &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi(); return ( &lt;Fragment&gt; ... &lt;/Fragment&gt; );&#125;封装useHackerNewsApi 1234567891011121314151617181920212223242526272829303132333435const userHackerNewsApi = ()=&gt;&#123; //初始化状态 const [data, setData] = useState(&#123; hits: [] &#125;); const [url, setUrl] = useState( &#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;, ); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(()=&gt;&#123; const fetchData = async ()=&gt;&#123; setIsError(false); setIsLoading(true); try &#123; const result = await axios(url); setData(result.data); &#125; catch (error) &#123; setIsError(true); &#125; setIsLoading(false); &#125;; //调用请求 fetchData() &#125;,[url]) const doFetch = (url)=&gt;&#123; setUrl(url) &#125; return &#123;data,isLoading,isError,doFetch&#125;&#125; 关于数据获取的 Reducer Hook让我们用reduce把一些状态调用连接起来使用 Reducer Hook 返回一个 state 对象和一个函数（用来改变 state 对象）。这个函数被称为分发函数（dispatch function），它分发一个 action，action 具有 type 和 payload 两个属性。所有的这些信息都在 reducer 函数中被接收，根据之前的状态提取一个新的状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344function App() &#123; const [query, setQuery] = useState(&#x27;redux&#x27;); const [&#123; data, isLoading, isError &#125;, doFetch] = useDataApi( `http://hn.algolia.com/api/v1/search?query=redux`, &#123; hits: [] &#125;, ); return ( &lt;Fragment&gt; &lt;form onSubmit=&#123;event =&gt; &#123; doFetch( `http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`, ); event.preventDefault(); &#125;&#125; &gt; &lt;input type=&quot;text&quot; value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; 如何设计useDataApi现在，在获取数据时，可以使用 dispatch 函数向 reducer 函数发送信息。使用 dispatch 函数发送的对象具有一个必填的 type 属性和一个可选的 payload 属性。type 属性告诉 reducer 函数需要转换的 state 是哪个，还可以从 payload 中提取新的 state。在这里只有三个状态转换：初始化数据过程，通知数据请求成功的结果，以及通知数据请求失败的结果。123456789101112131415161718192021222324252627const useDataApi = (initialUrl,initialData)=&gt;&#123; const [url,setUrl] = useState(initialUrl); const [state,dispatch] = useReducer(dataFetchReducer,&#123; isLoading:false, isError:false, data:initialData, &#125;) useEffect(()=&gt;&#123; const fetchData = async ()=&gt;&#123; dispatch(&#123;type:&quot;FETCH_INIT&quot;&#125;) try&#123; const result = await axios(url); dispatch(&#123;type:&quot;FETCH_SUCCESS&quot;,payload:result.data&#125;) &#125;catch (e) &#123; dispatch(&#123;type:&quot;FETCH_FAILURE&quot;,payload:e&#125;) &#125; &#125; fetchData(); &#125;,[url]) //只返回state中包含data isloading / setUrl return [state, setUrl];&#125; reducer函数的实现它需要处理三个不同的状态转换，称为FETCH_INIT，FETCH_SUCCESS和FETCH_FAILURE。每个状态转换都需要返回一个新的状态对象123456789101112131415161718192021const dataFetchReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case &#x27;FETCH_INIT&#x27;: return &#123; ...state, isLoading: true, isError: false &#125;; case &#x27;FETCH_SUCCESS&#x27;: return &#123; ...state, isLoading: false, isError: false, data: action.payload, &#125;; case &#x27;FETCH_FAILURE&#x27;: return &#123; ...state, isLoading: false, isError: true, &#125;; default: throw new Error(); &#125;&#125;; 在 Hook 中中断数据请求下次再更新12345``````javascript 参考Robin Wieruch","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列Fiber","slug":"React源码系列Fiber","date":"2019-05-02T16:00:00.000Z","updated":"2020-09-16T09:07:49.000Z","comments":true,"path":"2019/05/03/React源码系列Fiber/","link":"","permalink":"http://mariogogogo.github.io/2019/05/03/React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97Fiber/","excerpt":"什么是fiber所谓fiber，它其实是一个react中的架构，一个 fiber 对象代表了一个work单位，每一个ReactElement都会对应一个Fiber对象记录各个节点的状态 （props state）通过fiber 让节点获取属性值串联整个应用的树结构","text":"什么是fiber所谓fiber，它其实是一个react中的架构，一个 fiber 对象代表了一个work单位，每一个ReactElement都会对应一个Fiber对象记录各个节点的状态 （props state）通过fiber 让节点获取属性值串联整个应用的树结构 最近更新2019年6月14日 与15的变化从15到16，源码结构发生了很大变化：再也看不到mountComponent/updateComponent()了，被拆分重组成了（beginWork/completeWork/commitWork()）ReactDOMComponent也被去掉了，在Fiber体系下DOM节点抽象用ReactDOMFiberComponent表示，组件用ReactFiberClassComponent表示，之前是ReactCompositeComponent Fiber体系的核心机制是负责任务调度的ReactFiberScheduler，相当于之前的ReactReconciler vDOM tree变成fiber tree了，以前是自上而下的简单树结构，现在是基于单链表的树结构，维护的节点关系更多一些 特点优化渲染任务，让一个大组件细化，从同步变成异步，让渲染任务有了优先级。生命周期函数调用不再是同步的，让用户能感知的性能提高了。fiber可以把很大的工作分成一个个小块（trunk），trunk之间是异步的，每个trunk之间可以执行别的操作。以render函数为界，分为两个阶段，在render之前改变 workInProgress tree，执行生命周期函数比如componentWillMount，componentWillReceiveProp。在render函数之后，执行componentDidMount， componentDidUpdate。在第一个阶段，可能被中断。 fiber tree来张图感受一下 参考：完全理解React Fiber","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列_ReactDom.render || hydrate","slug":" React源码系列_ReactDom.render || hydrate","date":"2019-04-26T16:00:00.000Z","updated":"2019-05-09T14:58:06.000Z","comments":true,"path":"2019/04/27/ React源码系列_ReactDom.render || hydrate/","link":"","permalink":"http://mariogogogo.github.io/2019/04/27/%20React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97_ReactDom.render%20||%20hydrate/","excerpt":"这一章重点分析创建及更新的过程；","text":"这一章重点分析创建及更新的过程；react更新的方法ReactDom.render 客户端hydrate 初次渲染 服务端setState 用于设置状态对象forceUpdate 强制更新replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。（将在下一个大版本中废除） 创建redner对象12345678910111213141516ReactDOM = &#123; render( element: React$Element&lt;any&gt;,//节点元素 react.createElement后返回的对象 container: DOMContainer, //container就是我们需要渲染到的元素 callback: ?Function,//回调 ) &#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ) &#125;,&#125; 调用方法legacyRenderSubtreeIntoContainer参数 ： parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function, 其中第一次加载 root == null;1let root: Root = (container._reactRootContainer: any);接着看123456789101112131415161718192021222324252627282930313233343536function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function,) &#123; // 创建了root对象 let root: Root = (container._reactRootContainer: any) if (!root) &#123; // 初始化挂载 root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ) //判断是否有callback if (typeof callback === &#x27;function&#x27;) &#123; const originalCallback = callback callback = function() &#123; const instance = DOMRenderer.getPublicRootInstance(root._internalRoot) originalCallback.call(instance) &#125; &#125; // 批量更新操作 DOMRenderer.unbatchedUpdates(() =&gt; &#123; if (parentComponent != null) &#123; // 一般不会出现 &#125; else &#123; root.render(children, callback) &#125; &#125;) &#125; else &#123; // 有root的情况 &#125; return DOMRenderer.getPublicRootInstance(root._internalRoot)&#125; legacyCreateRootFromDOMContainerrender与hydrate的区别在于返回第四个参数true和false。是否会调和原来存在于container里面的html节点，是否要复用这些节点，hydrate基本用于服务端渲染因为服务端第一次渲染和客户端第一次渲染节点结构应该是一致的如果可以复用就可以节省一定的性能123456789101112131415161718192021222324252627hydrate( element: React$Node, container: DOMContainer, callback: ?Function) &#123; // TODO: throw or warn if we couldn&#x27;t hydrate? return legacyRenderSubtreeIntoContainer( null, element, container, true, callback, ); &#125;, render( element: React$Element&lt;any&gt;, container: DOMContainer, callback: ?Function, ) &#123; return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, ); &#125;,shouldHydrateDueToLegacyHeuristicgetReactRootElementInContainer 方法里判断我们的节点下有没有子节点，如果有子节点调和原来的子节点。 12345678910function shouldHydrateDueToLegacyHeuristic(container) &#123; const rootElement = getReactRootElementInContainer(container); return !!( rootElement &amp;&amp; //判断有这个节点和属性 rootElement.nodeType === ELEMENT_NODE &amp;&amp; rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME) //标识有服务端渲染 //合并的过程 );&#125; 1234567function legacyCreateRootFromDOMContainer()&#123;... const isConcurrent = false; 创建完FiberRoot后直接return return new ReactRoot(container, isConcurrent, shouldHydrate);&#125; 创建FiberRoot12345678910111213141516171819function ReactRoot( container: Container, isConcurrent: boolean, hydrate: boolean,) &#123; //传入dom节点 创建FiberRoot const root = DOMRenderer.createContainer(container, isConcurrent, hydrate); //再进行赋值给一个变量 this._internalRoot = roo t;&#125;....export function createContainer( containerInfo: Container, isConcurrent: boolean, hydrate: boolean,): OpaqueRoot &#123; return createFiberRoot(containerInfo, isConcurrent, hydrate);&#125; 创建ReactRoot对象看下ReactRoot中的render方法12345678910111213141516171819202122232425function ReactRoot( container: Container, isConcurrent: boolean, hydrate: boolean,) &#123; //传入dom节点 const root = DOMRenderer.createContainer(container, isConcurrent, hydrate); this._internalRoot = root;&#125;ReactRoot.prototype.render = function( children: ReactNodeList, callback: ?() =&gt; mixed,): Work &#123; const root = this._internalRoot; const work = new ReactWork(); callback = callback === undefined ? null : callback; if (__DEV__) &#123; warnOnInvalidCallback(callback, &#x27;render&#x27;); &#125; if (callback !== null) &#123; work.then(callback); &#125; DOMRenderer.updateContainer(children, root, null, work._onCommit); return work;&#125;;调用updateContainer 123456789101112131415161718export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any&gt;, callback: ?Function,): ExpirationTime &#123; const current = container.current; const currentTime = requestCurrentTime(); //computeExpirationForFiber是react16之后让我们使用任务更新优先级计算方法 const expirationTime = computeExpirationForFiber(currentTime, current); return updateContainerAtExpirationTime( element, //应用实际的节点 App container, //dom节点 对应的root parentComponent, // null expirationTime, callback, //work._onCommit );&#125; 调用updateContainerAtExpirationTime 12345678910111213141516171819202122232425262728293031export function updateContainerAtExpirationTime( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any&gt;, expirationTime: ExpirationTime, callback: ?Function,) &#123; // TODO: If this is a nested container, this won&#x27;t be the root. const current = container.current; if (__DEV__) &#123; if (ReactFiberInstrumentation.debugTool) &#123; if (current.alternate === null) &#123; ReactFiberInstrumentation.debugTool.onMountContainer(container); &#125; else if (element === null) &#123; ReactFiberInstrumentation.debugTool.onUnmountContainer(container); &#125; else &#123; ReactFiberInstrumentation.debugTool.onUpdateContainer(container); &#125; &#125; //=========暂时不管（context== null）======== const context = getContextForSubtree(parentComponent); if (container.context === null) &#123; container.context = context; &#125; else &#123; container.pendingContext = context; &#125; //=========创建更新======== return scheduleRootUpdate(current, element, expirationTime, callback); &#125; 开始调度首先要生成一个update，不管你是setState还是ReactDOM.render造成的 React 更新，都会生成一个叫update的对象，并且会赋值给Fiber.updateQueue 创建更新12345678910111213141516171819202122232425262728function scheduleRootUpdate( current: Fiber, element: ReactNodeList, expirationTime: ExpirationTime, callback: ?Function,) &#123; //创建update const update = createUpdate(expirationTime) update.payload = &#123; element &#125; callback = callback === undefined ? null : callback if (callback !== null) &#123; warningWithoutStack( typeof callback === &#x27;function&#x27;, &#x27;render(...): Expected the last optional `callback` argument to be a &#x27; + &#x27;function. Instead received: %s.&#x27;, callback, ) update.callback = callback &#125; //update加入到fiber对象上面对应的updateenqueue里面 //因为update可以是某一个节点上产生多次更新 enqueueUpdate(current, update) //告诉react任务开始调度 更新产生了 优先级概念产生需要分配优先级任务 scheduleWork(current, expirationTime) return expirationTime //这次更新的 超时时间。&#125; 接着会执行enqueueUpdate函数，这个函数其实大概的意思就是将新建的update对象和当前的FiberNode对象传入，然后为current$$1这个对象添加了updateQueue对象，里面保存着相关的一些任务。 然后就是调用scheduleWork。注意到这里之前setState和ReactDOM.render是不一样，但进入schedulerWork之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系 小结 首先我们要通过React.createElement函数来将我们定义好的组件进行转换为React元素 将创建好的React元素通过调用ReactDom.render来进行渲染 ReactDom.render调用后先创建根对象root，然后调用root.render 然后经过若干函数调用，来到workLoop函数，它将遍历虚拟DOM树，将下一个需要处理的虚拟DOM传给performUnitOfWork，performUnitOfWork再将虚拟DOM传给beginWork后，beginWork根据虚拟DOM的类型不同进行相应处理，并对儿子进行处理为Fiber类型，为Fiber类型虚拟DOM添加父节点、兄弟节点等待细节，已方便遍历树。 beginWork处理完后返回需要处理的子元素再继续处理，直到没有子元素（即返回null），此时performUnitOfWork调用completeUnitOfWork处理这颗虚拟DOM子树，将其转换为真实DOM。 最后所有的虚拟DOM都将转为真实DOM。 注意：子组件内修改props是没有效果的?_store中添加了一个新的对象validated(可写入)，element对象中添加了_self和_source属性（只读），最后冻结了element.props和element。 FiberRoot示意图","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列_createRef 与ref还有forwardRef","slug":" React源码系列_createRef 与ref还有forwardRef","date":"2019-04-25T16:00:00.000Z","updated":"2020-09-16T09:06:50.000Z","comments":true,"path":"2019/04/26/ React源码系列_createRef 与ref还有forwardRef/","link":"","permalink":"http://mariogogogo.github.io/2019/04/26/%20React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97_createRef%20%E4%B8%8Eref%E8%BF%98%E6%9C%89forwardRef/","excerpt":"这是最近增加的一种方案。Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用refs，只需将 ref 分配给构造函数中的实例属性。","text":"这是最近增加的一种方案。Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用refs，只需将 ref 分配给构造函数中的实例属性。 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.myRef = React.createRef() &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt; &#125;&#125; 你也可以使用 ref 回调函数的方案，而不用考虑 React 版本 123456789101112131415161718192021222324class SearchBar extends Component &#123; constructor(props) &#123; super(props); this.txtSearch = null; this.state = &#123; term: &#x27;&#x27; &#125;; this.setInputSearchRef = e =&gt; &#123; this.txtSearch = e; &#125; &#125; onInputChange(event) &#123; this.setState(&#123; term: this.txtSearch.value &#125;); &#125; render() &#123; return ( &lt;input value=&#123;this.state.term&#125; onChange=&#123;this.onInputChange.bind(this)&#125; ref=&#123;this.setInputSearchRef&#125; /&gt; ); &#125;&#125; 还有一种方法是再react16之前用的最多的一种方法但是再下一个大版本中将被废弃的一种方法 1&lt;p ref=&quot;strRef&quot;&gt;获取ref&lt;p&gt; 源码中如何实现 123456export function createRef(): RefObject &#123; const refObject = &#123; current: null, &#125;; return refObject;&#125; 你没看错！react.js中代码就只有这么一点，但后期如何使用这个refObject我们在后面讲react如何渲染过程中再讲解这个步骤。 什么是 forward refs? Ref forwarding 是一个特性，它允许一些组件获取接收到 ref 对象并将它进一步传递给子组件。 一般情况下ref可以获取class组件的实例，获取不到function 组件的实例比如这样1const Comp = （props,ref)=&gt; &lt;input type=&quot;text&quot; ref=&#123;ref&#125;/&gt;这个也可以看做PurComponent没有实例没有this是获取不到ref的但是第三方组件封装过，让其他用户使用的时候用户不确定你是否是PurComponent组件如果使用ref就获取不到。 解决这个问题我们就要使用forwardRef123456789const ButtonElement = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=&quot;CustomButton&quot;&gt; &#123;props.children&#125; &lt;/button&gt;));// Create ref to the DOM button:const ref = React.createRef();&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;&#x27;Forward Ref&#x27;&#125;&lt;/ButtonElement&gt; 然后我们看下forwardRef的源码： 123456789export default function forwardRef( render: (props: Props, ref: React$Ref&lt;ElementType&gt;) =&gt; React$Node,) &#123; //...忽略_DEV_... return &#123; $$typeof: REACT_FORWARD_REF_TYPE, render, //指的就是传进来的 function-Component &#125;;&#125; 返回也是一个对象，但是对象里的$$typeof与ReactElement中返回的$$typeof不能混淆。 123456&#123; $$typeof:xxx, props:&#123; $$typeof:xxx, &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列_Component做了什么","slug":" React源码系列_Component做了什么","date":"2019-04-24T16:00:00.000Z","updated":"2021-02-13T13:24:23.000Z","comments":true,"path":"2019/04/25/ React源码系列_Component做了什么/","link":"","permalink":"http://mariogogogo.github.io/2019/04/25/%20React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97_Component%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"有两种可行的方法来创建一个组件： Function Components: 这是创建组件最简单的方式。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素 Class Components: 你还可以使用 ES6 类来定义组件","text":"有两种可行的方法来创建一个组件： Function Components: 这是创建组件最简单的方式。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素 Class Components: 你还可以使用 ES6 类来定义组件 12345678function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125; propscontextrefs 想要获取的节点的实例挂载到refs上面 然后再component原型上有一个方法setState123456789101112Component.prototype.setState = function(partialState, callback) &#123; //判断类型是否object或者function或者null invariant( typeof partialState === &#x27;object&#x27; || typeof partialState === &#x27;function&#x27; || partialState == null, &#x27;setState(...): takes an object of state variables to update or a &#x27; + &#x27;function which returns an object of state variables.&#x27;, ); //当updater传入后执行enqueueSetState的方法（后面会讲） this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;;这个API强制我们的react更新，既是state没有改变123Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, &#x27;forceUpdate&#x27;);&#125;; 另一个重点 PureComponentReact.PureComponent 与 React.Component 完全相同，只是它为你处理了 shouldComponentUpdate() 方法。当属性或状态发生变化时，PureComponent 将对属性和状态进行浅比较。另一方面，一般的组件不会将当前的属性和状态与新的属性和状态进行比较。因此，在默认情况下，每当调用 shouldComponentUpdate 时，默认返回 true，所以组件都将重新渲染。源码中是如何做到的：123456789101112131415161718function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;Object.assign(pureComponentPrototype, Component.prototype);pureComponentPrototype.isPureReactComponent = true;export &#123;Component, PureComponent&#125;;我们可以认为他是继承Component 通过new 实现了一个ComponentDummy空的类让Component的原型对象赋值给ComponentDummy的原型对象pureComponentPrototype.constructor指向自己Component.prototype上的属性拷贝到pureComponentPrototype上 唯一的区别就是isPureReactComponent通过一个标识让继承自这个类的组件是不是PureComponent。然后判断props是否更新再判断组件是否更新。 这个方法中没有涉及到生命周期 和 render ，这是出乎意料的","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"如何合理布置React/Redux的目录结构","slug":"React-Redux如何合理布置目录结构","date":"2019-04-24T16:00:00.000Z","updated":"2020-09-16T09:07:45.000Z","comments":true,"path":"2019/04/25/React-Redux如何合理布置目录结构/","link":"","permalink":"http://mariogogogo.github.io/2019/04/25/React-Redux%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%B8%83%E7%BD%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"项目的结构改过很多次，每次根据需求的复杂度慢慢的修改，根据工作中的经验总结下几种结构的特点。","text":"项目的结构改过很多次，每次根据需求的复杂度慢慢的修改，根据工作中的经验总结下几种结构的特点。 按照文件类型划分不是很复杂的项目可以这样规划。 123456789101112|—— actions |—— CommandActions.jsx └── newAction.jsx &lt;- here|—— components |—— Command.jsx └── newComponent.jsx &lt;- here|—— containers |—— Command.jsx └── newContainers.jsx &lt;- here└── reducers |—— command.jsx └── newReducers.jsx &lt;- here 优点：项目简单结构清晰，actions，reducers，containers中放着每个模块的对应的结构文件。缺点：当你添加一个组件的时候你就需要在3个目录下操作，以及跨文件的管理对应的文件，有点不方便。 按照组件划分一个组件包含自身action，reducers，style等相关的文件，这样在修改某些文件的时候就非常的容易。对于项目不存在很复杂的异步逻辑等可以参考这样的结构。 1234567891011121314|—— app |—— App.jsx |—— reducers.jsx |—— routes.jsx|—— home |—— index.jsx |—— Home.jsx |—— HomeActions.jsx └── HomeReducer.jsx|—— product |—— index.jsx |—— ProductList.jsx |—— ProductActions.jsx └── ProductReducer.jsx 缺点：大型项目中如果存在大量复用模块处理起来非常麻烦 大型项目的组织1234567891011121314|——app |—— component # 这里放的都是公共部分的组件 |—— Header # 使用 styled-components 来定义基础组件 └── Fotter |—— containers # 页面容器 |—— HomePage |—— ... |—— index.js # 组织页面的结构, 私有模块和公共模块构成 |—— reducer.js # Home下的reducer逻辑 |—— component # 私有模块 |—— sagas.js # Home下的异步数据 |—— action.js |—— ... └── reducers.js # reducer component下面包括了大量的通用组件，不管是项目的平台移植，模块复用都很好管理。containers下如HomePage/index.js有复用的模块以及页面场景下特殊的模块构成， 同时index.js还负责模块跟redux store数据的链接，对应的每个场景都拥有自身saga，reducer等。构建大型的项目结构参考这个也是一个非常棒的 最后介绍下react-starter-kit这个项目的结构使用的是 fractal(不规则碎片形：适合大型项目)*，方法的分组主要是依照特性而不是文件类型。注意，这个目录结构只是一个指引，并不一定要按这个来。这种结构谐在让程序更容易扩展 123456789101112131415161718├── src # 程序源文件│ ├── main.js # 程序启动和渲染│ ├── components # 全局可复用的表现组件(Presentational Components)│ ├── containers # 全局可复用的容器组件│ ├── layouts # 主页结构│ ├── store # Redux指定块│ │ ├── createStore.js # 创建和使用redux store│ │ └── reducers.js # Reducer注册和注入│ └── routes # 主路由和异步分割点│ ├── index.js # 用store启动主程序路由│ ├── Root.js # 为上下文providers包住组件│ └── Home # 不规则路由│ ├── index.js # 路由定义和代码异步分割│ ├── assets # 组件引入的静态资源│ ├── components # 直观React组件│ ├── container # 连接actions和store│ ├── modules # reducers/constants/actions的集合│ └── routes ** # 不规则子路由(** 可选择的) routes 作为主入口，并且把所有路由对应的组件，assets, modules全部都集中在了一起,更像mvc的命名组织。reducer、action整合为modules， components作为view，container连接actions和store。 12345678910111213export const createRoutes = (store) =&gt; (&#123; path: &#x27;/&#x27;, component: CoreLayout, indexRoute: Home, childRoutes: [ CounterRoute(store), ZenRoute(store), ElapseRoute(store), RouteRoute(store), PageNotFound(), Redirect ]&#125;) 一个Counter模块包含如下： 12345Counter/ components/ # 页面的组件 containers/ # view 和 modules 数据对接 modules/ # 包含对应的 reducer, action index.js # 页面入口，定义path index.js 自动的注入reducer 到store，这样在顶层的store就无需要手动去整合每个模块自身的reducer。代码如下： 1234// 导入对应的redicerconst reducer = require(&#x27;./modules/counter&#x27;).default /* Add the reducer to the store on key &#x27;counter&#x27; */injectReducer(store, &#123; key: &#x27;counter&#x27;, reducer &#125;) 当然项目结构还是要根据个人或者项目需求而定，以上方案只做参考。谢谢！ 参考掘金Reudx官网","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列_ReactElement","slug":"React源码系列_ReactElement","date":"2019-04-24T16:00:00.000Z","updated":"2020-09-16T09:07:48.000Z","comments":true,"path":"2019/04/25/React源码系列_ReactElement/","link":"","permalink":"http://mariogogogo.github.io/2019/04/25/React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97_ReactElement/","excerpt":"上一节我们看到了jsx转义到javascript的时候都会调用ReactElement方法现在我们就来探索下ReactElement做了写什么","text":"上一节我们看到了jsx转义到javascript的时候都会调用ReactElement方法现在我们就来探索下ReactElement做了写什么 首先看下它的代码引用123456 import &#123; createElement, createFactory, cloneElement, isValidElement,&#125; from &#x27;./ReactElement&#x27;; 然后我们来看下createElement方法如何定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263export function createElement(type, config, children) &#123; let propName; const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; //判断是否存在config if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = &#x27;&#x27; + config.key; &#125; ...... for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; .... //arguments参数第三个开始作为childrenLength const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; .... props.children = childArray; &#125; //判断组件没有传props则可以用defaultProps作为默认参数 if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; .... //返回一个对象 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125; 参数 ： 字符串比如div，p代表原生DOM，称为HostComponent Class类型是我们继承自Component或者PureComponent的组件，称为ClassComponent 方法就是functional Component 原生提供的Fragment、AsyncMode等是Symbol，会被特殊处理 在处理config的过程中要处理不是props对应的属性值123456const RESERVED_PROPS = &#123; key: true, ref: true, __self: true, __source: true,&#125;;之后处理children 看下ReactElement方法12345678910111213const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, //记录负责创建此元素的组件 _owner: owner, &#125;; return element;&#125;; ReactElement只是一个用来承载信息的容器，他会告诉后续的操作这个节点的以下信息： type类型，用于判断如何创建节点 key和ref这些特殊信息 props新的属性内容 $$typeof用于确定是否属于ReactElement $$typeof与type的区别？$$typeof用于确定是否属于ReactElement，我们在用jsx写代码的时候所有的标签都是ReactElement创建的。类型$$typeof: REACT_ELEMENT_TYPE,type是记录我们节点类型的是原生组件还是自定义组件，还是标签类型 流程图大致内容感谢yck 接下来我们来看看react.createElement这个函数里面会帮我们做什么事情。 defineKeyPropWarningGetter和defineRefPropWarningGetter两个函数是干什么的？这两个函数仅仅只是将key和ref添加到即将传入ReactElement函数的props对象中而已。并且对get绑定了一个函数，当尝试获通过props获取key和ref的时候会出现警告。什么情况下childrenLength大于1？将原来的h1改成一个div，并且嵌套2个h1元素就可以发现childrenLength大于1了。ReactElement是干嘛的？包装在一个element对象 小结 首先会初始化一些列的变量，之后会判断我们传入的元素中是否带有key和ref的属性，这两个属性对于react是有特殊意义的，如果检测到有传入key,ref,self和source这4个属性值，会将其保存起来。 之后对传入的config做处理，循环config对象，并且剔除掉4个内置属性值（key,ref,self,source），之后重新组装新的config为props。 之后会检测传入的参数的长度，如果childrenLength等于1的情况下，那么就代表着当前createElement的元素没有子元素，只有文字或者是空，那么将内容赋值到props.children。那什么时候childrenLength会大于1呢？那就是当你的元素里面涉及到嵌套子元素的时候，那么children将会有多个传入到createElement函数中，这个之后再做详解，现在只针对最简单的DEMO去说明。 接着函数将会检测是否存在defaultProps这个参数，因为现在的DEMO是一个最简单的DEMO，而且传入的只是原生元素，所以没有defaultProps这个参数，我们先忽略。 检测key和ref是否有赋值，如果有将会执行defineKeyPropWarningGetter和defineRefPropWarningGetter两个函数。 最后将一系列组装好的数据传入ReactElement函数中。","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React源码系列_jsx转javascript","slug":"React源码系列_jsx转javascript","date":"2019-04-23T16:00:00.000Z","updated":"2020-09-16T09:07:48.000Z","comments":true,"path":"2019/04/24/React源码系列_jsx转javascript/","link":"","permalink":"http://mariogogogo.github.io/2019/04/24/React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97_jsx%E8%BD%ACjavascript/","excerpt":"这是下半年的对自己的提升。感谢jokcy","text":"这是下半年的对自己的提升。感谢jokcy React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用 JSX，但它有以下优点：JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。它是类型安全的，在编译过程中就能发现错误。使用 JSX 编写模板更加简单快速。12345678910111213141516171819202122232425&lt;div style=&#123;&#123;color:red&#125;&#125; key=&quot;1&quot; ref=&quot;divRef&quot;&gt; &lt;h1&gt;content &lt;a&gt;lianjie&lt;/a&gt; &lt;/h1&gt;&lt;/div&gt;......转义之后这样的..........&quot;use strict&quot;;React.createElement( &quot;div&quot;, &#123; style: &#123; color: red &#125;, key: &quot;1&quot;, ref: &quot;divRef&quot; &#125;, React.createElement( &quot;h1&quot;, null, &quot;content&quot;, React.createElement(&quot;a&quot;, null, &quot;lianjie&quot;) ));如果我们加个组件会如何呢？1234567891011121314151617181920212223242526272829function Comp()&#123; return &lt;h2&gt;i am Component&lt;/h2&gt;&#125;&lt;div style=&#123;&#123;color:red&#125;&#125; key=&quot;1&quot; ref=&quot;divRef&quot;&gt; &lt;h1&gt;content &lt;a&gt;lianjie&lt;/a&gt; &lt;Comp/&gt; &lt;/h1&gt;&lt;/div&gt;..........转义之后........React.createElement( &quot;div&quot;, &#123; style: &#123; color: red &#125;, key: &quot;1&quot;, ref: &quot;divRef&quot; &#125;, React.createElement( &quot;h1&quot;, null, &quot;content&quot;, React.createElement(&quot;a&quot;, null, &quot;lianjie&quot;), React.createElement(Comp, null) ));又或者这样1234567891011121314151617181920212223242526function Comp()&#123; return &lt;h2&gt;i am Component&lt;/h2&gt;&#125;&lt;Comp style=&#123;&#123;color:red&#125;&#125; key=&quot;1&quot; ref=&quot;divRef&quot;&gt; &lt;h1&gt;content &lt;a&gt;lianjie&lt;/a&gt; &lt;/h1&gt;&lt;/Comp&gt;.......转义之后..........React.createElement( Comp, //变量为组件名 &#123; style: &#123; color: red &#125;, key: &quot;1&quot;, ref: &quot;divRef&quot; &#125;, React.createElement( &quot;h1&quot;, null, &quot;content&quot;, React.createElement(&quot;a&quot;, null, &quot;lianjie&quot;) ));组件名千万不能小心不然会出现这样123456789101112131415161718192021222324252627function comp()&#123; return &lt;h2&gt;i am Component&lt;/h2&gt;&#125;&lt;comp style=&#123;&#123;color:red&#125;&#125; key=&quot;1&quot; ref=&quot;divRef&quot;&gt; &lt;h1&gt;content &lt;a&gt;lianjie&lt;/a&gt; &lt;/h1&gt;&lt;/comp&gt;.......转义之后..........React.createElement( &quot;comp&quot;, //变量为字符串 不是正确的原生标签会导致报错 &#123; style: &#123; color: red &#125;, key: &quot;1&quot;, ref: &quot;divRef&quot; &#125;, React.createElement( &quot;h1&quot;, null, &quot;content&quot;, React.createElement(&quot;a&quot;, null, &quot;lianjie&quot;) )); 下一节学习下createElement到底做了些什么","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"「Vue实战」适合你的优化指南-动态注册组件","slug":"「Vue实战」适合你的优化指南-动态注册组件","date":"2019-04-22T16:00:00.000Z","updated":"2020-09-16T09:06:50.000Z","comments":true,"path":"2019/04/23/「Vue实战」适合你的优化指南-动态注册组件/","link":"","permalink":"http://mariogogogo.github.io/2019/04/23/%E3%80%8CVue%E5%AE%9E%E6%88%98%E3%80%8D%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","excerpt":"我们在刚开始学vue的时候写一些小组件引入到大组件中都是这样的：","text":"我们在刚开始学vue的时候写一些小组件引入到大组件中都是这样的：12345678910111213import BaseButton from &#x27;./baseButton&#x27;import BaseIcon from &#x27;./baseIcon&#x27;import BaseInput from &#x27;./baseInput&#x27;export default &#123; components: &#123; BaseButton, BaseIcon, BaseInput &#125;&#125;&lt;BaseInput v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot; /&gt;&lt;BaseButton @click=&quot;search&quot;&gt; &lt;BaseIcon name=&quot;search&quot;/&gt;&lt;/BaseButton&gt;步骤一般有三步： 第一步，引入、 第二步注册、 第三步才是正式的使用， 这也是最常见和通用的写法。但是这种写法经典归经典，好多组件，要引入多次，注册多次，感觉很烦。我们可以借助一下webpack，使用 require.context() 方法来创建自己的（模块）上下文，从而实现自动动态require组件。 思路是：在src文件夹下面main.js中，借助webpack动态将需要的基础组件统统打包进来。 12345678910111213141516171819202122232425262728293031323334353637383940import Vue from &#x27;vue&#x27;/** * 首字母大写 * @param str 字符串 * @example heheHaha * @return &#123;string&#125; HeheHaha */function capitalizeFirstLetter(str) &#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;/** * 对符合&#x27;xx/xx.vue&#x27;组件格式的组件取组件名 * @param str fileName * @example abc/bcd/def/basicTable.vue * @return &#123;string&#125; BasicTable */function validateFileName(str) &#123; return /^\\S+\\.vue$/.test(str) &amp;&amp; str.replace(/^\\S+\\/(\\w+)\\.vue$/, (rs, $1) =&gt; capitalizeFirstLetter($1))&#125;const requireComponent = require.context(&#x27;./&#x27;, true, /\\.vue$/)console.log(&#x27;requireComponent&#x27;,requireComponent)// 找到组件文件夹下以.vue命名的文件，如果文件名为index，那么取组件中的name作为注册的组件名requireComponent.keys().forEach(filePath =&gt; &#123; const componentConfig = requireComponent(filePath) const fileName = validateFileName(filePath) const componentName = fileName.toLowerCase() === &#x27;index&#x27; ? capitalizeFirstLetter(componentConfig.default.name) : fileName // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig)&#125;) 在main.js中引入123456789101112131415161718192021222324252627import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;import &#x27;@/icons&#x27;// 全局挂载请求import Global from &#x27;./global&#x27;;// 全局注册组件import componentRegister from &#x27;./components/componentRegister&#x27;import Loading from &#x27;./components/loadding&#x27;// 全局设置节流/防抖import Throttle from &#x27;./components/Throttle&#x27;Vue.component(&#x27;Throttle&#x27;, Throttle)Vue.use(Loading)Vue.use(Global) Vue.config.productionTip = falseconst vm = new Vue(&#123; router, store, componentRegister,//引入 render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)BasicTable.js123456789&lt;template&gt; &lt;div&gt;我是BasicTable小组件&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;BasicTable&quot; &#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"「Vue实战」适合你的优化指南-请求篇","slug":"「Vue实战」适合你的优化指南-请求篇","date":"2019-04-20T16:00:00.000Z","updated":"2020-09-16T09:06:51.000Z","comments":true,"path":"2019/04/21/「Vue实战」适合你的优化指南-请求篇/","link":"","permalink":"http://mariogogogo.github.io/2019/04/21/%E3%80%8CVue%E5%AE%9E%E6%88%98%E3%80%8D%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97-%E8%AF%B7%E6%B1%82%E7%AF%87/","excerpt":"先看看目录一般项目中处理搭建环境我们最常做的就是封装请求，今天就来学习一下如何封装一个好用的请求","text":"先看看目录一般项目中处理搭建环境我们最常做的就是封装请求，今天就来学习一下如何封装一个好用的请求 接口模块处理对axios的二次封装很基础的部分,这里的封装是依据 JWT前提还需要知道什么是 router.history.current.path 告诉你什么是 router.currentRoute.fullPath 告诉你当前路径链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import axios from &#x27;axios&#x27;import router from &#x27;../router&#x27;import &#123; MessageBox, Message &#125; from &#x27;element-ui&#x27;let loginUrl = &#x27;/login&#x27;// 根据环境切换接口地址axios.defaults.baseURL = process.env.VUE_APP_APIaxios.defaults.headers = &#123; &#x27;Postman-Token&#x27;: &#x27;3deda212-00f1-44e5-8d92-18463283de1d&#x27;, &#x27;cache-control&#x27;: &#x27;no-cache&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;, axios.defaults.timeout = 60000// 请求拦截axios.interceptors.request.use( config =&gt; &#123; if (router.history.current.path !== loginUrl &amp;&amp; router.history.current.path != &quot;/about&quot;) &#123; let token = window.sessionStorage.getItem(&#x27;token&#x27;) if (token == null) &#123; router.replace(&#123; path: loginUrl, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) return false &#125; else &#123; config.headers[&#x27;Authorization&#x27;] = &#x27;JWT&#x27; + token &#125; &#125; return config &#125;, error =&gt; &#123; Message.warning(error) return Promise.reject(error) &#125;)// 响应拦截 异常处理axios.interceptors.response.use( response =&gt; &#123; return response.data &#125;, error =&gt; &#123; if (error.message !== undefined) &#123; switch (error.response.status) &#123; case 400: MessageBox.alert(error.response.data) break case 401: if (window.sessionStorage.getItem(&#x27;out&#x27;) === null) &#123; window.sessionStorage.setItem(&#x27;out&#x27;, 1) MessageBox.confirm(&#x27;会话已失效! 请重新登录&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;重新登录&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; router.replace(&#123; path: loginUrl, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) &#125;) &#125; break case 402: MessageBox.confirm(&#x27;登陆超时 ！&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;重新登录&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; router.replace(&#123; path: loginUrl, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) &#125;) break case 403: MessageBox.alert(&#x27;没有权限&#x27;) break default: MessageBox.alert(`连接错误$&#123;error.response.status&#125;`) &#125; &#125; &#125;)// 导出基础的请求类型封装export default &#123; // 其中给 get请求加上时间戳参数，避免从缓存中拿数据 get (url, param) &#123; if (param !== undefined) &#123; param = &#123; ...param, _t: (new Date()).getTime() &#125; &#125; else &#123; param = &#123; _t: (new Date()).getTime() &#125; &#125; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; method: &#x27;GET&#x27;, url, param: param &#125;) .then(res =&gt; &#123; resolve(res) &#125;) &#125;) &#125;, getData (url, param) &#123; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; method: &#x27;GET&#x27;, url, param: param &#125;) .then(res =&gt; &#123; if (res.code === 4000) &#123; resolve(res.data) &#125; else &#123; Message.warning(res.msg) &#125; &#125;) &#125;) &#125;, post (url, param, config) &#123; console.log(&#x27;router.history.current.path:当前路径&#x27;,router.history.current.path) console.log(&#x27;router.currentRoute.fullPath:&#x27;,router.currentRoute.fullPath) return new Promise((resolve, reject) =&gt; &#123; axios.post(url, param, config) .then(res =&gt; &#123; resolve(res) &#125;) &#125;) &#125;&#125; 统一请求入口123456789 // 请求按模板合并import http from &#x27;./request&#x27;import login from &#x27;./login&#x27;// const api = Object.assign(&#123;&#125;,http,login,其他api模板)const api = Object.assign(&#123;&#125;, http, login)export default api 单独请求12345678910111213141516import http from &#x27;./request&#x27;// https://easy-mock.com/mock/5cbe83dd59a6ea65f79ad4f5/api/v1/loginconst baseUrl = &quot;https://easy-mock.com/mock/5cbe83dd59a6ea65f79ad4f5&quot;;export default &#123; login (param) &#123; return http.post(&#x27;http://rap2api.taobao.org/app/mock/6006/api/u/verify&#x27;, param) &#125;, out (param) &#123; return http.get(&#x27;/api/v1/out&#x27;, param) &#125;, register (param) &#123; return http.post(&#x27;/api/v1/register&#x27;, param) &#125;&#125; 全局导入在main.js12345678910import &#x27;@/icons&#x27;// 全局挂载请求import Global from &#x27;./global&#x27;;const vm = new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)console.log(vm) 加载后 使用1234567891011121314151617181920212223&lt;script&gt; import &#123; MessageBox, Message, Button, &#125; from &#x27;element-ui&#x27; export default &#123; name: &#x27;about&#x27;, data () &#123; return &#123; val: 0 &#125; &#125;, methods: &#123; onClick ($ev, val) &#123; this.val += val &#125;, getData: async function () &#123; const res = await this.$http.login(&#123; &#x27;name&#x27;: &#x27;哈哈&#x27; &#125;).then(res =&gt; &#123; return res &#125;) console.log(res) res.success ? Message.success(&#x27;登录成功&#x27;) : this.$message.warning(res.msg) &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"ReactNative离线框架设计","slug":"ReactNative离线框架设计","date":"2019-04-12T16:00:00.000Z","updated":"2020-09-16T09:07:50.000Z","comments":true,"path":"2019/04/13/ReactNative离线框架设计/","link":"","permalink":"http://mariogogogo.github.io/2019/04/13/ReactNative%E7%A6%BB%E7%BA%BF%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/","excerpt":"好久没更新，最近一直赶项目，疲敝 - -！！！","text":"好久没更新，最近一直赶项目，疲敝 - -！！！最近项目升级2.0，增加了一个离线缓存的功能优化。记录一下： AsyncStorage介绍AsyncStorage 是一个简单的、异步的、持久化的 Key-Value 存储系统，它对于 App 来说是全局性的。它用来代替 LocalStorage。由于它的操作是全局的，官方建议我们最好针对 AsyncStorage 进行一下抽象的封装再使用，而且不是直接拿 AsyncStorage 进行使用。AsyncStorage 存储的位置根据系统的不同而有所差异。iOS 中的存储类似于 NSUserDefault，通过 plist 文件存放在设备中。Android 中会存储在 RocksDB 或者 SQLite 中，取决于你使用哪个。 相关方法（1）根据键来获取值，获取的结果会放在回调函数中。 static getItem(key: string, callback:(error, result)) （2）根据键来设置值。 static setItem(key: string, value: string, callback:(error)) （3）根据键来移除项。 static removeItem(key: string, callback:(error)) （4）合并现有值和输入值。 static mergeItem(key: string, value: string, callback:(error)) （5）清除所有的项目 static clear(callback:(error)) （6）获取所有的键 static getAllKeys(callback:(error, keys)) （7）清除所有进行中的查询操作。 static flushGetRequests() （8）获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’] static multiGet(keys, callback:(errors, result)) （9）设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]] static multiSet(keyValuePairs, callback:(errors)) （10）删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’] static multiRemove(keys, callback:(errors)) （11）多个键值合并，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]] static multiMerge(keyValuePairs, callback:(errors)) 设计为什么要离线缓存？ 提升用户体验 节省流量 缺点只能针对一些对数据实时性要求不高的App开发 离线缓存的策略： 首先保存数据12345678910/** * 保存数据 * @param url * @param data * @param callback */ saveData(url, data, callback) &#123; if (!data || !url) return; AsyncStorage.setItem(url, JSON.stringify(this._wrapData(data)), callback); &#125; 注意AsyncStorage无法保存为object类型所以我们需要将其序列号成json 获取本地时间设置有效期。推荐设置为服务器时间123_wrapData(data) &#123; return &#123;data: data, timestamp: new Date().getTime()&#125;; &#125; 然后先获取本地数据12345678910111213141516171819202122/** * 获取本地数据 * @param url * @returns &#123;Promise&#125; */fetchLocalData(url) &#123; return new Promise((resolve, reject) =&gt; &#123; AsyncStorage.getItem(url, (error, result) =&gt; &#123; if (!error) &#123; try &#123; resolve(JSON.parse(result)); &#125; catch (e) &#123; reject(e); console.error(e); &#125; &#125; else &#123; reject(error); console.error(error); &#125; &#125;) &#125;)&#125; 只需要url去比对本地缓存中是否有数据，保存类型为字符串string类型，方便我们调用后用转成object使用 获取网络数据1234567891011121314151617181920212223242526272829303132333435363738/** * 获取网络数据 * @param url * @param flag * @returns &#123;Promise&#125; */ fetchNetData(url, flag) &#123; return new Promise((resolve, reject) =&gt; &#123; if (flag !== FLAG_STORAGE.flag_trending) &#123; fetch(url) .then((response) =&gt; &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then((responseData) =&gt; &#123; this.saveData(url, responseData) resolve(responseData); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;) &#125; else &#123; new Trending().fetchTrending(url) .then(items =&gt; &#123; if (!items) &#123; throw new Error(&#x27;responseData is null&#x27;); &#125; this.saveData(url, items); resolve(items); &#125;) .catch(error =&gt; &#123; reject(error); &#125;) &#125; &#125;) &#125; 最后我们封装fetch请求123456789101112131415161718192021222324252627282930313233export default class DataStore &#123; /** * 获取数据，优先获取本地数据，如果无本地数据或本地数据过期则获取网络数据 * @param url * @param flag * @returns &#123;Promise&#125; */ fetchData(url, flag) &#123; return new Promise((resolve, reject) =&gt; &#123; this.fetchLocalData(url).then((wrapData) =&gt; &#123; if (wrapData &amp;&amp; DataStore.checkTimestampValid(wrapData.timestamp)) &#123; console.log(&#x27;读取本地缓存&#x27;,wrapData) resolve(wrapData); &#125; else &#123; //本地没有就获取网络请求 console.log(&#x27;url&#x27;,url,&#x27;flag&#x27;,flag) this.fetchNetData(url, flag).then((data) =&gt; &#123; resolve(this._wrapData(data)); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125; &#125;).catch((error) =&gt; &#123; this.fetchNetData(url, flag).then((data) =&gt; &#123; resolve(this._wrapData(data)); &#125;).catch((error =&gt; &#123; reject(error); &#125;)) &#125;) &#125;) &#125;&#125; 时间有效期的检测12345678910111213141516 /** * 检查timestamp是否在有效期内 * @param timestamp 项目更新时间 * @return &#123;boolean&#125; true 不需要更新,false需要更新 */ static checkTimestampValid(timestamp) &#123; const currentDate = new Date(); const targetDate = new Date(); targetDate.setTime(timestamp); if (currentDate.getMonth() !== targetDate.getMonth()) return false; if (currentDate.getDate() !== targetDate.getDate()) return false; if (currentDate.getHours() - targetDate.getHours() &gt; 4) return false;//有效期4个小时 // if (currentDate.getMinutes() - targetDate.getMinutes() &gt; 1)return false; return true; &#125;&#125; 参考贾鹏辉的技术博客官网参考一","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"ReactNative 中使用redux和logger,thunk","slug":"ReactNative_redux","date":"2019-03-27T16:00:00.000Z","updated":"2020-09-16T09:07:50.000Z","comments":true,"path":"2019/03/28/ReactNative_redux/","link":"","permalink":"http://mariogogogo.github.io/2019/03/28/ReactNative_redux/","excerpt":"项目中需要用到redux，今天就用加班时间来重新复习下学习一下；之前发表过react的redux；","text":"项目中需要用到redux，今天就用加班时间来重新复习下学习一下；之前发表过react的redux； 先看下具体流程我们一一介绍 了解下redux特性 单一数据源： 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改：为了描述 action 如何改变 state tree ，你需要编写 reducers。 预见性：所有的用户的行为都是你提前定义好的。 统一管理state：所有的状态都在一个store中分配管理。 工作流程 用户（操作view）发出action，发出的方式用dispatch方法； 然后store调用redurce，并传入2个参数（一个当前state，一个收到的action），reducer会返回新的state，如果有middleware，store会将当前state和收到的action传递给middleware，middleware会调用reducer，返回新的state； state一旦有变化，store就会监听到，来更新View； Redux与Flux的区别Redux是Flux思想的一种实现，同时又在其基础上做了改进。Redux秉承了Flux单向数据流、Store是唯一的数据源的思想。 Redux中没有Dispatcher: 它使用Store的Store.dispatch0方法来把action传给Store, 由于所有的action处理都会经过这个Store.dispatch0方法，所以在Redux中很容易实现Middleware机制。 Middleware可以让你在reducer执行前与执行后进行拦截并插入代码，来达到操作action和Store的目的，这样-来就很容易实现灵活的日志打印、错误收集、API请求、路由等操作。 Redux只有一个Store: Flux中允许有多个Store, 但是Redux中只允许有- 个，相较于多个Store的Flux,一个Store更加清晰，井易于管理;Redux有那几部分构成? action: action就是一 个描述发生什么的对象; reducer: 形式为(state, action) =&gt; state的纯函数，功能是根据action 修改state将其转变成下一个state; store: 用于存储state, 你可以把它看成-个容器，整个应用只能有一个store实战部分创建store 1234567891011121314151617import &#123; createStore, applyMiddleware, compose &#125; from &#x27;redux&#x27;;//异步操作import thunk from &#x27;redux-thunk&#x27;;import createLogger from &#x27;redux-logger&#x27;;import rootReducer from &#x27;../reducers&#x27;;function configureStore(initialState) &#123; return createStore( rootReducer, initialState, compose(applyMiddleware(thunk, createLogger)) );&#125;const store = configureStore();export default store; 首先最外层导入store 需要辅助工具redux-logger(这个会打印你的所有 state和 action变化 , 建议使用)redux-thunk(中间件, 用于异步操作)react-navigation(如果你要做多个页面跳转就install) 针对不同功能点可以设置不同的reducer, 拆分 reducer 对一个不同的操作, 然后用combineReducers 合并所有的 reducer 到 rootReducer 用户触发action123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123; Component &#125; from &quot;react&quot;;import &#123; View, Text, TextInput, Image, TouchableOpacity &#125; from &quot;react-native&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; bindActionCreators &#125; from &quot;redux&quot;;import * as loginAction from &quot;../actions/LoginActions&quot;;import * as themeAction from &quot;../actions/ThemeActions&quot;;import &#123; NavigationActions &#125; from &quot;react-navigation&quot;;import MainPage from &quot;./MainPage&quot;;class LoginPage extends Component &#123; static navigationOptions = &#123; title: &quot;LoginPage&quot; &#125;; shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.status === &quot;登录成功&quot; &amp;&amp; nextProps.isSuccess) &#123; this.props.navigation.push(&quot;Main&quot;, &#123; user: nextProps.user &#125;); &#125; return true; &#125; render() &#123; const &#123; LoginAction &#125; = this.props; console.log(this.props); return ( &lt;View style=&#123;&#123; flex: 1, backgroundColor: &quot;#fff&quot;, alignItems: &quot;center&quot; &#125;&#125;&gt; &lt;TouchableOpacity style=&#123;&#123; backgroundColor: &quot;#cdcdcd&quot;, marginTop: 200 &#125;&#125; onPress=&#123;() =&gt; &#123; this.props.dispatch(loginAction.requireLogin()); // LoginAction() &#125;&#125; &gt; ......// apStateToProps(state) 把 reducer 里改变过的 state 通过 props 传递过来function mapStateToProps(state) &#123; return &#123; status: state.LoginReducer.data.status, isSuccess: state.LoginReducer.data.isSuccess, user: state.LoginReducer.data.user, color: state.themeReducer.color &#125;;&#125;// 自动绑定 action creators到 dispatch() 函数 这个函数一样 把你要 dispatch 的 action 当做 props 传递过来 如果这么写 上面的触发 action 的时候就不要 this.prop.dispatch(xxxAction) 了 , 可以直接写 this,props.LoginActionfunction matchDispatchToProps(dispatch) &#123; return &#123; LoginAction: bindActionCreators(loginAction.requireLogin, dispatch) &#125;;&#125;// connect 连接组件与 store ,任何时候只要 store 发生改变, mapStateToProps 都会被调用, 函数接收两个参数 第一个参数里有两个参数 分别是mapStateToProps matchDispatchToPropsexport default connect(mapStateToProps)(LoginPage); 执行action方法12345678910111213141516&#x27;use strict&#x27;;import * as types from &#x27;../constants/LoginTypes&#x27;;import &#123; loginRequest &#125; from &#x27;../API/loginRequest&#x27;;export function login_out(data) &#123; return &#123; type: types.LOGIN_IN_OUT, data &#125;&#125;// 异步的Action 需要返回的是一个 function 在 createStore 时由middleWare 做处理 普通的action 直接返回纯对象即可export function requireLogin() &#123; return loginRequest();&#125; 执行apiaction.js中的方法，store-》reducer12345678910111213import *as loginActions from &#x27;../actions/LoginActions&#x27;;// 异步的网络请求方法 在这里再进行 dispatch Actionexport function loginRequest(action) &#123; return dispatch =&gt; &#123; dispatch(loginActions.login_doing(doingData)); let result = fetch(url) .then(res =&gt; &#123; dispatch(loginActions.login_done(doneData)); &#125;).catch(err =&gt; &#123; dispatch(loginActions.login_err(errData)); &#125;); &#125;&#125; 通过reducer返回新的state12345678export default function loginIn(state = initialState, action) &#123; console.log(state.type,action); switch (action.type) &#123; case types.LOGIN_IN_DOING: return &#123; ...state, data: action.data &#125; 最后重新根据store中的state更新View12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from &quot;react&quot;;import &#123; View, Text, TextInput, Image, TouchableOpacity &#125; from &quot;react-native&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; bindActionCreators &#125; from &quot;redux&quot;;import * as loginAction from &quot;../actions/LoginActions&quot;;import * as themeAction from &quot;../actions/ThemeActions&quot;;import &#123; NavigationActions &#125; from &quot;react-navigation&quot;;import MainPage from &quot;./MainPage&quot;;class LoginPage extends Component &#123; static navigationOptions = &#123; title: &quot;LoginPage&quot; &#125;; shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.status === &quot;登录成功&quot; &amp;&amp; nextProps.isSuccess) &#123; this.props.navigation.push(&quot;Main&quot;, &#123; user: nextProps.user &#125;); &#125; return true; &#125; ... // 这个函数最正确的名字应该叫 mapStateToProps(state) 把 reducer 里改变过的 state 通过 props 传递过来function mapStateToProps(state) &#123; return &#123; status: state.LoginReducer.data.status, isSuccess: state.LoginReducer.data.isSuccess, user: state.LoginReducer.data.user, color: state.themeReducer.color &#125;;&#125;// 自动绑定 action creators到 dispatch() 函数 这个函数一样 把你要 dispatch 的 action 当做 props 传递过来 如果这么写 上面的触发 action 的时候就不要 this.prop.dispatch(xxxAction) 了 , 可以直接写 this,props.LoginActionfunction matchDispatchToProps(dispatch) &#123; return &#123; LoginAction: bindActionCreators(loginAction.requireLogin, dispatch) &#125;;&#125;// connect 连接组件与 store ,任何时候只要 store 发生改变, mapStateToProps 都会被调用, 函数接收两个参数 第一个参数里有两个参数 分别是mapStateToProps matchDispatchToPropsexport default connect(mapStateToProps)(LoginPage);//export default connect(select)(LoginPage) 讲完再送一张图理解下整个过程 Github项目地址","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"多种跨域解决方案","slug":"多种跨域解决方案","date":"2019-03-07T16:00:00.000Z","updated":"2020-09-16T09:07:01.000Z","comments":true,"path":"2019/03/08/多种跨域解决方案/","link":"","permalink":"http://mariogogogo.github.io/2019/03/08/%E5%A4%9A%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"同源策略？如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。","text":"同源策略？如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 为什么会有跨域这个问题出现因为浏览器的同源策略导致了跨域，就是浏览器在搞事情浏览器为什么要搞事情？就是不想给好日子我们过？对于这样的质问，浏览器甩锅道：“同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。” cookie LocalStorage只支持同源下 Dom元素也同源策略 iframe （iframe里弄一个百度账号） ajax不支持跨域 实现跨域前端放一个服务器，后台放一个服务器需要通信要实现跨域 jsonp （只支持get） cors postMessage document.domain window.name location.hash http-proxy nginx websocket 一、 通过jsonp跨域jsonp123456789&lt;script&gt; // 百度：https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=h&amp;cb=show function show(data) &#123; console.log(data); &#125; &lt;!--show(&#123; q: &quot;h&quot;, p: false, s: [&quot;haha新歌&quot;, &quot;虎牙&quot;, &quot;花瓣&quot;, &quot;海贼王&quot;, &quot;虎牙直播&quot;, &quot;华为&quot;, &quot;虎扑&quot;, &quot;汇率&quot;, &quot;花瓣网&quot;, &quot;华为商城&quot;] &#125;);--&gt; &lt;/script&gt; //或者 &lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=h&amp;cb=show&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738//简单封装jsonp function jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;); window[cb] = function (data) &#123; resolve(data) window.document.head.removeChild(script); &#125; params = &#123; ...params, cb &#125; //wd=h&amp;cb=show let arr = [] for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` console.log(script.src); window.document.head.appendChild(script); &#125;) &#125; //缺点只能get，可以xss攻击 //调用 jsonp(&#123; url: &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#x27;, params: &#123; wd: &#x27;h&#x27; &#125;, cb:&#x27;show&#x27; &#125;).then(data=&gt;&#123; console.log(data); &#125;) 二、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 如果只是单纯的3000端口请求4000端口 12345678910111213141516171819let express = require(&#x27;express&#x27;);let app = express();app.get(&#x27;/getData&#x27;,function(req,res) &#123; res.end(&#x27;you look 4000&#x27;)&#125;)app.listen(&#x27;4000&#x27;);console.log(&#x27;启动4000&#x27;);//===============================let express = require(&#x27;express&#x27;);let app = express();app.use(express.static(__dirname))app.listen(&#x27;3000&#x27;);console.log(&#x27;启动&#x27;); 请求头的数据请求发过来了被浏览器屏蔽了解决：server2.js1234567891011//白名单let whitelist = [&#x27;http://localhost:3000&#x27;]app.use(function(req,res,next)&#123; let origin = req.headers.origin; if(whitelist.includes(origin))&#123; //设置哪个源可以访问我 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); &#125; next();&#125;)...其他请求方式 1res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;name&#x27;); 还可能出现这个问题 123456789//设置哪个源可以访问我 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); //设置请求头 res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;name&#x27;); res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT&#x27;); res.setHeader(&#x27;Access-Control-Max-Age&#x27;, 6); if (req.method === &quot;OPTIONS&quot;) &#123; res.end(); //PUT请求不做任何处理 &#125; 可以携带cookie 获取某个头 完整代码html12345678910111213141516 var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; document.cookie = &quot;cook=chan&quot;; xhr.open(&#x27;get&#x27;, &#x27;http://localhost:4000/getData&#x27;, true); xhr.setRequestHeader(&#x27;name&#x27;,&#x27;chan&#x27;) // xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText);console.log(xhr.getResponseHeader(&#x27;name&#x27;)); &#125; else if (xhr.readyState == 304) &#123; onsole.log(xhr.responseText); &#125; &#125;; xhr.send();server2.js1234567891011121314151617181920212223242526272829303132333435363738let express = require(&#x27;express&#x27;);let app = express();//白名单let whitelist = [&#x27;http://localhost:3000&#x27;]app.use(function(req,res,next)&#123; console.log(req.headers); let origin = req.headers.origin; if(whitelist.includes(origin))&#123; //设置哪个源可以访问我 // res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &#x27;*&#x27;); //任务接口 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &#x27;*&#x27;); //任务接口 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); //设置哪个头访问我 res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;name&#x27;); //允许哪个方法访问我 res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;PUT&#x27;); // 允许携带cookie (如果Allow-Origin带*号就不能设置这个) res.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;,true); // 预检存活时间 res.setHeader(&#x27;Access-Control-Max-Age&#x27;, 6); // 允许前端获取某个头(返回的头) res.setHeader(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;name&#x27;); if (req.method === &quot;OPTIONS&quot;) &#123; res.end(); //PUT请求不做任何处理 &#125; &#125; next();&#125;)app.get(&#x27;/getData&#x27;, function (req, res) &#123; res.setHeader(&#x27;name&#x27;,&#x27;chan&#x27;) //返回某个头 res.end(&#x27;you get 4000&#x27;)&#125;)app.put(&#x27;/getData&#x27;,function(req,res) &#123; res.end(&#x27;you look 4000&#x27;)&#125;)app.listen(&#x27;4000&#x27;);console.log(&#x27;启动4000&#x27;); 三、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数 data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 a.html 12345678910&lt;iframe id=&quot;frame&quot; src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; onload=&quot;sayb()&quot;&gt;&lt;/iframe&gt; &lt;script&gt; function sayb() &#123; let frame = document.getElementById(&quot;frame&quot;); frame.contentWindow.postMessage(&#x27;b页面你好&#x27;, &#x27;http://localhost:4000&#x27;); window.onmessage = function (e) &#123; console.log(e.data); &#125; &#125; &lt;/script&gt; b.html 1234567&lt;script&gt; window.onmessage &#x3D; function(e) &#123; console.log(e.data); console.log(e); e.source.postMessage(&#39;a.html你&#39;,e.origin) &#125; &lt;&#x2F;script&gt; e的参数 四、 document.domain+ iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。域名一级域名 二级域名 www.baidu.com video.baidu.coma.html12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://localhost:3000/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &#x27;domain.com&#x27;; var user = &#x27;admin&#x27;;&lt;/script&gt; b.html12345&lt;script&gt; document.domain = &#x27;domain.com&#x27;; // 获取父窗口中变量 alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);&lt;/script&gt; 五、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。a.html12345678910// 高级api 不兼容socket.io; // (一般不使用) let socket = new WebSocket(&#x27;ws://localhost:3000&#x27;); socket.onopen = function () &#123; socket.send(&#x27;我来跨域了&#x27;) &#125; socket.onmessage=function(e)&#123; console.log(e); console.log(e.data); &#125; server.js12345678910111213let express = require(&#x27;express&#x27;);let app = express();let WebSocket = require(&#x27;ws&#x27;);let wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on(&#x27;connection&#x27;,function(ws) &#123; ws.on(&#x27;message&#x27;,function(data)&#123; console.log(data) //发送 ws.send(&#x27;接受到消息了哈哈&#x27;) &#125;)&#125;) 六、 location.hash + iframe跨域（很low）实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。a和b是同域 http://localhost:3000c是独立的域 http://localhost:4000具体实现：A域：a.html -&gt; c域：c.html -&gt; b域：b.html，a给c传一个hash值，c收到hash值后，c把hash值传递给b，b将结果放到a的hash值中 a.html123456&lt;iframe src=&quot;http://localhost:4000/c.html#abc&quot;&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function() &#123; console.log(location.hash); &#125; &lt;/script&gt;c.html 123456&lt;script&gt; console.log(location.hash); //#abc let frame = document.createElement(&quot;iframe&quot;); frame.src = &quot;http://localhost:3000/b.html#youcanbb&quot; document.body.appendChild(frame) &lt;/script&gt; b.html 12345&lt;script&gt; //爸爸的爸爸 window.parent.parent.location.hash = location.hash; console.log(location.hash);&lt;/script&gt; 七、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB） 栗子a和b是同域 http://localhost:3000c是独立的域 http://localhost:4000 a获取c的数据a先引用c c把值放到window.name,把a引用的地址改到ba.html12345678910111213&lt;iframe id=&quot;frame&quot; src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt; &lt;script&gt; let first = true; function load() &#123; if (first) &#123; let frame = document.getElementById(&quot;frame&quot;); frame.src = &quot;http://localhost:3000/b.html&quot; first = false; &#125; else &#123; console.log(frame.contentWindow.name); &#125; &#125; &lt;/script&gt;b.html空c.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.name=&quot;我是c&quot; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 1234567891011121314#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端代码： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:81/?user=admin&#x27;, true);xhr.send(); Nodejs后台：123456789101112131415161718var http = require(&#x27;http&#x27;);var server = http.createServer();var qs = require(&#x27;querystring&#x27;);server.on(&#x27;request&#x27;, function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; &#x27;Set-Cookie&#x27;: &#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27; // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen(&#x27;8080&#x27;);console.log(&#x27;Server is running at port 8080...&#x27;); 总结今天工作不是很多，用了一天时间总结了下。努力！最后祝天下女人节日快乐O(∩_∩)O哈哈~","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"Vue中的简单动画","slug":"Vue中的简单动画","date":"2019-03-03T16:00:00.000Z","updated":"2020-09-16T09:07:56.000Z","comments":true,"path":"2019/03/04/Vue中的简单动画/","link":"","permalink":"http://mariogogogo.github.io/2019/03/04/Vue%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB/","excerpt":"一个App如果有好的动画效果可以为程序锦上添花，给用户留下非常好的印象；今天来学习下Vue的动画我们先重学transition；","text":"一个App如果有好的动画效果可以为程序锦上添花，给用户留下非常好的印象；今天来学习下Vue的动画我们先重学transition；首先看下animation与transition的区别：其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果1）动画不需要事件触发，过渡需要。2）过渡只有一组（两个：开始-结束） 关键帧，动画可以设置多个。 先来看个举个简单栗子1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img width=&quot;25%&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;button @click=&quot;toggleShow&quot;&gt; &lt;span v-if=&quot;isShowing&quot;&gt;Hide child&lt;/span&gt; &lt;span v-else&gt;Show child&lt;/span&gt; &lt;/button&gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;Close&lt;/button&gt; &lt;/app-child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./components/child&quot;;export default &#123; name: &quot;App&quot;, components: &#123; appChild: Child &#125;, data() &#123; return &#123; isShowing: false &#125;; &#125;, methods: &#123; toggleShow() &#123; this.isShowing = !this.isShowing; &#125; &#125;&#125;;&lt;/script&gt; demo中我们可以看到可以正常工作但是效果太僵硬 Vue中transitionVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 在Vue中有一个&lt;transition&gt;元素代表一个盒子，在这个盒子里我们处理元素或者组件上的动画效果。 &lt;transition&gt;是Vue已经封装好的一个组件，可以给任何元素和组件添加进入或离开过渡效果。12345 &lt;transition name=&quot;fade&quot;&gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;Close&lt;/button&gt; &lt;/app-child&gt;&lt;/transition&gt;现在，我们可以使用现成的 &lt;transition&gt; 组件。过渡钩子会添加 v- 前缀，我们可以在 CSS 中使用。其中 enter/leave 定义动画开始第一帧的位置， enter-active/leave-active 定义动画运行阶段—— 你需要把动画属性放在这里 enter-to/leave-to 指定元素在最后一帧上的位置。 我们不建议使用默认的v-前缀，正如你看到的我使用的是了一个 name 属性: name=&quot;fade&quot; 。属性名必须与动画效果名相近。 让我们创建下css样式 1234567.fade-enter-active, .fade-leave-active &#123; transition: opacity 0.25s ease-out;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125; 我将 .fade-enter和 .fade-leave-to属性设置为 opacity: 0 。这是动画的初始和结束位置，载入时的初始状态，卸载时的结束状态。你可能认为 .fade-enter-to 和 .fade-leave 应该设置 opacity: 1 。但是没有必要，因为它是组件的默认状态，所以这将是多余的。CSS 过渡和动画如果没有设置，总是会使用默认状态。 我们再优化下如果焦点都放在弹窗上，则背景是否需要虚化，如果把背景虚化则不能放在transition组件上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;[isShowing ? blurClass : &#x27;&#x27;, bkClass]&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt; &lt;span v-if=&quot;isShowing&quot;&gt;Hide child&lt;/span&gt; &lt;span v-else&gt;Show child&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;Close&lt;/button&gt; &lt;/app-child&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./components/child&quot;;export default &#123; name: &quot;App&quot;, components: &#123; appChild: Child &#125;, data() &#123; return &#123; isShowing: false, bkClass: &quot;bk&quot;, blurClass: &quot;blur&quot; &#125;; &#125;, methods: &#123; toggleShow() &#123; this.isShowing = !this.isShowing; &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.fade-enter-active,.fade-leave-active &#123; transition: opacity 2s ease-out;&#125;.fade-enter,.fade-leave-to &#123; opacity: 0;&#125;.bk &#123; transition: all 2s ease-out;&#125;.blur &#123; filter: blur(2px); opacity: 0.4;&#125;&lt;/style&gt; 需要注意这里需要注意的一点是，Vue只能对中的一个元素进行动效处理。相反，在任何给定的实例中，只能将&lt;transition&gt;中的一个元素插入到DOM中。比如下同这个示例，在Vue中无法正常的工作：12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;[isShowing ? blurClass : &#x27;&#x27;, bkClass]&quot;&gt; &lt;img width=&quot;25%&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;button @click=&quot;toggleShow&quot;&gt; &lt;span v-if=&quot;isShowing&quot;&gt;Hide child&lt;/span&gt; &lt;span v-else&gt;Show child&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot; key=&quot;info&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;Close&lt;/button&gt; &lt;/app-child&gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot; key=&quot;error&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;Close&lt;/button&gt; &lt;/app-child&gt; &lt;/transition&gt; &lt;/div&gt; 在Vue中中有多个元素需要有动效效果时，需要使用来替代，不然在Vue中则会报错。 另外，在中有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践。 在Vue中提供了两种过渡模式来解决一个离开过渡的时候另一个开始进入过渡。其实这也是的默认行为，即进入和离开同时发生的问题 in-out：新元素先进行过渡，完成之后当前元素过渡离开 out-in：当前元素先进行过渡，完成之后新元素过渡进入 123456789101112131415&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; appear-active-class=&quot;custom-appear-active-class&quot; &gt; &lt;app-child v-if=&quot;isShowing&quot; class=&quot;modal&quot; key=&quot;info&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;显示&lt;/button&gt; &lt;/app-child&gt; &lt;app-child v-else=&quot;!isShowing&quot; class=&quot;modal&quot; key=&quot;error&quot;&gt; &lt;button @click=&quot;toggleShow&quot;&gt;离开&lt;/button&gt; &lt;/app-child&gt; &lt;/transition&gt; css样式 1234567.custom-appear-class &#123; opacity: 0; transform: translateX(100%); //进场效果&#125;.custom-appear-active-class &#123; transition: 2s;&#125; 列表过渡123456789&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; 123456789101112131415161718new Vue(&#123; el: &#x27;#list-demo&#x27;, data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;) 123456789101112.list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-to/* .list-leave-active for below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125; 参考大漠","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue中的vuex","slug":"Vue中的vuex","date":"2019-03-02T16:00:00.000Z","updated":"2020-09-16T09:07:57.000Z","comments":true,"path":"2019/03/03/Vue中的vuex/","link":"","permalink":"http://mariogogogo.github.io/2019/03/03/Vue%E4%B8%AD%E7%9A%84vuex/","excerpt":"当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。","text":"当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。然后就出现了一个神器vuex 什么是vuex呢？Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。 大白话：多个组件之间共用一份数据 vuex的核心vuex由以下几部分组成： state mutations getters actions modules 开始写来个最简单的demostore.js12345678910111213141516171819202122232425262728import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);const state = &#123; count: 1&#125;;const mutations = &#123; increment(state) &#123; state.count++; &#125;, decrement(state) &#123; state.count--; &#125;&#125;;const actions = &#123; increment: (&#123; commit &#125;) =&gt; &#123; commit(&quot;increment&quot;); &#125;, decrement: (&#123; commit &#125;) =&gt; &#123; commit(&quot;decrement&quot;); &#125;&#125;;export default new Vuex.Store(&#123; state, mutations, actions &#125;);1.每一个Vuex应用就是一个store，在store中包含组件中的共享状态state和改变状态的方法mutations。注意：只能通过mutations改变store的state的状态；2.使用commit方法触发mutations改变state: 导入跟组件app.vue123456789import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;new Vue(&#123; store, //导入全局store数据 render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); Getters 可以在模板中静态的显示数据。换句话说，getters 可以读取数据，但不能改变状态。 Mutations 允许更新状态，但永远是同步的。Mutations 是 store 中改变状态数据的唯一方式。 Actions 允许异步更新状态，但是需要使用一个已经存在的 mutation 。如果你需要以特定的顺序同时执行不同的 mutations 会非常有用。 使用vuexvuex.vue123456789101112131415&lt;template&gt; &lt;div&gt; vuex ,&#123;&#123; $store.state.count &#125;&#125; &lt;button type=&quot;button&quot; @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button type=&quot;button&quot; @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions &#125; from &quot;vuex&quot;;export default &#123; name: &quot;vuex&quot;, methods: mapActions([&quot;increment&quot;, &quot;decrement&quot;])&#125;;&lt;/script&gt; 进阶让我们在深入一点如果我们要向action传入参数怎么办？ 最后在拿一个项目中的栗子来说说我对vuex的使用 先来看下如何合理的构建store数据结构首先创建state.js对需要管理的数据初始化一些值，对应一些比较复杂的数据还可以调用方法执行。12345678910111213141516171819/** * 单一状态树 * vuex 操作顺序：state.js -&gt; mutations-type.js -&gt; mutations.js -&gt; getters.js */import &#123; getPlayHistory &#125; from &quot;../utils/index&quot;;const playMode = &#123; sequence: 0, // 顺序播放 loop: 1, // 单曲循环 random: 2 // 随机播放&#125;;const state = &#123; mode: playMode.sequence, playing: false, playlist: [&quot;发如雪&quot;, &quot;东风破&quot;, &quot;双节棍&quot;], song: &quot;周杰伦&quot;, playHistory: getPlayHistory()&#125;;export default state;然后创建mutation-type.js，用mutation 常量，注意目的是为了代码规范，易于出错排查1234567//播放模式export const SET_MODE = &quot;SET_MODE&quot;;//播放状态export const SET_PLAYING_STATE = &quot;SET_PLAYING_STATE&quot;;//播放列表export const SET_PLAYLIST = &quot;SET_PLAYLIST&quot;;接着我们创建mutation.js12345678910111213import * as types from &quot;./mutations-type.js&quot;;const mutations = &#123; [types.SET_MODE](state, mode) &#123; state.mode = mode; &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag; &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playlist = list; &#125;&#125;;export default mutations;随后在创建actions.js,用于数据的state的逻辑处理。1234567891011121314151617181920212223// 根级别的 actionimport * as types from &quot;./mutations-type&quot;;/**\\ * &#123;commit.state&#125; 内置状态 * song 传入的参数 */export const insertSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice(0); playlist = [...playlist, &quot;爸我回来了&quot;, &quot;牛仔很忙&quot;].concat(song); commit(types.SET_PLAYLIST, playlist); commit(types.SET_PLAYING_STATE, true); // commit(types.SET_MODE, 1);&#125;;export const removeSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice(0); playlist.slice(0, 1); commit(types.SET_PLAYLIST, playlist); commit(types.SET_PLAYING_STATE, false); commit(types.SET_MODE, 2);&#125;;别忘记了set有了 还需要get获取，所以我们创建getters.js12345678// 映射及计算export const playing = state =&gt; state.playing;export const playlist = state =&gt; state.playlist;export const mode = state =&gt; state.mode;export const song = state =&gt; state.song;最后设置index.js的入口文件12345678910111213141516171819202122// 组装模块并导出 store 的地方import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;import state from &quot;./state.js&quot;;import mutations from &quot;./mutations.js&quot;;import * as actions from &quot;./actions.js&quot;;import * as getters from &quot;./getters.js&quot;;import createLogger from &quot;vuex/dist/logger&quot;; // Vuex 自带一个日志插件用于一般的调试Vue.use(Vuex);const debug = process.env.NODE_ENV !== &quot;production&quot;;export default new Vuex.Store(&#123; state, mutations, actions, getters, strict: debug, plugins: debug ? [createLogger()] : []&#125;);别忘记app中的全局导入storemain.js123456789import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store/index&quot;;Vue.config.productionTip = false;new Vue(&#123; render: h =&gt; h(App), store&#125;).$mount(&quot;#app&quot;); 使用1234567891011121314151617181920212223&lt;script&gt;import &#123; mapMutations, mapActions, mapGetters &#125; from &quot;vuex&quot;; //导入vuex模块方法export default &#123; name: &quot;pagea&quot;, methods: &#123; ...mapMutations(&#123; setMode: &quot;SET_MODE&quot;, setPlayList: &quot;SET_PLAYLIST&quot; &#125;), ...mapActions([&quot;insertSong&quot;, &quot;removeSong&quot;]), add() &#123; this.setMode(1); this.insertSong(&quot;你比从前快乐&quot;); &#125; &#125;, computed: &#123; ...mapGetters([&quot;mode&quot;, &quot;song&quot;, &quot;playlist&quot;]), playstatus() &#123; return this.song; &#125; &#125;&#125;;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"PM2一键发布网站适合React Vue Node","slug":"PM2一键发布网站，适合React Vue Node","date":"2019-03-01T16:00:00.000Z","updated":"2020-09-16T09:07:44.000Z","comments":true,"path":"2019/03/02/PM2一键发布网站，适合React Vue Node/","link":"","permalink":"http://mariogogogo.github.io/2019/03/02/PM2%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%EF%BC%8C%E9%80%82%E5%90%88React%20Vue%20Node/","excerpt":"为什么要研究Pm2？","text":"为什么要研究Pm2？当你的项目每次都要改动时，本地改完，push到仓库内，再从服务器pull下来，重新build，再采用如上的各种方法。这样无形之中就加大了时间成本，因而我的解决方法时采用pm2的自动化部署方法，来实现本地一键部署到服务器。 首先你要确保你本地/服务器/Github上实现了无密登录 具体流程12345678910111213141516171819//1.看你有没有.ssh的文件。cd ~/.ssh//2.没有则需要创建一个。mkdir ~/.ssh//3.生成一个证明（默认会生成id_rsa和id_rsa.pub，如果你之前有生成这两个文件，现在就不需要再生成了，可以复用的，而且新生成的id_rsa和id_rsa.pub还会覆盖掉原来的，特别是连着公司的svn和git的一些，最好不要再生成了）ssh-keygen -t rsa//4.将证明复制到阿里云的虚拟机首先需要进入到.ssh目录cd ~/.sshscp id_rsa.pub chan@IP地址:~/.ssh/id_rsa.pub//5.将证书写入到authorized_keys（这样就能保证不输入密码登入）登入自己的虚拟机ssh root@IP地址cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys//6.销毁之前的证书就行rm id_rsa.pubexit//好了，现在你就可以不用输入密码就登入到你的阿里云虚拟机了。 配置服务器上的文件夹权限12345sudo mkdir /testcd /testsudo mkdir production#修改权限,先切换到testsudo chmod 777 production 配置你的项目在根目录添加ecosystem.json123456789101112131415161718192021222324252627&#123;&quot;apps&quot;:&#123; &quot;name&quot;:&quot;项目名称&quot;, &quot;script&quot;:&quot;index.js&quot;, &quot;env&quot;:&#123; &quot;COMMON_VARIABLE&quot;:&quot;true&quot; &#125;, &quot;env_production&quot;:&#123; &quot;NODE_ENV&quot;:&quot;production&quot; &#125;&#125;,&quot;deploy&quot;:&#123; &quot;production&quot;:&#123; &quot;user&quot;:&quot;服务器登录账号不要用root&quot;, //服务器名称 比如 chan &quot;host&quot;:[&quot;192.168.2.31&quot;], //服务器ip &quot;port&quot;:&quot;22&quot; //服务器端口 &quot;ref&quot;:&quot;origin/master&quot;, &quot;repo&quot;:&quot;http://git仓库地址&quot;, &quot;path&quot;:&quot;/test/production&quot;, //项目目录 &quot;ssh_options&quot;:&quot;StrictHostKeyChecking=no&quot;, &quot;post-deploy&quot;:&quot;yarn &amp;&amp; yarn build &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;, //执行操作 &quot;env&quot;:&#123; &quot;NODE_ENV&quot;:&quot;production&quot; &#125; &#125; &#125;&#125; 注意踩过的坑： 然后输入 1source ~/.bashrc 代码 第一次部署在本地iterm中输入 12pm2 deploy ecosystem.json production setup//此时会在服务器 /www/test/production新建三个目录 第二次以后可以输入1pm2 deploy ecosystem.json production即发布成功。 按照上述步骤操作，就可以实现利用pm2本地部署项目到服务器，这样就省掉了登入服务器取更新代码的步骤了。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"Vue中的slot","slug":"Vue中的slot","date":"2019-03-01T16:00:00.000Z","updated":"2020-09-16T09:07:57.000Z","comments":true,"path":"2019/03/02/Vue中的slot/","link":"","permalink":"http://mariogogogo.github.io/2019/03/02/Vue%E4%B8%AD%E7%9A%84slot/","excerpt":"在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除","text":"在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除 Slot的通俗理解是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中位置），当插槽也就是坑有命名时，组件标签中使用属性slot=”mySlot”的元素就会替换该对应位置内容； 单个插槽看单个插槽，即没有在标签中显式的设置name值。比如SlotDemo这个组件，而且在slot标签中提供了一个默认的内容。我们在使用该组件时，可以通过v-slot:default来调用未显式设置name的slot：一个不带name的出口会带有隐含的名字default slotdemo.js1234567891011&lt;template&gt; &lt;div class=&quot;slot-demo&quot;&gt;&lt;slot&gt;单个插槽&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// export default &#123;// name: &quot;slotdemo&quot;// &#125;;//&lt;/script&gt;helloword.vue 123456789101112131415&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;p&gt;Hello Vue in CodeSandbox!&lt;/p&gt; &lt;h3&gt;Learn slot&lt;/h3&gt; &lt;slot-demo&gt;&lt;/slot-demo&gt; &lt;p&gt;=============&lt;/p&gt; &lt;slot-demo&gt; &lt;template v-slot:default&gt; &lt;p&gt;v-slot:defatult 的使用&lt;/p&gt; &lt;/template&gt; &lt;/slot-demo&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽layout.vue1234567891011121314151617&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt; &lt;p&gt;header&lt;/p&gt; &lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt; &lt;p&gt;middler&lt;/p&gt; &lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt; &lt;p&gt;footer&lt;/p&gt; &lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;!--不用写name--&gt;&lt;script&gt;// export default &#123;// name: &quot;layout&quot;// &#125;;&lt;/script&gt;helloword.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;p&gt;Hello Vue in CodeSandbox!&lt;/p&gt; &lt;h3&gt;Learn slot&lt;/h3&gt; &lt;slot-demo&gt;&lt;/slot-demo&gt; &lt;p&gt;=============&lt;/p&gt; &lt;slot-demo&gt; &lt;template v-slot:default&gt; &lt;p&gt;v-slot:defatult 的使用&lt;/p&gt; &lt;/template&gt; &lt;/slot-demo&gt; &lt;p&gt;=============&lt;/p&gt; &lt;slot-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;这里有头部&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;这里是底部&lt;/p&gt; &lt;/template&gt; &lt;/slot-layout&gt; &lt;/div&gt;&lt;/template&gt; 注意 v-slot 只能添加在一个&lt;template&gt; 上 作用域插槽slotlist.vue 123456789101112131415161718&lt;template&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt; &lt;slot v-bind:item=&quot;item&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;list&quot;, props: &#123; items: &#123; type: Array &#125; &#125;&#125;;&lt;/script&gt; helloword.vue12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;p&gt;=============&lt;/p&gt; &lt;List :items=&quot;colors&quot; v-slot=&quot;color&quot;&gt; &lt;/List&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import SlotDemo from &quot;../slot/slotdemo.vue&quot;;import List from &quot;../slot/list.vue&quot;;export default &#123; name: &quot;HelloWorld&quot;, components: &#123; SlotDemo, List &#125;, data() &#123; return &#123; colors: [ &#123; name: &quot;Yellow&quot;, hex: &quot;#F4D03F&quot; &#125;, &#123; name: &quot;Green&quot;, hex: &quot;#229954&quot; &#125;, &#123; name: &quot;Purple&quot;, hex: &quot;#9B59B6&quot; &#125; ] &#125;; &#125;, props: &#123; msg: String &#125;&#125;;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Javascript 设计模式之备忘录模式","slug":"Javascript设计模式之备忘录模式","date":"2019-02-28T16:00:00.000Z","updated":"2020-09-16T09:07:34.000Z","comments":true,"path":"2019/03/01/Javascript设计模式之备忘录模式/","link":"","permalink":"http://mariogogogo.github.io/2019/03/01/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"备忘录模式:在不破坏对象的封装特性的前提下,在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态","text":"备忘录模式:在不破坏对象的封装特性的前提下,在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态 我们在做列表页请求的时候进行会遇到上一页数据与下一页数据之间的交互. 12345678910111213141516//下一页按钮点击事件$(&amp;#39;#next page&amp;#39;).click(function() &#123; //获取新闻内容元素 var $news = $(&amp;quot;#news content&amp;quot;)， //获取新闻内容元素当前页数据 page = $news.data(&amp;#39;page&amp;#39;); //获取并显示新闻 getPageData(page, function() &#123; //修正新闻内容元素当前页数据 $news.data(&amp;#39;page&amp;#39;, page + 1) &#125;)&#125;);//1上一页按钮点击事件$(#pre page &amp;#39;).click (function() &#123;//显示上一页&#125;) getPageData 是一个异步请求 123456789101112131415function getPageData (page,fn)&#123; $.post(&amp;#39;./data/getNewsData.php&amp;#39;,&#123; page:page &#125;,function(res) &#123; if(res.errNo == 0 )&#123; showPage(page,res.data) fn &amp;&amp; fn() &#125; &#125;)&#125;//显示某页逻辑function showPage(page,data) &#123; // body...&#125; 这么处理看起来无可厚非,不过对于用户点击下一页后,又点击上一页这种浏览行为是不是感觉第二次请求是多余的?因为第一次你已经获取了数据,不需要再多发一次请求,如果用户网速不好,那对于用户来说,体验是糟糕的.手机端流量也是一种浪费 缓存数据123456789101112131415161718192021222324252627282930313233343536//page备忘录类var Page = function() &#123; //信息缓存 var cache = &#123;&#125; /* 主函数 参数page页码 */ return function(page, fn) &#123; //判断该页数据是否在缓存中 if (cache[page]) &#123; //恢复到该页状态，显示该页内容 showPage(page, cache[page]); //执行成功回调函数 fn &amp;&amp; fn(); &#125; else &#123; //若缓存Cache中无该页数据 $.post(&amp;#39;./data/getNewsData.php&amp;#39;, &#123; //请求携带数据page页码 page: page &#125;，function(res) &#123; // 成功返回 if (res.errNo == 0) &#123; //显示该页数据 showPage(page, res.data); //将该页数据种入缓存中 cache[page] = res.data; //执行成功回调函数 fn &amp;&amp; fn(); &#125; else &#123; //处理异常 &#125; &#125;) &#125; &#125;&#125; page 缓存器与 getPageData 方法不同之处在 Page 类的内部缓存了每次请求回来的新闻数据,以后用户会看某页面新闻数据,就不必要重新请求了. 123456789101112//下一页按钮点击事件$(&amp;#39;#next page&amp;#39;).click(function() &#123; //T获取新闻内容元素 var $news = $(&amp;quot;#news content&amp;quot;)， //获取新闻内容元素当前页数据 page = $news.data(&amp;#39;page&amp;#39;); //获取并显示新闻 Page(page, function() &#123; //修正新闻内容元素当前页数据 $news.data(&amp;#39;page&amp;#39;, page + 1) &#125;)&#125;); 总结备忘录模式最主要的任务就是对现有的数据或者状态做缓存,从而降低对数据的获取成本","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Vue中的Mixins","slug":"Vue中的Mixins  ","date":"2019-02-28T16:00:00.000Z","updated":"2020-09-16T09:07:57.000Z","comments":true,"path":"2019/03/01/Vue中的Mixins  /","link":"","permalink":"http://mariogogogo.github.io/2019/03/01/Vue%E4%B8%AD%E7%9A%84Mixins%20%20/","excerpt":"混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。","text":"混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 学了vue几个月时间做了几个小项目，mixin真的很少用，但挺重要的希望做点笔记记录下 在项目开发的时候，常会碰到这样的一种现象：有两个组件非常相似，比如较为熟悉的Modal、Tooltip，它们都具有同样的基本函数，而且它们之前也有足够的不同。很多时候，就让人很难做出选择：是把它们拆会成多个不同的组件呢？还是只使用一个组件，创建足够的属性来改变不同的情况。所有请出了今天我们的猪角Minxins. mixins为我们提供了在Vue组件中共用功能的方法。使用方式很简单，将共用的功能以对象的方式传入mixins选项中。当组件使用mixins对象时，所有mixins对象的选项都将被混入该组件本身的选项目 如何使用？1234567891011const myMinxin= &#123; created()&#123; console.log(`我来自minxin`) &#125;&#125;let app = new Vue(&#123; el:&quot;#app&quot;, mixins:[myMixin]&#125;) 更规范的使用创建一个minxin的文件夹中放minxins.js文件 123456789import &#123; myMixin &#125; from &quot;../mixin/mixins.js&quot;;export default &#123; mixins: [myMixin], name: &quot;HelloWorld&quot;, props: &#123; msg: String &#125;&#125;; 还可以引入多个minxins，一旦引入都会被使用123456789import &#123; myMixin，myMinxin2 &#125; from &quot;../mixin/mixins.js&quot;;export default &#123; mixins: [myMixin,myMinxin2], name: &quot;HelloWorld&quot;, props: &#123; msg: String &#125;&#125;; 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。 默认是mixins上会首先被注册，组件上的接着注册！ 在Vue中mixins常见的合并主要有三种情形：数据data、生命周期中的钩子函数和值为对象的选项 数据合并123456789101112131415161718&lt;script&gt;import &#123; mixdata, mindataAnother &#125; from &quot;../mixin/mixins.js&quot;;export default &#123; mixins: [mixdata, mindataAnother], name: &quot;HelloWorld&quot;, data() &#123; return &#123; msg: &quot;来自组件自身&quot;, name: &quot;vue&quot;, age: &quot;22&quot; &#125;; &#125;, created() &#123; console.log(this.$data); &#125;&#125;;&lt;/script&gt; 结论：数据对象在内部分进行浅合并（一层属性深度），在和组件的数据发生冲突时，以组件数据优先。 钩子函数合并123456789101112131415export default &#123; mixins: [myMixin, myMixin2], name: &quot;HelloWorld&quot;, data() &#123; return &#123; msg: &quot;来自组件自身&quot;, name: &quot;vue&quot;, age: &quot;22&quot; &#125;; &#125;, created() &#123; console.log(&quot;来自组件的方法&quot;); &#125;&#125;; 结论：当组件使用的mixins对象有相同的选项时，比如钩子函数，就会全部被合并到一个数组中，因此都会被执行，并且mixins对象中的钩子会先被执行。 值为对象的选项合并123456789101112131415161718192021 export default &#123; mixins: [myMixin], name: &quot;HelloWorld&quot;, data() &#123; return &#123; msg: &quot;来自组件自身&quot;, name: &quot;vue&quot;, age: &quot;22&quot; &#125;; &#125;, methods: &#123; message() &#123; console.log(this.msg); &#125; &#125;, created() &#123; console.log(&quot;来自组件的方法&quot;); // console.log(this.$data); &#125;&#125;; 结论：当mixins对象和组件中的选项的值为对象时，比如methods、components和directives，将被混合为同一个对象。当两个对象键名冲突时，组件选项优先。 全局Mixins使用起来要非常小心，不到万不得已不要轻易去使用它； 12345Vue.mixin(&#123; mounted() &#123; console.log(&#x27;hello from mixin!&#x27;) &#125; &#125;) new Vue(&#123; ... &#125;) 总结： 混合对于封装一小段想要复用的代码来讲是有用的。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"JAVASCRIPT设计模式之状态模式","slug":"Javascript设计模式之状态模式","date":"2019-02-27T16:00:00.000Z","updated":"2020-09-16T09:07:37.000Z","comments":true,"path":"2019/02/28/Javascript设计模式之状态模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/28/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"状态模式:解决程序中一些臃肿的分支判断语句问题，每一个分支转化为一种独立的状态，方便每一种状态的管理不至于每次只需遍历所有分支，最终目的是为了简化分支判断流程","text":"状态模式:解决程序中一些臃肿的分支判断语句问题，每一个分支转化为一种独立的状态，方便每一种状态的管理不至于每次只需遍历所有分支，最终目的是为了简化分支判断流程如果有一个需求：投票最美图片征集活动，如果我们将所有图片的结果展示一遍，内部免不了有多个分支判断： 123456//展示结果function showResult = (result)&#123;if(result === 0)&#123;console.log(&#x27;处理结果0&#x27;)&#125;，else if(result === 1)&#123;console.log(&#x27;处理结果1&#x27;)&#125;，else if(result === 2)&#123;console.log(&#x27;处理结果2&#x27;)&#125;，else if(result === 3)&#123;console.log(&#x27;处理结果3&#x27;)&#125;， 如果某天需求要增加或减少处理就比较麻烦 状态对象的实现如果我们将不同的判断结果封装在状态对象内，然后改状态返回一个可被调用的结构方法，用于调用状态对象内部某种方法。 12345678910111213141516171819202122//投票结果状态对象var ResultState = function()&#123; var States = &#123; state0:function()&#123; console.log(&#x27;处理结果0&#x27;) &#125;, state1:function()&#123; console.log(&#x27;处理结果1&#x27;) &#125;, state2:function()&#123; console.log(&#x27;处理结果2&#x27;) &#125;, &#125; function show(result)&#123; //如果方法存在则执行 States[&#x27;state&#x27;+result] &amp;&amp; States[&#x27;state&#x27;+result]() &#125; return &#123; //返回调用状态方法接口 show:show &#125;&#125; 使用 1ResultState.show(3) 状态模式的目的：将条件判断不同的结果转化为状态对象的内部状态。既然是内部状态一般就是私有变量，私有方法，便于我们增删改查。 状态的优化我们首先创建一个状态对象，内部保存状态变量，内部封装好每种动作对应的状态，最后状态对象返回一个接口对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//创建一个游戏状态类var HeroState = function () &#123; //内部状态私有变量 var _currentState = &#123;&#125;; //动作与状态方法映射 var states = &#123; jump: function () &#123; console.log(&#x27;跳跃&#x27;) &#125;, move: function () &#123; console.log(&#x27;移动&#x27;) &#125;, shoot: function () &#123; console.log(&#x27;射击&#x27;) &#125;, squat: function () &#123; console.log(&#x27;蹲下&#x27;) &#125; &#125; //动作控制类 var Action = &#123; //改变状态方法 changeState: function () &#123; var arg = arguments; //重置内部状态 _currentState = &#123;&#125;; if (arg.length) &#123; //遍历动作 for (var i = 0, len = arg.length; i &lt; len; i++) &#123; _currentState[arg[i]] = true; &#125; &#125; //返回动作控制类 return this; &#125;, //执行动作 goes: function () &#123; console.log(&#x27;触发一次动作&#x27;); for (const key in _currentState) &#123; states[key] &amp;&amp; states[key]() &#125; return this; &#125; &#125; return &#123; change: Action.changeState, goes : Action.goes &#125;&#125;使用123//创建一个超级角色var hero = new HeroState();hero.change(&#x27;jump&#x27;,&#x27;shoot&#x27;).goes().goes()","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Javascript设计模式之迭代器模式","slug":"Javascript设计模式之迭代器模式","date":"2019-02-21T16:00:00.000Z","updated":"2020-09-16T09:07:34.000Z","comments":true,"path":"2019/02/22/Javascript设计模式之迭代器模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/22/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"迭代器模式是 ：在不暴露内部结构的同时，可以顺利的访问聚合对象内部的元素","text":"迭代器模式是 ：在不暴露内部结构的同时，可以顺利的访问聚合对象内部的元素 首先为什么要使用迭代器？我们举一个例子看看 12345678910111213141516171819//开发过程中经常碰到这样的循环数据var array = [1, 2, 3]var nodeList = document.getElementsByTagName(&quot;p&quot;);var $p = $(&#x27;p&#x27;);//要对三个变量进行遍历要写写三种方法array.forEach(function (item) &#123; console.log(item)&#125;)var i, len = nodeList.length;for (i = 0; i &lt; len; i++) &#123; console.log(nodeList[i])&#125;$p.each(function (key, p) &#123; console.log(key, p)&#125;) 结果 写三遍烦不烦？ 如何优化呢？使用迭代器试试吧？ 写一个迭代器方法12345678910111213141516171819202122232425262728293031323334353637class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; //没有下一项 return null &#125; hasNext() &#123; if (this.index &gt;=this.list.length) &#123; return false &#125; return true &#125;&#125;// 兼容es6中所有有序数据结构class Container&#123; constructor(list)&#123; this.list = list &#125; //生成遍历器 getIterator()&#123; return new Iterator(this) //传this指向Container &#125;&#125;let arr = [1,2,3];let container = new Container([1,2,3]);let iterator = container.getIterator();while (iterator.hasNext()) &#123; console.log(iterator.next())&#125; 在jquery中的引用场1234567891011function each(data) &#123; var $data = $(data); //生成迭代器 $data.each(function (key,p) &#123; console.log(key,p); &#125;)&#125;//testeach(arr)each(nodeList)each($p) for..of的写法也属于迭代器的一种 1234567891011121314151617181920// ================在iterator中的引用场景=================// data要属于[Symbol.iterator]属性function eachSyiter(data) &#123; for (const item of data) &#123; console.log(item); &#125;&#125;//等同于下面的写法function eachSyiter(params) &#123; //生成遍历器 let iterator = data[Symbol.iterator]; let item = &#123;done:false&#125; while (!item.done) &#123; item = iterator.next() if(!item.done)&#123; console.log(item.value); &#125; &#125;&#125; 最后再举个小栗子用个迭代器思想解决实际开发过程中的问题 1234567891011121314151617181920212223242526272829303132//迭代器var Iterator_mode = function (item, container) &#123; //获取父容器 var container = container &amp;&amp; document.getElementById(container) || document; //获取元素 var items = container.getElementsByTagName(items); //获取元素长度 var length = items.length; //当前元素索引 var index = 0; //缓存原来数组的方法 === 浅复制一份副本 var splice = items.splice(0); return &#123; //第一个 first: function () &#123;&#125;, //最后个 last: function () &#123;&#125;, //前一个 prev: function () &#123;&#125;, //后一个 next: function () &#123;&#125;, //获取某一个元素 get: function () &#123;&#125;, //对每一个元素执行某一个方法 dealEach: function () &#123;&#125;, //对某一个元素执行某一个方法 dealItem: function () &#123;&#125;, //排它方式处理某一个元素 exclusive: function () &#123;&#125; &#125;&#125; 使用123456789101112// 使用var demo = new Iterator_mode(&quot;li&quot;, &#x27;container&#x27;);console.log(demo.first());console.log(demo.last());console.log(demo.next());console.log(demo.get(2000));//处理所有元素demo.dealEach(function(text,color) &#123; this.innerHTML = text; this.style.background = color;&#125;,&#x27;test&#x27;,&#x27;pink&#x27;) 这种思想的好处：迭代器提供的接口方法就能轻易的访问聚合对象中的每一个对象，甚至不需要知道聚合对象内部的具体结构 实现下上面迭代器的各个功能点：first 1234first:function()&#123; index = 0; return items[index];&#125; last 1234last:function()&#123; index = length-1; return items[index];&#125; pre 12345678pre:function()&#123; if(--index&gt;0)&#123; return items[index] &#125;else&#123; index = 0 return null &#125;&#125; next12345678next:function()&#123; if(++index &lt; length)&#123; return items[index] &#125;else&#123; index = length -1 return null &#125;&#125;get12345get:function(num)&#123; //如果num大于等于0 再获取正向获取，否则逆向获取 index = num &gt;= 0 ? num%length : num%length+length; return items[index];&#125;dealEach1 数组迭代器比如低版本浏览器不能很好的支持each方法，我们就要用到数组迭代器，它把元素的索引和索引值传入回调函数中 12345678910111213var eachArray = function(arr,fn)&#123; var i = 0, len = arr.length; //遍历数组 for (;i &lt; len;i++) &#123; //以此执行回调函数，注意回调函数中传入参数第一个为索引, //第二个是索引值 if(fn.call(arr[i],i,arr[i]) === false) &#123; break; &#125; &#125;&#125; 对象迭代器12345678var eachObject = function(obj,fn) &#123; for(var i in obj)&#123; if(fn.call(obj[i],i,obj[i]) === false)&#123; break; &#125; &#125;&#125; 同步变量迭代器我们在页面同步变量内某些属性值时，我们不知道服务端将该属性或者该属性的上顺序打印到页面上，我们不能用点语法或者[]语法直接导致错误，因此需要一层一层的去安全校验。 1234var a = &#123;&#125;var c = a &amp;&amp; a.b &amp;&amp; a.b.c; 使用迭代器来校验代码数据12345678910111213141516171819202122bGetter = function(key) &#123; //如果b不存在则直接返回未定义 if(!b) return undefined; var result = b; //获取同步b的对象 key = key.split(&#x27;.&#x27;); //解析属性的层次序列 //迭代同步变量b对象属性 for (let i = 0, len=key.length; i &lt; len; i++) &#123; if(result[key[i]] != undefined)&#123; result = result[key[i]] &#125;else&#123; return undefined &#125; &#125; //返回获取结果 return result;&#125;//获取用户信息console.log(bGetter(&quot;client.user.username&quot;)); //轻舞飞扬//获取本地语言数据console.log(bGetter(&quot;server.lang.local&quot;)); //undefined如果有时候用户数据在主页会添加一些或修改一些数据 也可以通过同步变量赋值器来实现 1234567891011121314151617181920212223242526bSetter = function (key,val) &#123; //如果b不存在则直接返回未定义 if (!b) return undefined; var result = b; key = key.split(&#x27;.&#x27;); //迭代同步变量b对象属性 for (var i = 0, len = key.length; i &lt; len; i++) &#123; //如果第i层属性对应的值不存在，则定义为对象 if (result[key[i]] === undefined) &#123; result[key[i]] = &#123;&#125; &#125; //如果第i层属性对应的值不是对象的一个实例，则抛出错误 if(!result[key[i]] instanceof Object)&#123; throw new Error(&#x27;b&#x27;+ key.splice(0,i+1).join(&quot;.&quot;)+&quot;is not object&quot;); return false &#125; //迭代改层的属性值 result = result[key[i]] &#125; //返回获取结果 return result[key[i]] = val;&#125;//获取用户信息console.log(bSetter(&quot;client.module.news.sports&quot;,&quot;javascript&quot;)); //轻舞飞扬","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Javascript设计模式之链模式","slug":"Javascript设计模式之链模式","date":"2019-02-21T16:00:00.000Z","updated":"2020-09-16T09:07:36.000Z","comments":true,"path":"2019/02/22/Javascript设计模式之链模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/22/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"很早之前一直想读一下jquery或者zepto的源码，但读源码之前还是得先了解下上面是链模式；因为源码的框架都是基于这个链模式","text":"很早之前一直想读一下jquery或者zepto的源码，但读源码之前还是得先了解下上面是链模式；因为源码的框架都是基于这个链模式 链模式：通过对象方法中将当前对象返回，实现同一个对象多个方法的链式调用，从而简化该对象多个方法的多次调用，对该对象的多次引用。 说白了这些都是基于原型继承 123456789var A = function()&#123;&#125;A.prototype = &#123; length:2, size:function()&#123; return this.length &#125;&#125; 如果我们想访问size方法该如何做？ 123var a = new A();console.log(a.size()) //2 但有没有想过如果这样访问 12console.log(A.size()) //报错console.log(A().size()) //报错 为什么报错？ 第一种因为size绑定在原型上没有绑定在自己身上 第二种A函数对应执行结果没有返回值找不到size方法 找位小助手12345678910111213var A = function()&#123; return A.fn&#125;var A.fn = A.prototype = &#123; length:2, size:function()&#123; return this.length &#125;&#125;//testconsole.log(A.fn);console.log(A().size()); 获取元素但是我们希望A.fn能提供获取元素方法的init然后再A中返回123456789101112131415161718// a.fn方法中提供init用来获取元素然后返回var A = function (selector) &#123; return A.fn.init(selector)&#125;A.fn = A.prototype = &#123; length: 2, size : function () &#123; return this.length &#125;, init: function (selector) &#123; return document.getElementById(selector) &#125;&#125;//testconsole.log(A(&#x27;demo&#x27;)); 还遇到个大问题，我们还希望返回结果能够拥有A.fn中的很多方法如何办到呢？ this大法好！this指向的一个对象，对象又可以设置属性那我们把this对象设置成当前对象的一个属性不就可以了嘛~~~O(∩_∩)O 12345678910111213141516171819202122232425// 一个问题如何访问元素的同时，又能访问对象中的方法var A = function (selector) &#123; return A.fn.init(selector)&#125;A.fn = A.prototype = &#123; length: 2, size : function () &#123; console.log(&#x27;sizefn &#x27;,this); return this.length &#125;, init: function (selector) &#123; console.log(&#x27;initfn &#x27;,this); //fn this[0] = document.getElementById(selector) this.length = 1; return this; //返回this &#125;&#125;//testvar demo = A(&#x27;demo&#x27;);console.log(demo);console.log(demo.size());//2 还是会碰到一个问题如果被覆盖 12var test = A(&#x27;test&#x27;)console.log(demo); 原因是：A构造函数每次return返回A.fn.init对象都指向同一个对象；所以那我们加上一个new 但是还是会碰到一个问题调用size方法就会报错 123456789101112//构造函数指向同一个对象造成的var A = function (selector) &#123; return new A.fn.init(selector)&#125;var demo = A(&#x27;demo&#x27;);console.log(demo);var test = A(&#x27;test&#x27;)console.log(demo); console.log(&#x27;==============&#x27;);console.log(demo.size()); //为什么报错 new之前 new之后 原因：由于new对对象内的属性进行了复制，所以this指向不在是A.fn、A.prototype 而是A.fn.A.init呢？ 原型构造函数中的方法是在构造函数new关键词指向时才能被构造函数获取，所以平时构造函数是获取不到原型对象上的方法的 防止方法丢失new A.fn.init(selector)中的init中的this为什么指向 A.fn.A.init???? 123456789101112131415161718192021222324252627282930//构造函数指向同一个对象造成的var A = function (selector) &#123; return new A.fn.init(selector)&#125;A.fn = A.prototype = &#123; constructor: A, init : function (selector) &#123; console.log(this.constructor); /** ƒ(selector) &#123; return new A.fn.init(selector) &#125; */ &#125;, length: 2, size : function () &#123; return this.length &#125;, &#125;//这句非常重要A.fn.init.prototype = A.fn; //testvar demo = A(&#x27;demo&#x27;);console.log(demo);console.log(&#x27;==============&#x27;);console.log(demo.size()); //2 只要将构造函数的对象指向一个已存在的对象即可 数组与对象jquery返回的是数组A框架返回的是对象 原因：数组 对象 函数都被看成对象的实例，javascript没有一个纯粹的数组类型，一些浏览器引擎在判断对象是否数组不仅仅判断有没有length长度，还会判断是否具有数组方法来确定是否用数组形式展开 增加几个数组方法123456789101112131415161718A.fn = A.prototype = &#123; constructor: A, init : function (selector, context) &#123; //获取元素长度 this.length = 0; //........ //返回this对象 return this &#125;, push : [].push, sort : [].sort, splice: [].splice, length: 2, size : function () &#123; return this.length &#125;,&#125; 方法与扩展通过对jquery的extend方法学习，我们知道了extend的2个作用一个队外部对象扩展，二是对内部对象扩展 12345678910111213141516171819202122232425262728293031323334A.extend = A.fn.extend = function() &#123; var i = 1, len = arguments.length, target = arguments[0], j; if(i === len)&#123; target = this; i--; &#125; //遍历参数中的扩展对象 for(;i&lt;len;i++)&#123; //遍历扩展对象中的属性 for(j in arguments[i])&#123; //扩展对象 target[j] = arguments[i][j] &#125; &#125; console.log(&#x27;返回对象&#x27;,target); return target&#125;var demo = A.extend(&#123;first:1&#125;,&#123;second:2&#125;,&#123;third:3&#125;,&#123;four:4&#125;,&#123;five:5&#125;)console.log(demo);var demo1 = A.extend(A.fn,&#123;version:&quot;1.0&quot;&#125;)console.log(demo1); A.fn.extend(&#123;getVersion:function() &#123; return this.version&#125;&#125;)console.log(A(&#x27;demo&#x27;).getVersion()); 添加方法","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Javascript设计模式之外观模式","slug":"Javascript设计模式之外观模式","date":"2019-02-20T16:00:00.000Z","updated":"2020-09-16T09:07:36.000Z","comments":true,"path":"2019/02/21/Javascript设计模式之外观模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/21/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"外观模式(门面模式)，是一种相对简单而又无处不在的模式。外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。","text":"外观模式(门面模式)，是一种相对简单而又无处不在的模式。外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。 还不明白就看图： 123456789101112//场景function bindEvent(elem,type,selector,fn) &#123; if(fn == null)&#123; fn = selector; selector = null; &#125; //dosomething.......&#125;//调用bindEvent(elem,&#x27;click&#x27;,&quot;#div1&quot;,fn)bindEvent(elem,&quot;moveIn&quot;,fn) 首先看一个比较初级小白的写法： 123456789101112//bad写法document.onclick = function(e) &#123; e.preventDefault(); if(e.target !== document.getElementById(&quot;myinput&quot;))&#123; hidePageAlert(); &#125;&#125;function hidePageAlert(params) &#123; console.log(&#x27;隐藏弹窗&#x27;); &#125; 缺点：1.onclick的点击事件在dom0级事件处理，如果其他开发人员也用这个绑定事件就会覆盖这个点击事件2.低版本浏览器可能不支持e.preventDefault和e.target也需要处理2.如果用dom2事件处理应该对老版本浏览器兼容处理attachEvent，如果不支持dom2 那只能用onclick 代码实现12345678910111213141516171819202122232425//外观模式实现function addEvent(dom,type,fn) &#123; //对于dom2事件的处理 if(dom.addEventListener)&#123; dom.addEventListener(type,fn,false); &#125;else if(dom.attachEvent)&#123; dom.attachEvent(&quot;on&quot;+type,fn) &#125;else&#123; //不支持addevnet或者 attachEvent的方法 dom[&#x27;on&#x27;+type] = fn &#125;&#125;//获取dom元素var myInput = document.getElementById(&quot;myinput&quot;);addEvent(myInput,&quot;click&quot;,function() &#123; console.log(&#x27;绑定第一个事件中&#x27;); &#125;)addEvent(myInput,&#x27;click&#x27;,function() &#123; console.log(&#x27;绑定第二个事件中&#x27;);&#125;)addEvent(myInput, &#x27;click&#x27;, function () &#123; console.log(&#x27;绑定第三个事件中&#x27;);&#125;) 对低版本浏览器的e.preventDefault和e.target处理12345678910111213141516171819//获取事件对象var getEvent = function(event) &#123; return event || window.event;&#125;//获取元素var getTarget = function(event) &#123; var event = getEvent(event) return event.target || event.srcElement&#125;//阻止默认事件var preventDefault = function(event) &#123; var event = getEvent(event); if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 最后在优化一下之前的小白代码： 1234567//优化document.onclick = function(e) &#123; preventDefault(e) if(getTarget(e) !== document.getElementById(&quot;myinput&quot;))&#123; hidePageAlert(); &#125;&#125; 许多代码块也采用外观模式来封装多个功能，来简化底层操作方法：比如我们来获取元素属性样式的简单方法库 123456789101112131415161718192021222324252627282930313233//简约版本获取元素样式方法库let $ = &#123; //通过id获取 g:function(id) &#123; return document.getElementById(&quot;id&quot;) &#125;, //设置元素css属性 css:function(id,key,val) &#123; document.getElementById(id).style[key] = val &#125;, //设置元素属性 attr:function(id,key,val) &#123; document.getElementById(id)[key] = val &#125;, html:function(id,html) &#123; document.getElementById(id).innerHTML = html &#125;, on:function(id,type,fn) &#123; document.getElementById(id)[&#x27;on&#x27;+type] = fn &#125;&#125;$.css(&#x27;book&#x27;,&#x27;background&#x27;,&#x27;red&#x27;);$.attr(&quot;book&quot;,&quot;className&quot;,&quot;box&quot;)$.html(&#x27;book&#x27;,&#x27;这是更新的消息&#x27;)$.on(&quot;book&quot;,&quot;click&quot;,function() &#123; $.css(&#x27;book&#x27;, &#x27;width&#x27;, &#x27;150px&#x27;);&#125;)/*&lt;p id=&quot;book&quot; class=&quot;box&quot; style=&quot;background: red; width: 150px;&quot;&gt;这是更新的消息&lt;/p&gt;*/","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Javascript设计模式之代理模式","slug":"Javascript设计模式之代理模式","date":"2019-02-19T16:00:00.000Z","updated":"2020-09-16T09:07:34.000Z","comments":true,"path":"2019/02/20/Javascript设计模式之代理模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/20/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这2个对象之间起到中介作用","text":"由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这2个对象之间起到中介作用 白话文：代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作. 12345678910111213141516171819202122232425class RealImg &#123; constructor(filename) &#123; this.filename = filename; &#125; display() &#123; console.log(&#x27;display... &#x27; + this.filename) &#125; loadFromDisk() &#123; console.log(&#x27;loadding ...&#x27; + this.filename) &#125;&#125;class ProxyImg&#123; constructor(filename)&#123; this.realImg = new RealImg(&quot;filename&quot;) &#125; display()&#123; this.realImg.display(); &#125;&#125;let proxyImg = new ProxyImg(&quot;1.png&quot;);proxyImg.display(); //display... filename 再举个栗子ES6中的proxy非常好的使用的代理模式的精髓 let p = new Proxy(target, handler); 参数 说明 target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 明星与经纪人之间的关系 某个明星对象 123456//某个明星let star = &#123; name : &quot;王富贵&quot;, age : 18, phone: &#x27;13084920234&#x27;&#125; 明星经纪人对象 123456789101112131415161718192021222324252627282930//经纪人let agent = new Proxy(star,&#123; get: function (target,key) &#123; if(key === &quot;phone&quot;)&#123; return &#x27;经纪人phone：1233423423&#x27; &#125; if(key === &quot;price&quot;)&#123; return &#x27;明星出场价：120000&#x27; &#125; return target[key] &#125;, set: function(target,key,val)&#123; if(key === &quot;customPrice&quot;)&#123; if(val &lt; 100000)&#123; //最低10w throw new Error(&#x27;价格不低于10w&#x27;) &#125;else&#123; target[key] = val; return true &#125; &#125; &#125;&#125;)console.log(agent.phone); console.log(agent.price);console.log(agent.age);console.log(agent.name);agent.customPrice = 9000;console.log(agent.customPrice);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Javascript设计模式之观察者模式","slug":"Javascript设计模式之观察者模式","date":"2019-02-17T16:00:00.000Z","updated":"2020-09-16T09:07:35.000Z","comments":true,"path":"2019/02/18/Javascript设计模式之观察者模式/","link":"","permalink":"http://mariogogogo.github.io/2019/02/18/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"观察者模式的定义：在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。","text":"观察者模式的定义：在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 其实我们经常接触的的dom事件. 也是js和dom之间实现的一种观察者模式 只要订阅了div的click事件. 当点击div的时候, function click就会被触发. 场景：三个工程师分别写了三个独立的模块:留言模块，用户信息模块，提交留言模块，如果其中有一个人想添加别的功能又不能影响其他功能，不想自己写的模块与别人写的模块严重耦合在一起，就需要观察者模式 简单的理解可以是这样的：一个对象发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 12345678910111213141516171819202122232425262728293031323334353637383940var Observer = (function () &#123; //消息队列防止队列暴露被修改，作为私有变量保存 var _message = &#123;&#125; return &#123; //注册信息接口 regist: function (type, fn) &#123; if (typeof _message[type] === &#x27;undefined&#x27;) &#123; _message[type] = [fn]; &#125; else &#123; _message[type].push(fn) &#125; &#125;, //发布信息接口 fire: function (type, args) &#123; if (!_message[type]) &#123; return; &#125; var events = &#123; type: type, args: args || &#123;&#125; &#125;, i = 0, len = _message[type].length; for (; i &lt; len; i++) &#123; _message[type][i].call(this, events); &#125; &#125;, //移除信息接口 remove: function (type, fn) &#123; if (_message[type] instanceof Array) &#123; var i = _message[type].length - 1; for (; i &gt; 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1) &#125; &#125; &#125; &#125;&#125;)() 工程师A 123456789101112131415161718192021/**工程师a写追加评论功能 */(function () &#123; function addMsgItem(e) &#123; var text = e.args.text, ul = $$(&#x27;msg&#x27;), li = document.createElement(&quot;li&quot;); span = document.createElement(&quot;span&quot;); span.innerHTML = text; span.onclick = function () &#123; ul.removeChild(li) //发布者删除留言 Observer.fire(&#x27;removeCommentMessage&#x27;, &#123; num: -1 &#125;); &#125; li.appendChild(span) ul.appendChild(li) &#125; Observer.regist(&quot;addCommentMessage&quot;, addMsgItem);&#125;)() 工程师B12345678910111213/**B工程师复制递增用户信息功能模块 */(function () &#123; function changeMsgNum(e) &#123; var num = e.args.num; var numtext = $$(&#x27;msg_num&#x27;) console.log(numtext, num); numtext.innerHTML = parseInt(numtext.innerHTML) + num; &#125; Observer.regist(&quot;addCommentMessage&quot;, changeMsgNum); Observer.regist(&quot;removeCommentMessage&quot;, changeMsgNum);&#125;)()工程师C1234567891011121314151617/** c工程师负责 提交信息模块开发 */(function()&#123; $$(&#x27;user_submit&#x27;).onclick = function() &#123; var text = $$(&#x27;user_input&#x27;); if(text.value === &quot;&quot;)&#123; alert(&#x27;不能空&#x27;) return &#125; //发布消息 Observer.fire(&#x27;addCommentMessage&#x27;,&#123; text: text.value, num : 1 &#125;) text.value = &quot;&quot; &#125;&#125;)() 还可以对象间的解耦12345678910111213141516171819202122232425262728293031323334353637383940414243var Student = function(result) &#123; var that = this; that.result = result; that.say = function()&#123; console.log(that.result); &#125;&#125;//回答Student.prototype.answer = function(question) &#123; //注册参数问题 Observer.regist(question,this.say)&#125;//睡觉Student.prototype.sleep = function(question)&#123; //取消监听 Observer.remove(question,this.say)&#125;var Teacher = function() &#123;&#125;Teacher.prototype.ask = function(question) &#123; console.log(&#x27;老师的问题是： &#x27;+ question); Observer.fire(question)&#125;var student1 = new Student(&#x27;学生1回答问题&#x27;)var student2 = new Student(&#x27;学生2回答问题&#x27;)var student3 = new Student(&#x27;学生3回答问题&#x27;)student1.answer(&#x27;什么是设计模式&#x27;);student1.answer(&#x27;解释观察者模式&#x27;);student2.answer(&#x27;什么是设计模式&#x27;)student3.answer(&#x27;什么是设计模式&#x27;)student3.answer(&#x27;解释观察者模式&#x27;);student3.sleep(&#x27;解释观察者模式&#x27;);var teacher = new Teacher();teacher.ask(&quot;什么是设计模式&quot;);teacher.ask(&#x27;解释观察者模式&#x27;); 在实际开发中一个工程师很难做到项目中每一个模块熟悉，模块间信息的传递不必要相互引用其他模块，只需要通过观察者注册或发布消息； 其他使用场景在react中也用到的这个机制进行跨组件通信举个场景例子：页面顶部的搜索框（Search）根据下面加载的内容（Content）页面不同，显示不同的默认内容。也就是 Content 组件需要发送数据给 Search 组件。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Vue源码分析之模板解析-一般指令","slug":"Vue源码分析之模板解析-一般指令","date":"2019-02-17T16:00:00.000Z","updated":"2020-09-16T09:07:55.000Z","comments":true,"path":"2019/02/18/Vue源码分析之模板解析-一般指令/","link":"","permalink":"http://mariogogogo.github.io/2019/02/18/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90-%E4%B8%80%E8%88%AC%E6%8C%87%E4%BB%A4/","excerpt":"","text":"带着问题去探索？vue中的v-text/v-html指令是如何实现的？一般指令解析123&lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;&lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt;&lt;p v-class=&quot;msg&quot;&gt;&lt;/p&gt; 判断是否是普通指令1234567// 事件指令 exp表达式 也就是 方法名if (me.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令&#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);&#125; 1234567891011121314var compileUtil = &#123; // 解析text text: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;text&#x27;); &#125;, html: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;html&#x27;); &#125;, class: function(node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;class&#x27;); &#125;, 最后使用更新器把节点赋值进去1234567891011121314151617181920212223// 更新器 更新节点 给节点赋值var updater = &#123; textUpdater: function(node, value) &#123; // textContent就是 &#123;&#123;word&#125;&#125; node.textContent = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;, htmlUpdater: function(node, value) &#123; node.innerHTML = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;, classUpdater: function(node, value, oldValue) &#123; var className = node.className; className = className.replace(oldValue, &#x27;&#x27;).replace(/\\s$/, &#x27;&#x27;); //判断 class=&quot;a b&quot; 还是 class=“b” 是否需要空格？ var space = className &amp;&amp; String(value) ? &#x27; &#x27; : &#x27;&#x27;; node.className = className + space + value; &#125;, modelUpdater: function(node, value, oldValue) &#123; node.value = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125; 小结1) 得到指令名和指令值(表达式) text/html/class msg/myClass2) 从 data 中根据表达式得到对应的值3) 根据指令名确定需要操作元素节点的什么属性 v-text—textContent 属性 v-html—innerHTML 属性 v-class–className 属性4) 将得到的表达式的值设置到对应的属性上5) 移除元素的指令属性","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue源码分析之模板解析-事件指令","slug":"Vue源码分析之模板解析-事件指令","date":"2019-02-16T16:00:00.000Z","updated":"2020-09-16T09:07:55.000Z","comments":true,"path":"2019/02/17/Vue源码分析之模板解析-事件指令/","link":"","permalink":"http://mariogogogo.github.io/2019/02/17/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90-%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4/","excerpt":"带着问题去探索？vue中的@click指令是如何实现的？","text":"带着问题去探索？vue中的@click指令是如何实现的？事件指令解析1&lt;button v-on:click=&quot;button&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/button&gt; 首先还是判断元素节点123456//判断是否元素节点if (me.isElementNode(node)) &#123; // 编译指令 me.compile(node); // 判断是否是大括号的文本节点&#125; 然后进入compile编译1234567891011121314151617181920var nodeAttrs = node.attributes, me = this;//[].slice.call(nodeAttrs) ---&gt;伪数组 转成数组[].slice.call(nodeAttrs).forEach(function(attr) &#123; //attrname = “v-on = &quot;click&quot;&quot; var attrName = attr.name; if (me.isDirective(attrName)) &#123; var exp = attr.value; var dir = attrName.substring(2); // &quot;on:click&quot; // 事件指令 if (me.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令 &#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; node.removeAttribute(attrName); &#125;&#125;); 如何绑定事件12345678910111213// 事件处理 事件button绑定事件监听 事件名和回调函数eventHandler: function(node, vm, exp, dir) &#123; // 得到事件类型名 :click var eventType = dir.split(&#x27;:&#x27;)[1], //从methods中得到表达式所对应的函数（事件回调函数） fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; //取到事件的函数 //如果都存在 if (eventType &amp;&amp; fn) &#123; //绑定事件监听 fn.bind(vm) //让事件中 this.name --&gt;指向vm // 给节点绑定事件名和回调函数dom事件监听 node.addEventListener(eventType, fn.bind(vm), false); &#125;&#125;, 但我们在页面中看不到如何指令，因为12//移除指令属性node.removeAttribute(attrName); 小结：模板解析(2): 事件指令解析1) 从指令名中取出事件名2) 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象3) 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听4) 指令解析完后, 移除此指令属性","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue源码分析之模板解析-表达式","slug":"Vue源码分析之模板解析","date":"2019-02-15T16:00:00.000Z","updated":"2020-09-16T09:07:56.000Z","comments":true,"path":"2019/02/16/Vue源码分析之模板解析/","link":"","permalink":"http://mariogogogo.github.io/2019/02/16/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/","excerpt":"带着问题去探索？vue中的指令是如何实现的？","text":"带着问题去探索？vue中的指令是如何实现的？ 模板解析主要分：大括号解析 1&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; 将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 将解析后的 fragment 添加到 el 中显示 12// 创建一个编译的对象 编译解析我们的模板this.$compile = new Compile(options.el || document.body, this) 简单分析编译过程1234567891011121314function Compile(el, vm) &#123; // 保存vm对象到compile中 this.$vm = vm; this.$el = this.isElementNode(el) ? el : document.querySelector(el); // 如果有el元素才执行 if (this.$el) &#123; // 取出el元素中所有子节点保存到fragment中 this.$fragment = this.node2Fragment(this.$el); // 编译所有层次的子节点 this.init(); //编译好的el元素添加到页面el元素中 this.$el.appendChild(this.$fragment); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Compile.prototype = &#123;...compileElement: function (el) &#123; // 取出最外层的子节点 var childNodes = el.childNodes, me = this; //this-&gt; compile实例 [].slice.call(childNodes).forEach(function (node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 匹配&#123;&#123;name&#125;&#125; 加小括号是为了$1 ==name if (me.isElementNode(node)) &#123; // 编译事件指令 me.compile(node); //是否有指令属性 // 是文本节点吗 有&#123;&#123;&#125;&#125; 吗 &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 是否有子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;,&#125;... // 指令处理集合var compileUtil = &#123; text: function (node, vm, exp) &#123; this.bind(node, vm, exp, &#x27;text&#x27;); &#125;, bind: function (node, vm, exp, dir) &#123; // 得到更新节点函数 var updaterFn = updater[dir + &#x27;Updater&#x27;]; // 调用更新节点 updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); new Watcher(vm, exp, function (value, oldValue) &#123; updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, &#125; // 包含多个更新节点方法的工具对象var updater = &#123; textUpdater: function (node, value) &#123; node.textContent = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value; &#125;, &#125; 小结：1) 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 name2) 从 data 中取出表达式对应的属性值3) 将属性值设置为文本节点的 textContent","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue源码分析数据代理","slug":"Vue源码分析之数据代理","date":"2019-02-14T16:00:00.000Z","updated":"2020-09-16T09:07:56.000Z","comments":true,"path":"2019/02/15/Vue源码分析之数据代理/","link":"","permalink":"http://mariogogogo.github.io/2019/02/15/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"怎么实现 this._test 改变而不是 this._data.test 改变触发更新？","text":"怎么实现 this._test 改变而不是 this._data.test 改变触发更新？ 数据代理: 通过一个对象代理对另一个对象(在前一个对象内部)中属性的操作(读/写) vue 数据代理: 通过 vm 对象来代理 data 对象中所有属性的操作 好处: 更方便的操作 data 中的数据 基本实现流程 a. 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 b. 所有添加的属性都包含 getter/setter c. getter/setter 内部去操作 data 中对应的属性数据 123456789101112131415161718192021222324252627282930313233function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; var me = this; // 数据代理 // 实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;/*代理*/_proxy(options.data);function _proxy (data) &#123; const that = this; Object.keys(data).forEach(key =&gt; &#123; Object.defineProperty(that, key, &#123; configurable: true, enumerable: true, get: function proxyGetter () &#123; return that._data[key]; &#125;, set: function proxySetter (val) &#123; that._data[key] = val; &#125; &#125;) &#125;);&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"Vue源码分析前期知识点","slug":"Vue源码分析前期知识点","date":"2019-02-13T16:00:00.000Z","updated":"2020-09-16T09:07:55.000Z","comments":true,"path":"2019/02/14/Vue源码分析前期知识点/","link":"","permalink":"http://mariogogogo.github.io/2019/02/14/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%89%8D%E6%9C%9F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"归类了一些比较常用的方法","text":"归类了一些比较常用的方法 12345678&lt;div id=&quot;test&quot;&gt; &lt;ul&gt; &lt;li&gt;vue&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;li&gt;jQuery&lt;/li&gt; &lt;li&gt;angle&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; [].slice.call(lis): 将伪数组转换为真数组1234const lis = document.getElementsByTagName(&quot;li&quot;); console.log(lis instanceof Array, lis[1].innerHTML, lis.forEach); const lis2 = Array.prototype.slice.call(lis); console.log(lis2 instanceof Array, lis2[1].innerHTML, lis2.forEach); node.nodeType: 得到节点类型 doucment element attr text节点 1234const ele = document.getElementById(&quot;test&quot;); const attrNode = ele.getAttributeNode(&quot;id&quot;); const textNode = ele.firstChild; console.log(ele.nodeType, attrNode.nodeType, textNode.nodeType); Object.defineProperty(obj, propertyName, {}): 给对象添加/修改属性(指定描述符)1234567891011121314151617181920const obj = &#123; firstName: &quot;A&quot;, lastName: &quot;B&quot; &#125; Object.defineProperty(obj, &quot;fullname&quot;, &#123; get() &#123; return this.firstName + &quot;-&quot; + this.lastName; &#125;, set(value) &#123; const name = value.split(&quot;-&quot;); this.firstName = name[0]; this.lastName = name[1]; &#125; &#125;) console.log(obj.fullname); obj.firstName = &quot;C&quot; obj.lastName = &quot;D&quot; console.log(obj.fullname); obj.fullname = &quot;E-F&quot;; console.log(obj.firstName, obj.lastName); Object.keys(obj): 得到对象自身可枚举的属性名的数组123const objNames = Object.keys(obj)console.log(objNames); obj.hasOwnProperty(prop): 判断prop是否是obj自身的属性1console.log(obj.hasOwnProperty(&quot;fullname&quot;), obj.hasOwnProperty(&quot;toString&quot;)); DocumentFragment: 文档碎片(高效批量更新多个节点)123456789101112131415161718192021// 创建fragment const ul = ele.getElementsByTagName(&quot;ul&quot;)[0]; const fragment = document.createDocumentFragment(); // 取出ul中所有子节点包括空格 换行符 let child; console.log(ul.firstChild); while (child = ul.firstChild) &#123; fragment.appendChild(child) //先移除ul中删除 添加到fragment &#125; // 更新fragment中的li文本 console.log(Array.prototype.slice.call(fragment.childNodes)); Array.prototype.slice.call(fragment.childNodes).forEach(node =&gt; &#123; if (node.nodeType === 1) //元素节点 &#123; node.textContent = &quot;改变之后&quot; &#125; &#125;) // 插入ul中更新 ul.appendChild(fragment);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"ReactNative之屏幕适配","slug":"ReactNative之屏幕适配","date":"2019-02-12T16:00:00.000Z","updated":"2020-09-16T09:07:50.000Z","comments":true,"path":"2019/02/13/ReactNative之屏幕适配/","link":"","permalink":"http://mariogogogo.github.io/2019/02/13/ReactNative%E4%B9%8B%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/","excerpt":"RN中单位是dp，这个跟Android中的单位是一致的","text":"RN中单位是dp，这个跟Android中的单位是一致的说到这里，不妨把涉及到的一些概念梳理一下： dp（dip）（Density-independent pixels）一种基于屏幕密度的抽象单位，像素无关密度。在每英寸160点的显示器上，1dp = 1px。特别需要注意dp是相对长度单位，简单的说1dp在不同的屏幕或者不同的ppi下展示出来的“物理长度”可能不一致。 px 像素点。也是相对长度 pt 中文叫磅，等于1/72英寸。物理长度 sp（与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放，Android设置字体的时候使用。 density 密度。这个可以参考上边说的，跟pixelRatio相近，约等于DPI/160。 pixelRatio 设备像素比。通过PixelRatio.get()获得 PPI (pixels per inch) 图像分辨率 （每英寸所包含的像素数，指对角线） DPI（dots per inch）打印精度 （每英寸所能打印的点数，指宽高） 分辨率 ： 横纵2个方向的像素点的数量，常见取值 480X800 ，750X1334 屏幕尺寸： 屏幕对角线的长度（英寸）。电脑电视同理。所以我们可以知道： 1dp=（1 * density） px，相反1px=（1/density）dp 那么，我们如何在RN中设置宽度为1px的分割线呢？ 1width: 1 / PixelRatio.get() 这样就可以了！ 另外，一个设备的宽高，我们可以这样获得： 12width: Dimensions.get(&#x27;window&#x27;).width,height: Dimensions.get(&#x27;window&#x27;).height, 那么这个得到的宽高是什么呢？我们可以打印出来，比如iPhone6s，这个值打印出来是width：375，height：667，因为6s的density是2，所以我们知道这个得到的宽高是dp。 适配方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 屏幕工具类 以及一些常用的工具类封装 * ui设计基准,iphone 6 2倍图 * width:750px * height:1334px * @2x *//* 设备的像素密度，例如： PixelRatio.get() === 1 mdpi Android 设备 (160 dpi) PixelRatio.get() === 1.5 hdpi Android 设备 (240 dpi) PixelRatio.get() === 2 iPhone 4, 4S,iPhone 5, 5c, 5s,iPhone 6,xhdpi Android 设备 (320 dpi) PixelRatio.get() === 3 iPhone 6 plus , xxhdpi Android 设备 (480 dpi) PixelRatio.get() === 3.5 Nexus 6 */import &#123; PixelRatio, Dimensions, Platform, AsyncStorage&#125; from &#x27;react-native&#x27;;export let sW = Dimensions.get(&#x27;window&#x27;).width;export let sH = Dimensions.get(&#x27;window&#x27;).height;// 返回字体大小的缩放因子const fontScale= PixelRatio.getFontScale();export let pixelRatio = PixelRatio.get();//默认像素密度export const DEFAULT_DENSITY = 2;//px转换成dp//以iphone6为基准,如果以其他尺寸为基准的话,请修改下面的defaultWidth和defaultHeight为对应尺寸即可. 以下为1倍图时const defaultWidth = 375; //ptconst defaultHeight = 667; //pt//缩放比例const _scaleWidth = sW / defaultWidth;const _scaleHeight = sH / defaultHeight;console.log(&#x27;缩放比例&#x27;,sW,sH,fontScale,_scaleWidth,_scaleHeight)/** * 设置宽度 * @param size 输入px单位 * @returns &#123;number&#125; */export function px2dpw(size:Number) &#123; return size * _scaleWidth;&#125;/** * 设置高度 * @param size 输入px单位 * height ,paddingVertical ,paddingTop ,paddingBottom ,marginVertical ,marginTop ,marginBottom * @returns &#123;number&#125; */export function px2dph(size: Number) &#123; return size * _scaleHeight;&#125;/** * 设置字体 * @param size 输入px单位 * @returns &#123;number&#125; */export function px2dpf(size: Number, allowFontScaling = false) &#123; const scale = Math.min(_scaleWidth, _scaleHeight); const fontSize = allowFontScaling ? 1 : fontScale; return size * scale / fontSize;&#125;// iPhoneXconst X_WIDTH = 375;const X_HEIGHT = 812;/** * 判断是否为iphoneX * @returns &#123;boolean&#125; */export function isIphoneX() &#123; return ( Platform.OS === &#x27;ios&#x27; &amp;&amp; ((screenH === X_HEIGHT &amp;&amp; screenW === X_WIDTH) || (screenH === X_WIDTH &amp;&amp; screenW === X_HEIGHT)) )&#125; 使用123456&lt;Text style=&#123;&#123;fontSize: ScreenUtil.px2dpf(30)&#125;&#125;&gt;已适配&lt;/Text&gt;&lt;View style=&#123;&#123; height: ScreenUtil.px2dph(60), width: ScreenUtil.px2dpw(300), backgroundColor: &#x27;blue&#x27; &#125;&#125;&gt;&lt;/View&gt;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"mongoose联表查询方式","slug":"mongoose联表查询","date":"2019-02-07T16:00:00.000Z","updated":"2020-09-16T09:07:40.000Z","comments":true,"path":"2019/02/08/mongoose联表查询/","link":"","permalink":"http://mariogogogo.github.io/2019/02/08/mongoose%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"mongoose的一些高级用法：","text":"mongoose的一些高级用法：解决如下图片问题在关系型数据库如mysql中我们可以很容易解决 1SELECT student.name,student.age,class.name FROM student,class WHERE student.classId = class.id models中的配置123456789101112131415161718192021222324var mongoose = require(&#x27;mongoose&#x27;);var Schema = mongoose.Schema;/*定义数据模式*/var OrderSchema = new mongoose.Schema(&#123; uid: &#123; type: mongoose.Schema.ObjectId, //关键点 主键类型 ref : &#x27;user&#x27; &#125;, amount: &#123; type : Number, required: true &#125;, oType: &#123; type : Number, required: true &#125;, // 订单类型 status: &#123; type : Number, required: true &#125;, // 订单的状态:1完成 2未完成 3失效&#125;)module.exports = mongoose.model(&#x27;order&#x27;, OrderSchema, &quot;order&quot;)//解决mongose中数据库表名+s的问题，第三个参数与第一个参数名必须相同 第一种方式populate12345678910111213141516171819202122232425262728293031router.get(&#x27;/getOrder&#x27;, async function (ctx) &#123; const res = await Order.find().populate(&#123; path : &#x27;uid&#x27;, model : User, select: &#x27;_id phone status&#x27; &#125;).exec() ctx.body = &#123; code: 0, data: res &#125;&#125;)/*&#123; &quot;code&quot;: 0, &quot;data&quot;: [ &#123; &quot;_id&quot;: &quot;5c5da7407852d511cc3a82fd&quot;, &quot;uid&quot;: &#123; &quot;_id&quot;: &quot;5c5da6347852d511cc3a82f6&quot;, &quot;phone&quot;: &quot;001&quot;, &quot;status&quot;: &quot;0&quot; &#125;, &quot;amount&quot;: 0, &quot;oType&quot;: 1, &quot;status&quot;: 0, &quot;__v&quot;: 0 &#125; ] &#125;*/ 第二种方式$lookup 下面我简单介绍一些$lookup中的参数： from： 需要关联的表【 orders】 localField: 【product】 表需要关联的键。 foreignField：【 orders】 的matching key。 as： 对应的外键集合的数据，【 因为可能是一对多的， 对吧】 12345678910111213141516171819202122232425262728293031323334353637383940router.get(&#x27;/getOrder&#x27;, async function (ctx) &#123; const res = await Order.aggregate([&#123; $lookup: &#123; from : &#x27;user&#x27;, localField : &#x27;uid&#x27;, foreignField: &#x27;_id&#x27;, as : &quot;user_docs&quot; &#125; &#125;]) ctx.body = &#123; code: 0, data: res &#125;&#125;)/*&#123; &quot;code&quot;: 0, &quot;data&quot;: [ &#123; &quot;_id&quot;: &quot;5c5da7407852d511cc3a82fd&quot;, &quot;uid&quot;: &quot;5c5da6347852d511cc3a82f6&quot;, &quot;amount&quot;: 0, &quot;oType&quot;: 1, &quot;status&quot;: 0, &quot;__v&quot;: 0, &quot;user_docs&quot;: [ &#123; &quot;_id&quot;: &quot;5c5da6347852d511cc3a82f6&quot;, &quot;meta&quot;: &#123; &quot;createAt&quot;: &quot;2019-02-08T15:50:51.864Z&quot;, &quot;updateAt&quot;: &quot;2019-02-08T15:50:51.864Z&quot; &#125;, &quot;phone&quot;: &quot;001&quot;, &quot;status&quot;: &quot;0&quot;, &quot;__v&quot;: 0 &#125; ] &#125; ]*/ 附加一个模糊查询 1234567891011121314151617181920//从URL中传来的 keyword参数const keyword = this.params.keyword //不区分大小写const reg = new RegExp(keyword, &#x27;i&#x27;) const result = await User.find( &#123; $or : [ //多条件，数组 &#123;nick : &#123;$regex : reg&#125;&#125;, &#123;email : &#123;$regex : reg&#125;&#125; ] &#125;, &#123; password : 0 // 返回结果不包含密码字段 &#125;, &#123; sort : &#123; _id : -1 &#125;,// 按照 _id倒序排列 limit : 100 // 查询100条 &#125;)","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"Vue中的生命周期","slug":"Vue中的生命周期","date":"2019-01-21T16:00:00.000Z","updated":"2020-09-16T09:07:56.000Z","comments":true,"path":"2019/01/22/Vue中的生命周期/","link":"","permalink":"http://mariogogogo.github.io/2019/01/22/Vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Vue实例有一个完整的生命周期，从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。","text":"Vue实例有一个完整的生命周期，从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。 通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 文字说明 生命周期 说明 beforeCreate 在实例初始化之后，数据观测（Data Observer）和event/watcher事件配置之前被调用 create 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据(Data Observer)、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内 beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前.你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程 updated 由于数据更改导致虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用 destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用 小结一下： beforeCreate和created：创建Vue实例 beforeMount和mounted：挂载目标元素 beforeUpdate和updated：改变后重新渲染 beforeDestroy和destroyed：销毁Vue实例 注意 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 代码说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899let vm = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; name: &quot;马里奥&quot; &#125;; &#125;, beforeCreate: function() &#123; console.log(&quot;===== 创建前 =====&quot;); console.log(this.name);// undefined console.log(this.$el);// undefined &#125;, created: function() &#123; // 在实例创建之后同步调用 // 此时实例已结束解析选项 // 这意味着已建立：数据绑定，计算属性,方法，watcher/事件回调 // 但是还没有开始DOM编译，$el还不存在，但是实例存在，即this.name存在，可以打印出来 //在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 console.log(&quot;===== 已创建 =====&quot;); console.log(this.name); // &quot;马里奥&quot; console.log(this.$el); // undefined &#125;, beforeCompile: function() &#123; console.log(&quot;===== 未开始编译 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, compiled: function() &#123; // 在编译结束之后调用 // 此时所有的指令已生效，因而数据的变化将触发DOM更新 // 但是不担保$el已插入文档 console.log(&quot;===== 编译完成 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, beforeMount: function() &#123; //注意dom还没有生成html页面上去 console.log(&quot;===== Mount之前 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, mounted: function() &#123; //挂在完成 也就是模板中的html渲染到了页面中 //一般这里做一些ajax操作 //只执行一次 console.log(&quot;===== Mount完成 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log(&quot;===== 更新前 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, updated: function() &#123; //这里不能更改数据，否则会陷入死循环 console.log(&quot;===== 更新完成 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, ready: function() &#123; // 在编译结束和$el 第一次插入文档之后调用，如果在第一次attached钩子之后调用 // 注意，必须是由Vue插入，比如 vm.$appendTo()等方法或指令更新，才会触发ready 钩子 console.log(&quot;===== 一切都准备好了 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, attached: function() &#123; // app.$appendTo(&#x27;#app2&#x27;)暂时触发不了，不知道怎么解决 // 在 vm.$el插入DOM时调用。必须是由指令或实例方法，比如$appendTo()插入，直接操作vm.$el不会触发这个钩子 console.log(&quot;===== 插入DOM成功 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, detached: function() &#123; // 触发事件 app.$destroy(true)，其中参数true控制是否删除DOM节点或者app.$remove() // 在vm.$el 从DOM中删除时调用。必须是由指令或实例方法删除，直接操作vm.$el不会触发这个钩子 console.log(&quot;===== 删除DOM成功 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, beforeDestroy: function() &#123; // 触发方式，在console里面打印app.$destroy() // 在开始销毁实例时调用。此时实例仍然有功能 console.log(&quot;===== 销毁前 =====&quot;); console.log(this.name); console.log(this.$el); &#125;, destroyed: function() &#123; // 触发方式，在console里面打app.$destroy() // 其中app.$destroy(true)是删除DOM节点，会触发detached函数，但是实例仍然存在 // 在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑 // 注意是解绑不是销毁，所有的子实例也已经被销毁 console.log(&quot;===== 已销毁 =====&quot;); console.log(this.name); console.log(this.$el); &#125;&#125;); 页面初始化只执行这些函数点击输入框更改执行销毁操作 结合官方文档简单总结了一下如图显示 参考大漠","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"饿了么webApp项目回顾-技巧篇","slug":"饿了么webApp项目回顾-技巧篇","date":"2019-01-20T07:13:48.000Z","updated":"2020-09-16T09:07:01.000Z","comments":true,"path":"2019/01/20/饿了么webApp项目回顾-技巧篇/","link":"","permalink":"http://mariogogogo.github.io/2019/01/20/%E9%A5%BF%E4%BA%86%E4%B9%88webApp%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE-%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"侧边栏吸顶效果的实现 侧边栏点菜数量的实现 购物车抛物线的实现(⭐️⭐️⭐️)","text":"侧边栏吸顶效果的实现 侧边栏点菜数量的实现 购物车抛物线的实现(⭐️⭐️⭐️) 侧边栏吸顶效果的实现 1234567891011&lt;div class=&quot;goods&quot;&gt; &lt;div class = &quot;headtitle&quot; v-if = &quot;fixedTitle&quot; ref = &quot;fixed&quot; &gt;&#123;&#123;fixedTitle&#125;&#125;&lt;/div&gt; &lt;div class = &quot;menu-wrapper&quot; ref = &quot;menuWrapper&quot; &gt; &lt;/div&gt; 逻辑处理 12345678910fixedTitle() &#123; //当scrolly大于 -标题高度的时候不显示 console.log(&quot;现在的y&quot; + this.scrollY); if (this.scrollY &lt;= 0) &#123; return &quot;&quot;; &#125; return this.goods[this.itemIndex] ? this.goods[this.itemIndex].name: &quot;&quot;;&#125;, 侧边栏点菜数量的实现 12345678910111213141516171819202122232425&lt;divclass = &quot;menu-wrapper&quot;ref = &quot;menuWrapper&quot;&gt;&lt;ul&gt; &lt;li v-for = &quot;(item, index) in goods&quot; :key = &quot;index&quot; class = &quot;menu-item&quot; :class = &quot;&#123;&#x27;current&#x27;:currentIndex===index&#125;&quot; @click = &quot;selectMenu(index,$event)&quot; ref = &quot;menuList&quot; &gt; &lt;span class = &quot;num&quot; v-show = &quot;barTxts &amp;&amp; barTxts[index].count &gt;0&quot; &gt;&#123;&#123;barTxts[index].count&#125;&#125;&lt;/span&gt; &lt;span class=&quot;text border-1px&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在添加按钮组件中set一个事件改变增加了food中一个属性 12345678910111213141516171819 barTxts() &#123; let ret = []; //初始化数组 this.goods.forEach(good =&gt; &#123; const &#123; type, name, foods &#125; = good; let count = 0; //判断food中每一个对象是否有新增的count属性并获取数量 foods.forEach(food =&gt; &#123; count += food.count || 0; &#125;); ret.push(&#123; type, name, count &#125;); &#125;); console.log(ret); return ret;&#125; 购物车抛物线的实现 主要实现过程看图： 1.cartcontrol.vue，添加商品时，派发一个事件给goods.vue，获取当前DOM，方便计算小球下落位置 1234567891011121314151617addCart(event) &#123; if(!event._constructed) &#123;//非自定义点击事件的情况下return掉，这样pc端就不会检测到两次点击事件。 return; &#125; // console.log(this.food.count); if(!this.food.count)&#123; Vue.set(this.food,&#x27;count&#x27;,1); //给对象添加他不存在的属性时，这样的方式是不行的。需要用Vue的Vue.set() // this.food.count=1; &#125;else&#123; this.food.count++; &#125; this.$emit(&#x27;cart-add&#x27;,event.target);//添加商品时，派发一个事件，将当前DOM传递给goods.vue&#125; 2.goods.vue接收 1234&lt;div class=&quot;cartcontrol-wrapper&quot;&gt; &lt;cartcontrol :food=&#x27;food&#x27; @cart-add=&quot;cartAdd&quot;&gt;&lt;/cartcontrol&gt;&lt;/div&gt; 逻辑处理1234567cartAdd(el) &#123; //体验优化，异步执行下落动画，画面不容易卡顿。 this.$nextTick(() =&gt; &#123; this.$refs.shopcart.drop(el); &#125;);&#125;,3.goods.vue中调用子组件shopcart.vue的drop()方法 1234567891011121314drop(el) &#123; // console.log(el); //遍历小球，找到show为false的小球 for(let i=0;i&lt;this.balls.length;i++)&#123; let ball = this.balls[i]; if(!ball.show) &#123; ball.show = true; ball.el = el;//用小球的el对象保留这个element this.dropBalls.push(ball); return; &#125; &#125;&#125;, shopcart.vue123456789&lt;div class=&quot;ball-container&quot;&gt; &lt;transition-group name=&quot;drop&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-for=&quot;(ball,index) in balls&quot; v-show=&quot;ball.show&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;inner inner-hook&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/transition-group&gt;&lt;/div&gt;逻辑处理调用vue的javascript钩子函数 基础了解：向右表示X轴的正方向，向下表示Y轴的正方向 123456789101112131415161718192021222324252627282930313233343536373839beforeEnter: function (el) &#123; /*el是小球; 遍历所有show为true的小球*/ let count = this.balls.length; while(count--) &#123; let ball = this.balls[count]; if(ball.show) &#123; let rect = ball.el.getBoundingClientRect();//获得该元素（加号）相对于视口的位置的偏移（left,top） let x = rect.left-32; //为什么y是负值，因为起始位置在购物车图标位置要挪到+号位置进入动画 let y = -(window.innerHeight-rect.top-22); el.style.display = &#x27;&#x27;; el.style.webkitTransform = `translate3d(0,$&#123;y&#125;px,0)`;//外层做纵向运动 el.style.transform = `translate3d(0,$&#123;y&#125;px,0)`; let inner = el.getElementsByClassName(&#x27;inner-hook&#x27;)[0]; inner.style.webkitTransform = `translate3d($&#123;x&#125;px,0,0)`; inner.style.transform = `translate3d($&#123;x&#125;px,0,0)`; &#125; &#125;&#125;,enter: function (el) &#123; let rf = el.offsetHeight;//必须重绘，再进行transform才有用 this.$nextTick(() =&gt; &#123; el.style.webkitTransform = &#x27;translate3d(0,0,0)&#x27;;//外层做纵向运动 el.style.transform = &#x27;translate3d(0,0,0)&#x27;; let inner = el.getElementsByClassName(&#x27;inner-hook&#x27;)[0]; inner.style.webkitTransform = &#x27;translate3d(0,0,0)&#x27;; inner.style.transform = &#x27;translate3d(0,0,0)&#x27;; &#125;);&#125;,afterEnter: function (el) &#123; //状态重置 let ball = this.dropBalls.shift(); if(ball) &#123; ball.show = false; el.style.display = &#x27;none&#x27;; &#125;&#125; 动画样式采用cubic曲线123456789101112131415161718192021222324.ball-container &#123; .ball &#123; position: fixed; left: 32px; bottom: 22px; width: 16px; heigth: 16px; z-index: 200; .inner &#123; width: 16px; height: 16px; border-radius: 50%; background: rgb(0,160,220); &#125; &amp;.drop-enter-active,&amp;.drop-leave-active &#123; transition: all 0.4s cubic-bezier(0.49,-0.29,0.75,0.41); .inner &#123; transition: all 0.4s linear; &#125; &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"}]},{"title":"饿了么webApp项目回顾-动画篇","slug":"饿了么webApp项目回顾动画篇","date":"2019-01-19T07:13:48.000Z","updated":"2020-09-16T09:07:02.000Z","comments":true,"path":"2019/01/19/饿了么webApp项目回顾动画篇/","link":"","permalink":"http://mariogogogo.github.io/2019/01/19/%E9%A5%BF%E4%BA%86%E4%B9%88webApp%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE%E5%8A%A8%E7%94%BB%E7%AF%87/","excerpt":"动画效果内容的一些整理记录","text":"动画效果内容的一些整理记录 123456&lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt; ... &lt;/div&gt; &lt;/transition&gt; 首先了解下过度动画在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 12345678910111213141516.detail position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto backdrop-filter: blur(10px) opacity: 1 background: rgba(7, 17, 27, 0.8) &amp;.fade-enter-active, &amp;.fade-leave-active transition: all 0.5s &amp;.fade-enter, &amp;.fade-leave-active opacity: 0 background: rgba(7, 17, 27, 0) 弹窗 12345678910&lt;!-- 购物车弹窗布局开始 --&gt; &lt;transition name=&quot;fold&quot;&gt; &lt;div class = &quot;shopcart-list&quot; v-show = &quot;listShow&quot; &gt; &lt;/div&gt; &lt;/transition&gt; &lt;!-- 购物车弹窗布局结束 --&gt; css 1234567891011.shopcart-list position absolute left 0 top 0 z-index -1 width 100% transform translate3d(0, -100%, 0) &amp;.fold-enter-active, &amp;.fold-leave-active transition all 0.5s &amp;.fold-enter, &amp;.fold-leave-active transform translate3d(0, 0, 0) 遮罩层的处理 123456789&lt;!-- 遮罩层布局开始 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div class = &quot;list-mask&quot; @click = &quot;hideList&quot; v-show = &quot;listShow&quot; &gt;&lt;/div&gt; &lt;/transition&gt; &lt;!-- 遮罩层布局结束 --&gt; css样式12345678910111213141516.list-mask position fixed top 0 left 0 width 100% height 100% z-index 40 backdrop-filter blur(10px) opacity 1 background rgba(7, 17, 27, 0.6) &amp;.fade-enter-active, &amp;.fade-leave-active transition all 0.5s &amp;.fade-enter, &amp;.fade-leave-active opacity 0 background rgba(7, 17, 27, 0)侧滑 1234&lt;transition name=&quot;move&quot;&gt;......&lt;/transition&gt; css样式1234567891011121314.food position fixed left 0 top 0 bottom 48px z-index 30 width 100% background #fff transform translate3d(0, 0, 0) &amp;.move-enter-active, &amp;.move-leave-active transition all 0.2s linear &amp;.move-enter, &amp;.move-leave-active transform translate3d(100%, 0, 0)小球滚动动画 代码如下 1234567891011121314151617&lt;transition name=&quot;move&quot;&gt; &lt;div class = &quot;cart-decrease&quot; v-show = &quot;food.count&gt;0&quot; @click.stop = &quot;decrease&quot; &gt; &lt;span class=&quot;inner icon-remove_circle_outline&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/transition&gt; &lt;div class = &quot;cart-count&quot; v-show = &quot;food.count&gt;0&quot; &gt;&#123;&#123;food.count&#125;&#125;&lt;/div&gt; &lt;div class = &quot;cart-add icon-add_circle&quot; @click.stop = &quot;add&quot; &gt;&lt;/div&gt; 样式 123456789101112131415161718192021.cartcontrol font-size 0 .cart-decrease display inline-block padding 6px opacity 1 transform translate3d(0, 0, 0) .inner display inline-block line-height 24px font-size 24px color rgb(0, 160, 220) transition all 0.4s linear transform rotate(0) &amp;.move-enter-active, &amp;.move-leave-active transition all 0.4s linear &amp;.move-enter, &amp;.move-leave-active opacity 0 transform translate3d(24px, 0, 0) .inner transform rotate(180deg)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"http://mariogogogo.github.io/tags/CSS/"}]},{"title":"饿了么webApp项目回顾-样式篇","slug":"饿了么webApp项目回顾样式篇","date":"2019-01-18T07:13:48.000Z","updated":"2020-09-16T09:07:02.000Z","comments":true,"path":"2019/01/18/饿了么webApp项目回顾样式篇/","link":"","permalink":"http://mariogogogo.github.io/2019/01/18/%E9%A5%BF%E4%BA%86%E4%B9%88webApp%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE%E6%A0%B7%E5%BC%8F%E7%AF%87/","excerpt":"样式内容的一些整理记录","text":"样式内容的一些整理记录 解决移动端1px边框问题其实这个原因很简单，因为css中的1px并不等于移动设备的1px，这些由于不同的手机有不同的像素密度。在window对象中有一个devicePixelRatio属性，他可以反应css中的像素与设备的像素比。解决的方式伪元素+transform 构建1个伪元素, border为1px, 再以transform缩放到50%。123456789101112131415161718192021222324border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: &#x27; &#x27; /*根据手机不同分辨率下的dpi*/@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7)@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) flex弹性布局需要了解 flex: flex-grow flex-shrink flex-basis|auto|initial|inherit;flex-basis 项目的长度。合法值：”auto”、”inherit” 或一个后跟 “%”、”px”、”em” 或任何其他长度单位的数字。 123456789101112.goods display: flex position: absolute top: 174px bottom: 46px width: 100% overflow: hidden .menu-wrapper flex: 0 0 80px width: 80px background: #f3f5f7 侧边菜单栏多行居中显示效果用到display：table-cell 与 va-middle 12345678910111213141516171819.menu-item display: table height: 54px width: 56px padding: 0 12px line-height: 14px &amp;.current position: relative z-index: 10 margin-top: -1px background: #fff font-weight: 700 .text display: table-cell width: 56px vertical-align: middle border-1px(rgba(7, 17, 27, 0.1)) font-size: 12px Sticky+footer布局问题：怎么样让一个区块始终在页面底部，无论它前面的内容只有几行或者多到页面出现滚动条，该区块始终出现在页面底部 1234567891011&lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt;&lt;div class=&quot;detail-wrapper clearfix&quot;&gt; &lt;div class=&quot;detail-main&quot;&gt; &lt;h1 class=&quot;name&quot;&gt;&#123;&#123;seller.name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;detail-close&quot; @click=&quot;closeDetail&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt; css布局 12345678910111213141516171819202122232425.detail-wrapper width: 100% min-height: 100% .detail-main margin-top: 64px padding-bottom: 64px .clearfix display: inline-block &amp;:after display: block content: &#x27;&#x27; height: 0 line-height: 0 clear: both visibility: hidden.detail-close position: relative width: 32px height: 32px margin: -64px auto 0 auto clear: both font-size: 32px 如何实现： 它这个布局实现的原理就是给它的伪类after添加一个内容，设置display必须为block或者inline-block，让它伪类的内容占一行，然后设置height跟line-height都为0，将它的visibility设置为hidden(这里还是会占据空间)，让伪类一直占据一行然后将下面的区块，也就是我们要求一直在底部的区块挤下去，这样就实现了sticky footer布局。margin: -64px auto 0 auto在这里就是这个margin-top:-64px决定你的这个元素要往上面增加多少 横线条穿过字符串的优化 123456&lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text&quot;&gt;优惠信息&lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.titledisplay: flexwidth: 80%margin: 28px auto 24px auto.lineflex: 1position: relativetop: -6pxborder-bottom: 1px solid rgba(255, 255, 255, 0.2).textpadding: 0 12pxfont-weight: 700font-size: 14px 填充图片占位由于图片异步加载如果不设置图片高度会出现闪动的bug所以需要css做些处理 123456789101112&lt;div class=&quot;image-header&quot;&gt; &lt;img :src = &quot;food.icon&quot; alt = &quot;meitu&quot; &gt; &lt;div class = &quot;back&quot; @click = &quot;hide&quot; &gt; &lt;i class=&quot;icon-arrow_lift&quot;&gt;&lt;/i&gt; &lt;/div&gt; padding-bottom设置多少根据实际需要宽高比来算123456789101112.image-header position relative width 100% height 0 padding-bottom 100% img position absolute top 0 left 0 width 100% height 100%","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://mariogogogo.github.io/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"http://mariogogogo.github.io/tags/CSS/"}]},{"title":"认识下position:sticky","slug":"认识下positionsticky","date":"2019-01-14T16:00:00.000Z","updated":"2020-09-16T09:07:11.000Z","comments":true,"path":"2019/01/15/认识下positionsticky/","link":"","permalink":"http://mariogogogo.github.io/2019/01/15/%E8%AE%A4%E8%AF%86%E4%B8%8Bpositionsticky/","excerpt":"什么是position:sticky？","text":"什么是position:sticky？sticky的中文意思是“粘性的”，position:sticky表现也符合这个粘性的表现。基本上，可以看出是position:relative和position:fixed的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。 其他特性position:sticky有个非常重要的特性，那就是sticky元素效果完全受制于父级元素们。 这和position:fixed定位有着根本性的不同，fixed元素直抵页面根元素，其他父元素对其left/top定位无法限制。 根据我简单的测试，发现了sticky元素以下一些特性表现： 父级元素不能有任何overflow:visible以为的overflow设置，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）。因此，如果你的position:sticky无效，看看是不是某一个祖先元素设置了overflow:hidden，移除之即可。同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。sticky定位，不仅可以设置top，基于滚动容器上边缘定位；还可以设置bottom，也就是相对底部粘滞。如果是水平滚动，也可以设置left和right值。 12345h4 &#123; position: -webkit-sticky; position: sticky; top: 0;&#125; demo如下：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mariogogogo.github.io/tags/CSS/"}]},{"title":"试试使用CSS实现抛物线运动效果","slug":"试试使用CSS实现抛物线运动效果","date":"2019-01-12T16:00:00.000Z","updated":"2020-09-16T09:07:12.000Z","comments":true,"path":"2019/01/13/试试使用CSS实现抛物线运动效果/","link":"","permalink":"http://mariogogogo.github.io/2019/01/13/%E8%AF%95%E8%AF%95%E4%BD%BF%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%8A%9B%E7%89%A9%E7%BA%BF%E8%BF%90%E5%8A%A8%E6%95%88%E6%9E%9C/","excerpt":"今天参考张鑫旭空间的另一篇文件","text":"今天参考张鑫旭空间的另一篇文件—&gt; 点击链接 效果图 实现的原理分析 抛物线运动元素使用至少内外两层标签,抛物线元素内外两次标签一个负责水平方向的translate移动， 一个负责垂直方向的translate移动， 然后使用不同的缓动函数，也就是使用不同的timing-function， 在CSS3 animation动画效果中是animation-timing-function属性 CSS3 transition-timing-function 属性transition-timing-function:属性规定过渡效果的速度曲线。该属性允许过渡效果随着时间来改变其速度。 transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n); 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 123456789.fly-item &#123; /* 水平移动，线性匀速 */ transition-timing-function: linear;&#125;.fly-item &gt; img &#123; /* 垂直移动，先慢后快 */ transition-timing-function: cubic-bezier(.96,.16,.99,.97);&#125; 其中cubic-bezier(.96,.16,.99,.97);我们可以借助cubic-bezier.com工具 12.ball-x &#123; animation-timing-function: linear; &#125;.ball-y &#123; animation-timing-function: cubic-bezier(.55, 0, .85, .36); &#125; 贴上代码css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*&#123;margin: 0;padding: 0;&#125;.image-x&#123;position: relative;padding: 100px 200px;&#125; .btn-cart &#123;position: absolute;display: block;width: 100px;height: 30px;left: 15.84%;top: 84.8392%;background: #0088CC;color: #fff;text-decoration: none;&#125;.fly-item,.fly-item&gt;img &#123;position: absolute;width: 50px;height: 50px;transition: transform .5s;&#125;.fly-item &#123;display: none;/* margin: -25px 0 0 -25px; */transition-timing-function: linear;opacity: .5;&#125;.fly-item &gt; img &#123;transition-timing-function:cubic-bezier(.96,.16,.99,.97);outline: 1px solid rgb(221, 46, 59);&#125;.shop-cart &#123;width: 283px;height: 25px;line-height: 25px;padding-top: 8px;background:red;font-family: &#x27;microsoft yahei&#x27;;font-size: 12px;text-indent: 34px;color: #000;position: fixed;right: 10px;bottom: 0;&#125;html123456&lt;div class=&quot;image-x&quot;&gt;&lt;a href=&quot;javascript:&quot; id=&quot;btnCart&quot; class=&quot;btn-cart&quot;&gt;添加到购物车&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;shopCart&quot; class=&quot;shop-cart&quot;&gt;购物车 &lt;span&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;flyItem&quot; class=&quot;fly-item&quot;&gt;&lt;img src=&quot;img/book.jpg&quot;&gt;&lt;/div&gt; javascript1234567891011121314151617181920212223242526272829303132333435363738394041var eleBtn = document.getElementById(&#x27;btnCart&#x27;);var eleFlyItem = document.getElementById(&quot;flyItem&quot;);var eleFlyImg = eleFlyItem.querySelector(&quot;img&quot;);var eleCart = document.querySelector(&quot;#shopCart&quot;);var isRuning = false;eleBtn.addEventListener(&quot;click&quot;, function() &#123;// 现在按钮距离购物车的距离var boundBtn = eleBtn.getBoundingClientRect();var boundCart = eleCart.getBoundingClientRect();console.log(boundBtn, boundCart);//中心点的水平距离var offsetX = boundCart.left + boundCart.width / 2 - (boundBtn.left + boundBtn.width / 2);var offsetY = boundCart.top + boundCart.height / 2 - (boundBtn.top + boundBtn.height / 2);//页面滚动距离var scrollTop = document.documentElement.scrollTop || document.body.scrollTop || 0;var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft || 0;console.log(scrollTop, scrollLeft);if (!isRuning) &#123; eleFlyItem.style.display = &quot;block&quot;; //显示抛物体 eleFlyItem.style.left = (boundBtn.left + scrollLeft + this.clientWidth / 2) + &#x27;px&#x27;; eleFlyItem.style.top = (boundBtn.top + scrollTop + this.clientHeight / 2) + &#x27;px&#x27;; //开始动画eleFlyItem.style.transform = &#x27;translateX(&#x27;+ offsetX +&#x27;px)&#x27;;eleFlyImg.style.transform = &#x27;translateY(&#x27;+ offsetY +&#x27;px)&#x27;; console.log(offsetX, offsetY); isRuning = true; setTimeout(function() &#123; eleFlyItem.style.display = &quot;&quot;; eleFlyItem.style.transform = &quot;translateX(0)&quot;; eleFlyImg.style.transform = &quot;translateY(0)&quot;; isRuning = false; eleCart.querySelector(&quot;span&quot;).innerHTML = eleCart.querySelector(&quot;span&quot;).innerHTML * 1 + 1 &#125;, 500)&#125;&#125;)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"购物物品抛物线到购物车","slug":"购物物品抛物线到购物车","date":"2019-01-11T16:00:00.000Z","updated":"2020-09-16T09:07:04.000Z","comments":true,"path":"2019/01/12/购物物品抛物线到购物车/","link":"","permalink":"http://mariogogogo.github.io/2019/01/12/%E8%B4%AD%E7%89%A9%E7%89%A9%E5%93%81%E6%8A%9B%E7%89%A9%E7%BA%BF%E5%88%B0%E8%B4%AD%E7%89%A9%E8%BD%A6/","excerpt":"今天写点外卖看到elm这个效果非常好，突发奇想实现下试试，于是写了几个非常不理想，然后各种谷歌，最后有一些小的收获分享","text":"今天写点外卖看到elm这个效果非常好，突发奇想实现下试试，于是写了几个非常不理想，然后各种谷歌，最后有一些小的收获分享效果1 效果2 1、原理及分析一开始的时候，我还在图上花了一些实现购物车的原理，但是很快发现不行，所以补了一下购物车的知识，在网上找到了公式 y=axx + b*x+c 下面的实现就很简单了： 找到三个点（x1,y1）,（x2,y2）,（x3,y3） 第一个点取：抛物线开始的点，也就是点击购物的按钮的地方（x1,y1） 第二个点取：抛物线结束的点，也就是购物车的位置（x3,y3） 第三个点取：其实结束的点往左一点取就可以了，可以是结束的点（x3-10,y3-8）,这里可以通过减的值调整抛物线的弧度 思路我再捋一捋，抛物线函数y = a*x*x + b*x + c ,其中a不等于0，a、b、c为常数。x、y为抛物线经过的坐标；a决定抛物线的开口方向，a&gt;0开口向上，a&lt;0开口向下。很明显天猫的抛物线开口向下，a还决定开口的大小，值越小开口越大，抛物线越平顺，反之抛物线越陡。所以a的值可以自定义，等于是已知两个坐标（起点和终点坐，即元素left、top值），求两个未知数，初中的数学就学过，二元二次方程。 12y1 ＝ a*x1*x1 + b*x1 + cy2 = a*x2*x2 + b*x2 + c a已知，代入两个已知坐标［x1, y1］[x2, y2]可以得出b、c的值，x和y的对应关系有了。 不管抛物线开口向上还是向下，元素在水平方向上移动的速度不变，即left值匀速改变，可以设定抛物线运动时间t，元素在水平方向上的速度为speedx =（x2 - x1）/t，设置一个定时器，每30ms执行一次，left值在每次定时器执行后的值为当前的x ＝ speedx 定时器已执行时长，再代入函数y ＝ axx + bx + c得到top值，由于这一切的计算都建立在起点坐标平移到原点（终点也随之平移）的基础上，所以最终设置运动元素的left／top值的时候必须将起点元素的初始left／top值加上。 代码如下：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"Object.defineProperty了解下","slug":"Object.defineProperty了解下","date":"2019-01-07T16:00:00.000Z","updated":"2020-09-16T09:07:44.000Z","comments":true,"path":"2019/01/08/Object.defineProperty了解下/","link":"","permalink":"http://mariogogogo.github.io/2019/01/08/Object.defineProperty%E4%BA%86%E8%A7%A3%E4%B8%8B/","excerpt":"方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。","text":"方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 参数 参数名 说明 obj 目标对象 prop 需要定义的属性或方法的名字。 descriptor 目标属性所拥有的特性。 特性 特性名 说明 value 属性的值 writable 如果为false，属性的值就不能被重写。 get 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。 set 一旦目标属性被赋值，就会调回此方法。 configurable 如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化。 enumerable 是否能在for…in循环中遍历出来或在Object.keys中列举出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 try &#123; var a = &#123;&#125;Object.defineProperty(a, &quot;p&quot;, &#123; value:&quot;这是一个不可变的默认值&quot;,writable:false&#125;);console.log(a.p);a.p=&quot;改写&quot;;console.log(a.p);&#125; catch (e) &#123;console.log(&#x27;你的浏览器不支持&#x27;)&#125;try &#123;var obj = &#123; foo: &quot;test&quot;&#125;;console.log(JSON.stringify(Object.getOwnPropertyDescriptor(obj, &quot;foo&quot;)));&#125; catch (e) &#123;console.log(&quot;你的游览器不支持Object.defineProperty或 Object.getOwnPropertyDescriptor&quot;)&#125; &quot;use strict&quot;; try&#123; var o = &#123;&#125;; Object.defineProperty( o, &quot;attr&quot;, &#123; value: &quot;这是利用defindProperty添加的新属性&quot;, writable: false, //不可重写 enumerable: true, //可枚举 configurable: true //可删除该属性 &#125;); (function()&#123; var name = &quot;帅哥你好&quot;; //读写器 Object.defineProperty( o, &quot;name&quot;, &#123; get: function()&#123; return name; &#125;, set: function(value)&#123; name = value+&quot;!!!&quot;; &#125; &#125;); &#125;)(); console.log( o.attr ) // 这是利用defindProperty添加的新属性 console.log( o.name ); // 帅哥你好 o.name = &quot;javascript&quot;; console.log( o.name ); // javascript console.log( Object.keys(o))//attr try&#123; o.attr = &quot;试图重写该属性&quot;; &#125;catch(ee)&#123; console.log(&quot;与writable: false冲突&quot;); &#125; Object.defineProperty( o, &quot;attr&quot;, &#123; writable: true, configurable: false &#125;); o.attr = &quot;再试尝试重写该属性&quot;; console.log( o.attr ); console.log(delete o.attr); //false 与writable: false冲突 &#125;catch(e)&#123; console.log(&quot;你的游览器不支持Object.defineProperty &quot;) &#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"swift4基本运算符","slug":"swift4基本运算符","date":"2019-01-01T16:00:00.000Z","updated":"2020-09-16T09:07:52.000Z","comments":true,"path":"2019/01/02/swift4基本运算符/","link":"","permalink":"http://mariogogogo.github.io/2019/01/02/swift4%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"大多数方法与javascript类型不做过多描述一个例子带过","text":"大多数方法与javascript类型不做过多描述一个例子带过 3.1赋值运算符12345678let b = 10var a = 5;a = b;print(a) // 10let (x,y) = (1,2)print(x) //1print(y) //2 3.2算数运算符加减乘除12let a = 9 ,b =4print(&quot;取余\\(a%b)&quot;) //1 3.3组合赋值运算符123var a = 1a +=2print(a) //3 3.4比较运算符 == = &gt; &lt; 3.5三目运算符1实发奖金 = 奖金 ？ 基本工资+5000 ：基本工资+ 300 3.6空合运算符空合运算 a??b 类似 a != nil ? a! : b 表达式a必须是个可选类型 默认值b的类型与a的储存值保持一致 如果a是非空 则b就不会被估值 1234567let default = &quot;red&quot;var userName : String?var name = userName ?? default 3.7区间运算符闭区间 a…b 半开间 a..&lt;b 1234567891011for index in 1...5&#123; print(index)&#125;let count = names.countfor i in 0..&lt;count&#123; print(i)&#125; 3.8逻辑运算符!a a&amp;&amp;b a||b","categories":[{"name":"Swift","slug":"Swift","permalink":"http://mariogogogo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://mariogogogo.github.io/tags/Swift/"}]},{"title":"swift4语法基础","slug":"swift4语法基础","date":"2018-12-31T16:00:00.000Z","updated":"2020-09-16T09:07:52.000Z","comments":true,"path":"2019/01/01/swift4语法基础/","link":"","permalink":"http://mariogogogo.github.io/2019/01/01/swift4%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"介绍下变量和常量","text":"介绍下变量和常量 2.1变量与常量let代表常量 1let MAX_VALUE = 25 var代表变量 1var currentCount = 100 注意：一旦常量或变量确定类型，就不能使用相同名称再次声明或改变它的类型，同时常量与变量不能相互转换 2.2注释//代表单行注释/+代表多行注释*+**/ 2.3分号基本上不需要分号除非：1let sun = &quot;☀️&quot;；print(sun) 2.4整数整数表示：正数，负数，零 2.5浮点数浮动数Double，Float 2.6类型安全和类型推断如果我们的代码需要一个string类型的值，就绝对不会传过去一个Int类型的值，有了类型推断，编译器根据我们给的相关变量，常量，或类测属性复制，在编译器自动推断表达式的类型，只要我们声明常量或变量赋予它一个”字面量“就会触发类型推断 12345let age= 23let name = &quot;jack&quot;let pi = 3.1415926let 面积 = pi * pow(3,2) 2.7数值型字面量12345let Interger = 17let twojinzhi = 0b0001let bajinzhi = 0o21let shiliujinzhi = 0x11 2.8数值类型转换整数与浮动数相互转化 12345678//int -&gt; dlet three = 3;let point = 0.14159;let pis = Double(three) + point;//d -&gt; intlet intPi = Int(pis) 类型别名：就是给现有的类型定义另一个名字，可以使typealias关键词定义类型别名 1typealias AudioSample = UInt16 2.9布尔值1234567let hasKey = trueif(hasKey)&#123; print(&#x27;kaimen&#x27;)&#125;else&#123; print(&#x27;guanmen&#x27;)&#125; 2.10元组元组的定义：临时把任意数据的多个值组合起来的一个复合类型，适用手机客户端webapi请求返回的数据集合 12345var http404Error = (404,&quot;没找到页面&quot;)//通过下标来找var code = http404Error.0var msg = http404Error.1 2.11可选类型可选类型定义：用来处理可能缺失值得类型 12345678910111213let number = &#x27;1234&#x27;let isNumber = Int(number)if(isNumber != nil)&#123; print(&quot;is number:\\(isNumber)&quot;)&#125;else&#123; print(&quot;not number:\\(isNumber)&quot;) // Optional(1234) print(&quot;not number:\\(isNumber!)&quot;) // 1234&#125; 增加isNumber!拆包 我们只能给可选类型的变量赋予nil值，它表示没有值。 建议声明变量时候设置为可选变量，他们会自动设置默认值nil 123var emptyString :String?print(emptyString) // nil 如果确定有默认值则 123var reward：Int! = 8_000print(reward) // 8000 2.12错误处理当函数遇到一个错误情况时，它就会出现throw一个错误 123456789101112func hasError() throws&#123; print (&#x27;处理抛出错误&#x27;)&#125;try hasError()do&#123; try &lt;# throwing expression #&gt;&#125; catch &lt;#pattenrn#&gt;&#123; &lt;#statements#&gt;&#125; 2.13断言断言：主要用于运行时调试 12345let andAge = 16assert(andAge &gt; 16,&quot;andyde 年龄没有到16岁&quot;) //执行这句","categories":[{"name":"Swift","slug":"Swift","permalink":"http://mariogogogo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://mariogogogo.github.io/tags/Swift/"}]},{"title":"2018 年总结","slug":"2018总结","date":"2018-12-29T16:00:00.000Z","updated":"2020-09-16T09:06:53.000Z","comments":true,"path":"2018/12/30/2018总结/","link":"","permalink":"http://mariogogogo.github.io/2018/12/30/2018%E6%80%BB%E7%BB%93/","excerpt":"2018 年成长的还是太慢，写了 NET 写了 RN 写了 ANDROID","text":"2018 年成长的还是太慢，写了 NET 写了 RN 写了 ANDROID 2019 年想扩展自己的技能学一门别的语言-Swift，给自己 4 个月的下班时间，加油 ⛽️，2019 年最重要的还有涨工资啊","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/tags/Web/"}]},{"title":"React系列_redux-Immutable","slug":"React系列_redux-Immutable ","date":"2018-12-15T16:00:00.000Z","updated":"2020-09-16T09:07:47.000Z","comments":true,"path":"2018/12/16/React系列_redux-Immutable /","link":"","permalink":"http://mariogogogo.github.io/2018/12/16/React%E7%B3%BB%E5%88%97_redux-Immutable%20/","excerpt":"Immutable 是什么？ 简而言之，Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变","text":"Immutable 是什么？ 简而言之，Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变 首先熟悉一些常用api的用法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const immutable = require(&#x27;immutable&#x27;);let &#123; Map, List, is &#125; = immutable;let a = Map(&#123; select: &#x27;users&#x27;, filter: Map(&#123; name: &#x27;Cam&#x27; &#125;),&#125;);let b = a.set(&#x27;select&#x27;, &#x27;people&#x27;);console.log(a === b);console.log(a.get(&#x27;filter&#x27;) === b.get(&#x27;filter&#x27;));const map = Map(&#123; a: 1, b: 2 &#125;);const list = List([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);console.log(map.get(&#x27;c&#x27;));console.log(list.get(21));immutable.fromJS(&#123; a: &#x27;123&#x27;, b: &#x27;234&#x27; &#125;, function(key, value, path) &#123; console.log(key, value, path);&#125;);//================================const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;);const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;);console.log(map1 === map2); //falseconsole.log(Object.is(map1, map2)); // falseconsole.log(is(map1, map2)); // true//=================================List.isList([]); // falseislist1 = List.isList(List([1, 2, 3, 4, 5])); // trueconsole.log(islist1);console.log(List([1, 2, 3, 4, 5]).push(2222222222));List([0, 1, 2, 3, 4]).insert(6, 5);//List [ 0, 1, 2, 3, 4, 5 ]List([1, 2, 3, 4]).push(5);// List [ 1, 2, 3, 4, 5 ]List([1, 2, 3, 4]).pop();// List[ 1, 2, 3 ]List([2, 3, 4]).unshift(1);// List [ 1, 2, 3, 4 ]List([0, 1, 2, 3, 4]).shift();// List [ 1, 2, 3, 4 ]console.log(List([1, 2, 3, 4, 5]).size);Map.isMap(&#123;&#125;); // falseismap1 = Map.isMap(Map()); // trueconsole.log(ismap1);//=================set==============const setlist = List([0]);console.log(&#x27;set &#x27; + setlist);const setlist2 = setlist.set(2, &#x27;abc&#x27;);console.log(&#x27;set &#x27; + setlist2);const setmap = Map();const setmap2 = setmap.set(&#x27;key&#x27;, &#x27;value&#x27;);console.log(setmap2);const setmap3 = setmap2.set(&#x27;k&#x27;, &#x27;hello value&#x27;, &#x27;b&#x27;, &#x27;ima&#x27;);console.log(setmap3);const deepmap = Map(&#123; subObject: Map(&#123; key: &#x27;hello react&#x27;, object: Map(&#123; key: &#x27;hello word&#x27;, &#125;), &#125;),&#125;);const newMap = deepmap.setIn([&#x27;subObject&#x27;, &#x27;key&#x27;], &#x27;update helo&#x27;);console.log(newMap);const secondMap = deepmap.setIn([&#x27;subObject&#x27;, &#x27;object&#x27;, &#x27;key&#x27;], &#x27;😁update word!&#x27;);console.log(secondMap);//=================delete==============const del = List([0, 1, 2, 3, 4]).delete(0);console.log(&#x27;删除后的数组： &#x27; + del);const originalMap = Map(&#123; key: &#x27;value&#x27;, otherKey: &#x27;other value&#x27;,&#125;);const del2 = originalMap.delete(&#x27;otherKey&#x27;);console.log(&#x27;删除后的对象&#x27; + del2);//==============merge============const Map1 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;d:333,e:444&#125;&#125;); const Map2 = Immutable.fromJS(&#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125;); const Map3 = Map1.merge(Map2); //Map &#123;a:111,b:222,c:&#123;e:444,f:555&#125;&#125; const Map4 = Map1.mergeDeep(Map2); //Map &#123;a:111,b:222,c:&#123;d:333,e:444,f:555&#125;&#125; const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;&#123; if(key === &#x27;a&#x27;)&#123; return 666; &#125;else&#123; return newData &#125; &#125;,Map2); //Map &#123;a:666,b:222,c:&#123;e:444,f:555&#125;&#125; 项目中如何用呢？首先修改redurce.js123456789101112131415161718192021import &#123; fromJS &#125; from &#x27;immutable&#x27;;//普通对象转换成 immutable类型对象const defaultState = fromJS(&#123; focused: false, mouseIn: false, list: [], page: 1, //当前页 totalPage: 1, //总页数&#125;);....switch (action.type) &#123; case constants.SEARCH_FOCUS: //逻辑 im根据之前的数据，返回新的数据 return state.set(&#x27;focused&#x27;, true); case constants.CHANGE_LIST: // merge多组对象中使用 return state.merge(&#123; list: action.data, totalPage: action.totalPage, &#125;); index.js获取数据1234567891011const mapStateToProps = state =&gt; &#123; return &#123; //getin[哪个分支reducer，分支上的数据字段] focused: state.getIn([&#x27;header&#x27;, &#x27;focused&#x27;]), list: state.getIn([&#x27;header&#x27;, &#x27;list&#x27;]), page: state.getIn([&#x27;header&#x27;, &#x27;page&#x27;]), totalPage: state.getIn([&#x27;header&#x27;, &#x27;totalPage&#x27;]), mouseIn: state.getIn([&#x27;header&#x27;, &#x27;mouseIn&#x27;]), login: state.getIn([&#x27;login&#x27;, &#x27;isLogin&#x27;]), &#125;;&#125;;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_combineReducers","slug":"React系列_combineReducers","date":"2018-12-14T16:00:00.000Z","updated":"2020-09-16T09:07:46.000Z","comments":true,"path":"2018/12/15/React系列_combineReducers/","link":"","permalink":"http://mariogogogo.github.io/2018/12/15/React%E7%B3%BB%E5%88%97_combineReducers/","excerpt":"随着应用变得复杂，需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分。","text":"随着应用变得复杂，需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分。combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 先看下demo结构 创建storesrc/store/index.js12345678910import &#123; createStore, compose, applyMiddleware &#125; from &#x27;redux&#x27;;import thunk from &#x27;redux-thunk&#x27;;import reducer from &#x27;./reducer&#x27;;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk)));export default store;src/store/redurcer.js 1234567891011121314import &#123; combineReducers &#125; from &#x27;redux-immutable&#x27;;import &#123; reducer as headerReducer &#125; from &#x27;../common/header/store&#x27;;import &#123; reducer as homeReducer &#125; from &#x27;../pages/home/store&#x27;;import &#123; reducer as detailReducer &#125; from &#x27;../pages/detail/store&#x27;;import &#123; reducer as loginReducer &#125; from &#x27;../pages/login/store&#x27;;const reducer = combineReducers(&#123; header: headerReducer, //key值 ： value值 home: homeReducer, detail: detailReducer, login: loginReducer,&#125;);export default reducer; /src/page/header/index.js 12345import reducer from &#x27;./reducer&#x27;;import * as actionCreators from &#x27;./actionCreators&#x27;;import * as constants from &#x27;./constants&#x27;;export &#123; reducer, actionCreators, constants &#125;; 这样写的好处是src/store/redurcer.js下的引用分支redurce目录结构少写2层。易读 1234567891011121314151617181920import &#123; fromJS &#125; from &#x27;immutable&#x27;;import * as constants from &#x27;./constants&#x27;;const defaultState = fromJS(&#123; title: &#x27;&#x27;, content: &#x27;&#x27;&#125;);export default (state = defaultState, action) =&gt; &#123; switch(action.type) &#123; case constants.CHANGE_DETAIL: // 逻辑处理返回纯函数 return state.merge(&#123; title: action.title, content: action.content &#125;) default: return state; &#125;&#125; 同时代码中引用reducer中也发生了变化： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; PureComponent &#125; from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;;import &#123; DetailWrapper, Header, Content &#125; from &#x27;./style&#x27;;import &#123; actionCreators &#125; from &#x27;./store&#x27;;class Detail extends PureComponent &#123; render() &#123; return ( &lt;DetailWrapper&gt; &lt;Header&gt;&#123;this.props.title&#125;&lt;/Header&gt; &lt;Content // html标签的转义用dangerouslySetInnerHTML dangerouslySetInnerHTML=&#123;&#123;__html: this.props.content&#125;&#125; /&gt; &lt;/DetailWrapper&gt; ) &#125; componentDidMount() &#123; this.props.getDetail(this.props.match.params.id); &#125;&#125;const mapState = (state) =&gt; (&#123; title: state.getIn([&#x27;detail&#x27;, &#x27;title&#x27;]), content: state.getIn([&#x27;detail&#x27;, &#x27;content&#x27;])&#125;);const mapDispatch = (dispatch) =&gt; (&#123; getDetail(id) &#123; dispatch(actionCreators.getDetail(id)); &#125;&#125;);export default connect(mapState, mapDispatch)(withRouter(Detail));// 他的意思是我让detail有能力获取router中的一些参数","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_react-redux","slug":"React系列_react-redux","date":"2018-12-14T16:00:00.000Z","updated":"2020-09-16T09:07:47.000Z","comments":true,"path":"2018/12/15/React系列_react-redux/","link":"","permalink":"http://mariogogogo.github.io/2018/12/15/React%E7%B3%BB%E5%88%97_react-redux/","excerpt":"首先下载 1yarn add react-redux","text":"首先下载 1yarn add react-redux 创建一个store123456import &#123; createStore &#125; from &#x27;redux&#x27;;import reducer from &#x27;./reducer&#x27;;const store = createStore(reducer);export default store;入口文件.js12345678910111213import store from &#x27;./store&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; getInputChange, addItem, deleteItem, GetItem &#125; from &#x27;./store/actionCreators&#x27;;class todoList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.props.inputValue&#125; onChange=&#123;this.props.changeInputValue&#125; /&gt; &lt;button onClick=&#123;this.props.handleBtnClcik&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;Dall&lt;/li&gt; &#123;this.props.list.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; inputValue: state.inputValue, list: state.list, &#125;;&#125;;const mapDispathchToProps = dispatch =&gt; &#123; return &#123; changeInputValue(e) &#123; console.log(e.target.value); const action = getInputChange(e.target.value); dispatch(action); &#125;, handleBtnClcik() &#123; console.log(&#x27;提交&#x27;); const action = addItem(); dispatch(action); &#125;, &#125;;&#125;;export default connect( mapStateToProps, mapDispathchToProps)(todoList); 创建reducer.js 12345678910111213141516171819202122import &#123; CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_TODO_ITEM &#125; from &#x27;./actionTypes&#x27;;const defaultState = &#123; inputValue: &#x27;&#x27;, list: [],&#125;;export default (state = defaultState, action) =&gt; &#123; console.log(state, action); const newState = JSON.parse(JSON.stringify(state)); //深拷贝 if (action.type === CHANGE_INPUT_VALUE) &#123; newState.inputValue = action.value; return newState; &#125; if (action.type === ADD_TODO_ITEM) &#123; newState.list = [...newState.list, newState.inputValue]; newState.inputValue = &#x27;&#x27;; return newState; &#125; return state;&#125;;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_redux-saga","slug":"React系列_redux-thunk","date":"2018-12-13T16:00:00.000Z","updated":"2020-09-16T09:07:48.000Z","comments":true,"path":"2018/12/14/React系列_redux-thunk/","link":"","permalink":"http://mariogogogo.github.io/2018/12/14/React%E7%B3%BB%E5%88%97_redux-thunk/","excerpt":"redux如何使用异步请求","text":"redux如何使用异步请求首先看下简单的使用请求 123456789componentDidMount = () =&gt; &#123; axios.get(&#x27;http://rap2api.taobao.org/app/mock/8651/api/tuangou&#x27;).then(res =&gt; &#123; console.log(res); const data = res.data; const action = initData(data); store.dispatch(action); &#125;); &#125;; actionCreator.js 12345export const initData = data =&gt; (&#123; type: INIT_TODO_ITEM, data: data,&#125;); redurce.js 1234if (action.type === INIT_TODO_ITEM) &#123; newState.list = action.data.data; return newState;&#125; 如果异步请求方法过多，代码看起来就比较臃肿所有必须提取出来统一管理 首先安装 1yarn add redux-saga 重新配置stroe 1234567891011121314151617import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;+ import createSagaMiddleware from &#x27;redux-saga&#x27;;import reducer from &#x27;./reducer&#x27;;+ import mySaga from &#x27;./sagas&#x27;;/** * 引入reduce后 store就存在了 inputvalue和list的数据 */// create the saga middleware+ const sagaMiddleware = createSagaMiddleware();// mount it on the Storeconst store = createStore(reducer, applyMiddleware(sagaMiddleware));// then run the sagasagaMiddleware.run(mySaga);export default store; //暴露 首先主文件index.js 1234567import &#123; getInputChange, addItem, deleteItem, GetItem &#125; from &#x27;./store/actionCreators&#x27;;//发送actioncomponentDidMount = () =&gt; &#123; const action = GetItem(); store.dispatch(action); &#125;; actionCreator.js 123456789&#x2F;&#x2F;异步请求的action ----&gt;saga去接收export const GetItem &#x3D; () &#x3D;&gt; (&#123; type: ANSYNC_INIT_ITEM,&#125;);&#x2F;&#x2F;请求之后获取action ---&gt;redurcer去接收export const initData &#x3D; data &#x3D;&gt; (&#123; type: INIT_TODO_ITEM, data: data,&#125;); saga.js 123456789101112131415161718192021import &#123;call,fork, put, takeEvery &#125; from &#x27;redux-saga/effects&#x27;;import axios from &#x27;axios&#x27;;import &#123; ANSYNC_INIT_ITEM &#125; from &#x27;./actionTypes&#x27;;import &#123; initData &#125; from &#x27;./actionCreators&#x27;;function* getInitList() &#123; try &#123; const res = yield axios.get(&#x27;http://rap2api.taobao.org/app/mock/8651/api/tuangou&#x27;); console.log(res); // yield put(&#123; type: INIT_TODO_ITEM, data: res.data &#125;); //发送action--&gt; yield put(initData(res.data)); &#125; catch (e) &#123; throw new Error(&#x27;网络请求返回错误&#x27; + e); &#125;&#125;function* mySaga() &#123; yield takeEvery(ANSYNC_INIT_ITEM, getInitList);&#125;export default mySaga; redurcer.js 12345if (action.type === INIT_TODO_ITEM) &#123; newState.list = action.data.data; return newState; &#125; sagaAPI简单介绍：Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。 call 和 forkcall和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。 put和selectput对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。 take、takeEvery、takeLatestredux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。 如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。 redux-saga的优缺点优点： （1）集中处理了所有的异步操作，异步接口部分一目了然 （2）action是普通对象，这跟redux同步的action一模一样 （3）通过Effect，方便异步接口的测试 （4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实 现非阻塞调用下的事件监听 （5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。 缺点：太复杂，学习成本较高","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_redux","slug":"简单使用redux","date":"2018-12-12T16:00:00.000Z","updated":"2020-09-16T09:07:06.000Z","comments":true,"path":"2018/12/13/简单使用redux/","link":"","permalink":"http://mariogogogo.github.io/2018/12/13/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8redux/","excerpt":"为什么要使用 redux？","text":"为什么要使用 redux？ 当你去开发复杂的单页应用的时候你需要管理各种复杂的应用状态，这鞋状态可能是服务器返回的状，态，本地的数据 url redux 可预测的状态管理 只维护数据 看图： redux 流程 首先创建 Store /src/store/index 1234567import &#123; createStore &#125; from &#x27;redux&#x27;;/** * 引入reduce后 store就存在了 inputvalue和list的数据 */const store = createStore();export default store; //暴露 index.js 中引入 store 12345678910import React, &#123; Component &#125; from &#x27;react&#x27;;import store from &#x27;./store&#x27;; //引入store中的数据class Todolist extends Component &#123; constructor(props) &#123; super(props); console.log(store.getState()); this.state = store.getState(); .... 但此时 store 并无数据我们再创建一个 redurce /src/store/reducer 123456789101112131415161718/** * state 相当于整个项目存的数据 * action 相当于 */const defaultState = &#123; inputValue: &#x27;&#x27;, list: [&#x27;a&#x27;, &#x27;b&#x27;],&#125;;export default (state = defaultState, action) =&gt; &#123; /** * state 是前一次的数据 */ console.log(state, action); //reducer 接受到 store传过来的action return state;&#125;; 然后再回到 store 中把 reducer 导入 123456789import &#123; createStore &#125; from &#x27;redux&#x27;;+ import reduce from &#x27;./reducer&#x27;;/** * 引入reduce后 store就存在了 inputvalue和list的数据 */+ const store = createStore(reduce);export default store; //暴露 派发 action 123456789101112131415161718192021222324252627282930render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入&quot; value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;button onClick=&#123;this.onSumbit&#125;&gt;提交&lt;/button&gt; &lt;ul&gt; &#123;this.state.list.map((item, index) =&gt; ( &lt;li onClick=&#123;this.handleItemDelete.bind(this, index)&#125; key=&#123;index&#125;&gt; &#123;item&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125; handleInputChange(e) &#123; const action = &#123; type: &#x27;changeText&#x27;, value: e.target.value, &#125;; store.dispatch(action); //传给store &#125; onSumbit() &#123; const action = &#123; type: &#x27;addList&#x27;, &#125;; store.dispatch(action); &#125; action –&gt; store –&gt; reducer 中找到更新 state 的方法 redurce.js 123456789101112export default (state = defaultState, action) =&gt; &#123; /** * state 是前一次的数据 */ console.log(state, action); //reducer 接受到 store传过来的action const newState = JSON.parse(JSON.stringify(state)); //深拷贝 if (action.type === &#x27;changeText&#x27;) &#123; newState.inputValue = action.value; return newState; &#125; ........ redurce –&gt; 返回新 state 到 Store 中,只有 stroe 改变自己的内容—&gt;返回给组件触发组件更新 监听 redurce 返回的新 state 1234567891011121314constructor(props) &#123; super(props); this.state = store.getState(); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); //监听store的变化 &#125; .... handleStoreChange() &#123; console.log(&#x27;storechange&#x27;); this.setState(store.getState()); &#125; .... 整一个流程大致是这样的 我们还可以做些什么呢？ 规范化 redux：ActionTypes 的拆分当我们有很多个 action 的时候，如果一个 action 方法名拼写字符串错误导致，是很难被发现的，如果是变量发现异常就很容易定位到错误，所有我们要引入 ActionTypes.js src/store/actionTypes.js 123export const CHANGE_INPUT_VALUE &#x3D;change_input_value &#39; ;export const ADD_TODO_ITEM &#x3D;add_todo_item&#39; ;export const DELETE_TODO_ITEM &#x3D;&#39;delete_todo_item&#39; ; index.js 12345678910111213import &#123;DELETE_TODO_ITEM&#125; = from &#x27;./store/actionTypes&#x27;...handleItemDelete(index) &#123; const action = &#123; type: DELETE_TODO_ITEM, //引入 index: index, &#125;; const bool = window.confirm(`你确定删除第$&#123;index&#125;个数吗?`); if (bool) &#123; store.dispatch(action); &#125; 同时还要改变 reducer 123456import &#123;DELETE_TODO_ITEM&#125; = from &#x27;./actionTypes&#x27;if (action.type === DELETE_TODO_ITEM) &#123; newState.list.splice(action.index, 1); return newState; &#125; 使用 actionCreator 统一管理 action123456789101112131415import &#123; CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM &#125; from &#x27;./actionTypes&#x27;;export const getInputChange = value =&gt; (&#123; type: CHANGE_INPUT_VALUE, value,&#125;);export const addItem = () =&gt; (&#123; type: ADD_TODO_ITEM,&#125;);export const deleteItem = index =&gt; (&#123; type: DELETE_TODO_ITEM, index: index,&#125;); 引入 index.js 1234567import &#123; getInputChange, addItem, deleteItem &#125; from &#x27;./store/actionCreators&#x27;; ... handleInputChange(e) &#123; const action = getInputChange(e.target.value); store.dispatch(action); //传给store &#125;","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_ref","slug":"React系列_ref","date":"2018-12-11T16:00:00.000Z","updated":"2020-09-16T09:07:48.000Z","comments":true,"path":"2018/12/12/React系列_ref/","link":"","permalink":"http://mariogogogo.github.io/2018/12/12/React%E7%B3%BB%E5%88%97_ref/","excerpt":"在React中提供了一个特殊的属性ref，用来引用React组件或Dom元素的实例；因此我们在使用表单元素定义ref属性获取元素的值；","text":"在React中提供了一个特殊的属性ref，用来引用React组件或Dom元素的实例；因此我们在使用表单元素定义ref属性获取元素的值； 例如： 12345678910111213141516171819202122export default class Ref extends Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; // 通过this.input获取value值; alert(&#x27;this title you submitted was&#x27; + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; title: &lt;input type=&quot;text&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; ref的值是一个函数，这个函数会接受当前元素作为参数上面的例子中如果是非受控组件我们还可以通过defaultValue属性设置默认值；比如： 123&lt;input type=&quot;text&quot; defaultValue=&quot;请输入有效字符😁&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt; 但是 我们基本上很少那么做这种方式破坏了React组件状态管理的一致性，不建议大家使用； 接下来我们归纳几个使用ref的场景在Dom中使用ref跟之前例子相似 123456789101112131415161718export default class Ref extends Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; componentDidMount = () =&gt; &#123; this.input.focus(); //自动获取焦点 &#125;; render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在组件上使用ref此时ref的回调函数接收的参数是当前组件的实例；这提供了一种在组件外部操作组件的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class A extends Component &#123; constructor(props) &#123; super(props); this.blur = this.blur.bind(this); &#125; componentDidMount = () =&gt; &#123; this.input.focus(); //自动获取焦点 &#125;; //失去焦点 blur() &#123; this.input.blur(); alert(&#x27;我失去焦点前的值：&#x27; + this.input.value); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;input =&gt; (this.input = input)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class B extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log(this.inputInstance); console.log(this.inputInstance.input.value); this.inputInstance.blur(); &#125; render() &#123; return ( &lt;div&gt; &lt;A ref=&#123;input =&gt; (this.inputInstance = input)&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;失去焦点&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default B; 通过上述例子中可以看出ref获取了A组件的实例，并把它复制给B组件的inputInstance属性，直接调用A组件中的方法 注意：只能使用类组件定义ref属性，而不能使用函数组件定义ref 父组件访问子组件Dom节点（暂时有点难理解慢慢消化）在一些场景中我们可能在父组件调用子组件的某个元素，例子父组件想知道这个dom的尺寸或者信息，直接用ref是无法实现的，因为ref只能获取子组件的实例对象，而不能获取子组件中的某个Dom元素 12345678910111213141516171819202122function Children(props) &#123; //子组件使用父组件传递的inputRef，为input的ref赋值 console.log(props.inputRef); return ( &lt;div&gt; 这里输入文字： &lt;input type=&quot;text&quot; ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends Component &#123; inputElement(el) &#123; console.log(el); &#125; render() &#123; return &lt;Children inputRef=&#123;el =&gt; (this.inputElement = el)&#125; /&gt;; &#125;&#125;export default Parent; ref的值是父组件传给子组件的一个回调函数 回调函数通过自定义属性传递 例子中的inputRef 父组件的回调函数中获取这个Dom元素 父组件的inputElement指向的子组件的input 元素","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_高阶组件","slug":"React系列_高阶组件","date":"2018-12-11T16:00:00.000Z","updated":"2020-09-16T09:07:46.000Z","comments":true,"path":"2018/12/12/React系列_高阶组件/","link":"","permalink":"http://mariogogogo.github.io/2018/12/12/React%E7%B3%BB%E5%88%97_%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","excerpt":"高阶组件就是一个组件作为参数并返回一个新组件的函数高阶组件是一个函数，并不是一个组件","text":"高阶组件就是一个组件作为参数并返回一个新组件的函数高阶组件是一个函数，并不是一个组件看一张图： 为什么需要高阶组件？多个组件都需要某个相同的功能，使用高阶组件可以减少重复的实现 高阶组件的应用代理方式的高阶组件 返回的新组件类直接继承自React.Component类,新组件扮演的角色传入参，数组件的一个代理,在新组件的render函数中,将被包裹组件渲染出来,除了高阶组件自己要做得工作,其余功能全都转手给了被包裹的组件 分为： 操纵Props 抽取状态 访问ref 包装组件 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &#x27;react&#x27;;import &#x27;../app.css&#x27;;function A(WrapperComponent) &#123; return class A extends Component &#123; render() &#123; // 通过props高阶组件删除属性 const &#123; age, ...otherProps &#125; = this.props; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;header&quot;&gt; &lt;span&gt;提示&lt;/span&gt; &lt;span&gt;X&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &#123;/* 高阶组件的传入参数 */&#125; &lt;WrapperComponent sex=&#123;&#x27;男&#x27;&#125; &#123;...otherProps&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125; &#125;;&#125;export default A; 继承方式的高阶组件 采用继承关联作为参数的组件和返回的组件,假如传入的组件参数是WrappedComponent ,那么返回的组件就直接继承自WrappedComponent 1234567891011121314151617import React from &#x27;react&#x27;;const modifyPropsHOC = WrappedComponent =&gt; class newComponent extends WrappedComponent &#123; render() &#123; const element = super.render(); const newStyle = &#123; color: element.type === &#x27;div&#x27; ? &#x27;red&#x27; : &#x27;green&#x27;, &#125;; console.log(element.type); const newProps = &#123; ...this.props, style: newStyle &#125;; return React.cloneElement(element, newProps, element.props.children); &#125; &#125;;export default modifyPropsHOC; DemoGitHub例子","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"聊聊「上传」这件事情","slug":"聊聊「上传」这件事情","date":"2018-12-09T16:00:00.000Z","updated":"2020-09-16T09:07:07.000Z","comments":true,"path":"2018/12/10/聊聊「上传」这件事情/","link":"","permalink":"http://mariogogogo.github.io/2018/12/10/%E8%81%8A%E8%81%8A%E3%80%8C%E4%B8%8A%E4%BC%A0%E3%80%8D%E8%BF%99%E4%BB%B6%E4%BA%8B%E6%83%85/","excerpt":"前端要实现上传可以通过三种方法触发： 通过input type=“file”选择本地文件； 通过拖拽方式把文件拖过来； 在编辑框里面复制黏贴","text":"前端要实现上传可以通过三种方法触发： 通过input type=“file”选择本地文件； 通过拖拽方式把文件拖过来； 在编辑框里面复制黏贴 先来讲讲第一种实现12345678&lt;h1&gt;点击选择&lt;/h1&gt;&lt;form&gt;&lt;input type=&quot;file&quot; id=&quot;file-input&quot; name=&quot;filecontent&quot; /&gt;&lt;/form&gt;&lt;h1&gt;拖拽&lt;/h1&gt;&lt;div class=&quot;img-container&quot;&gt;drop you image here&lt;/div&gt;&lt;h1&gt;黏贴&lt;/h1&gt;&lt;div class=&quot;img-paste&quot; contenteditable=&quot;true&quot;&gt;hello,paste you image here&lt;/div&gt; 用FormData来获取整个表单的内容；1234567$(&#x27;#file-input&#x27;).on(&#x27;change&#x27;, function() &#123; console.log(`file name is + $&#123;this.value&#125;`); console.log(this.form); let formData = new FormData(this.form); formData.append(&#x27;filename&#x27;, this.value); console.log(formData);&#125;); 使用formData 获取的this.value是一个假的路径，也就是说浏览器无法获取文件的真实存在地址，formData也是一个空对象，但内容不是空的只是对我们来说看不见而已，只能通过append去添加字段 使用FileReader12345678910111213141516$(&#x27;#file-input&#x27;).on(&#x27;change&#x27;, function() &#123;let fileReader = new FileReader();let fileType = this.files[0].type;console.log(fileType);fileReader.onload = function() &#123; if (/^image/.test(fileType)) &#123; $(`&lt;img src=&quot;$&#123;this.result&#125;&quot; /&gt;`).appendTo(&#x27;body&#x27;); &#125;&#125;;console.log(this.files[0]);//按base64方式读取fileReader.readAsDataURL(this.files[0]);//二进制方式读取 读取结果直接转成数组fileReader.readAsArrayBuffer(this.files[0]);&#125;); 通过实例化fileReader可以看见一个文件的修改时间，文件名，文件的大小，文件的类型 拖拽图片获取图片路径123456789101112131415$(&#x27;.img-container&#x27;).on(&#x27;dragover&#x27;, function(event) &#123; event.preventDefault();&#125;).on(&#x27;drop&#x27;, function(event) &#123; event.stopPropagation(); event.preventDefault(); let fileReader = new FileReader(); let file = event.originalEvent.dataTransfer.files[0]; fileReader.readAsDataURL(file); let formData = new FormData(); console.log(file); formData.append(&#x27;filecontent&#x27;, file); console.log(formData); //读不出的&#125;); 通过复制来获取图片路径1234567$(&#x27;.img-paste&#x27;).on(&#x27;paste&#x27;, function(event) &#123;event.stopPropagation();event.preventDefault();//黏贴的数据在event.clipboardData.files中let file = event.originalEvent.clipboardData.files[0];console.log(file);&#125;); 继续写上传什么是blob？如何读取blob? 多文件上传input 属性中增加 mulitple 如何实现断点续传？有一种方法就是使用blob分割大文件上传比如","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"移动端的那些事","slug":"移动端的那些事","date":"2018-11-30T16:00:00.000Z","updated":"2020-09-16T09:07:15.000Z","comments":true,"path":"2018/12/01/移动端的那些事/","link":"","permalink":"http://mariogogogo.github.io/2018/12/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"在现如今的前端开发中移动端开发的份额已大大超过了PC端开发，掌握移动端开发技巧对前端工程师来说真的非常有必要","text":"在现如今的前端开发中移动端开发的份额已大大超过了PC端开发，掌握移动端开发技巧对前端工程师来说真的非常有必要 viewport 视口(可视区窗口) 默认不设置viewport一般可视区宽度在移动端是980 width 可视区的宽度 (number||device-width) user-scalable 是否允许用户缩放 (yes||no) iOS10无效 (我们放在事件章节解决) initial-scale 初始缩放比例 minimum-scale 最小缩放比例 maximum-scale 最大缩放比例 12345678910111213var pixRatio = 1 / window.devicePixelRatio;console.log(&#x27;像素比：&#x27; + pixRatio, window.devicePixelRatio);var html = document.documentElement;document.write( &#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=&#x27; + pixRatio + &#x27;,minimum-scale=&#x27; + pixRatio + &#x27;,maximum-scale=&#x27; + pixRatio + &#x27;&quot;&gt;&#x27;);html.style.fontSize = html.clientWidth / 25 + &#x27;px&#x27;; 像素比把一个像素 放大至 N个像素去显示 设计图最少750 其他另外的设置 123&lt;a href=&quot;tel:18888888888&quot;&gt;请拨打电话18888888888&lt;/a&gt;&lt;a href=&quot;mailto:motao@motao.com&quot;&gt;请发送邮件&lt;/a&gt; 按钮圆角的清除1234567891011a, input, button&#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;input, button &#123; -webkit-appearance: none; border-radius: 0;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"React系列_生命周期","slug":"React系列_生命周期","date":"2018-11-15T16:00:00.000Z","updated":"2020-09-16T09:07:46.000Z","comments":true,"path":"2018/11/16/React系列_生命周期/","link":"","permalink":"http://mariogogogo.github.io/2018/11/16/React%E7%B3%BB%E5%88%97_%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"React 生命周期会经历三个过程？ 挂载过程 运行时过程 卸载过程 错误处理 errorHanding（只发生在 render 阶段）","text":"React 生命周期会经历三个过程？ 挂载过程 运行时过程 卸载过程 错误处理 errorHanding（只发生在 render 阶段） 先来看下装载过程 constructor componentWillMont render componentDidMont 注意： render 调用后，componentDidMont 函数不会马上被调用，render 函数返回的东西(jsx 表示的对象)已经在渲染，组件已经被装载到了 Dom 树上 如果有三个组件 A,B,C 要三个组件全部 render 以后才能调用 componentDidMont 方法，因为 react 肯定要把所有组件全部返回结果综合起来才知道如何渲染 cwm 与 cdm 还有一个区别：cwm 可以在服务端或浏览器端调用，componentDidMont 只能在浏览器端调用； 更新过期 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 如果 1234shouldComponentUpdate () &#123; console.log(&#x27;List+shouldComponentUpdate&#x27;); return false &#125; componentWillReceiveProps表示这个只在 props 引起的组件更新过程中，才会被调用，state 的更新不会被触发，参数 nextProps 是父组件传递到当前组件的新 props，需要比较 nextprops 与当前 props 是否相等，才决定是否执行 props 变化后的逻辑，比如更新新的 props 调用 this.setState 触发组件重新渲染 注意：在此方法中调用 render，只有在组件 render 及其后的方法中，this.state 才指向更新后的 state，在 render 之前的方法 shouldComponentUpdate，componentWillUpdate 中，this.state 依然指向的更新前的 state 大部分情况下 componentWillReceiveProps 生命周期函数是没用的，即可以略去不写， 但是在 constructor 函数中初始化了某个 state，必须用 componentWillReceiveProps 来更新 state，不可省去，否则 render 中的 state 将得不到更新。同时如果您想在子组件监听 watch 值变化做处理，也可以用到 componentWillReceiveProps 使用 componentWillReceiveProps 的时候，不要去向上分发，调用父组件的相关 setState 方法，否则会成为死循环 shouldComponentUpdate表示是否继续执行更新的过程，当返回 true（默认返回值）组件会继续更新，当返回 false 则组件更新停止，后续的 cwillupdate 和 render 和 cdidupdate 都不会被调用，参数 nextProps。nextState 与组件当前的 props 和 state 比较，减少组件的渲染，优化组件的性能,但一般不建议这么做：原因是 组件在 render 中还是会 diff 比较组件之间的不同 componentWillUpdate表示在 render 调用前执行，可以作为组件更新发生前执行某些工作的地方，（很少用到） componentDidUpdate表示组件更新后被调用，有 2 个参数 prevProps preState 表示更新前的状态值，可以用来操作更新后的 Dom 地方， 卸载过期componentWillUnmount在 cwu 中用非 react 方法创造的 dom 元素，如果撒手不管的话，很可能造成内存泄露，必须在 cwu 中把这些 dom 元素清理掉；比如清除一些不必要的定时器，清除 componentWillMont 手动创建的 Dom 元素避免内存泄露 注意：只有类组件才有生命周期函数 生命周期 调用次数 getDefaultProps 调用 1 次 getInitialState 调用 1 次 componentWillMount 调用 1 次 render 调用&gt;=1 次 componentDidMount 仅客户端，调用 1 次 componentWillReceiveProps 调用&gt;=0 次 ShouldComponentUpdate 调用&gt;=0 次 componentWillUpdate 调用&gt;=0 次 render 调用&gt;=1 次 componentDidUpdate 调用&gt;=0 次 componentWillUnmount 调用 1 次 更新 react16.3 之后的生命周期react16.3 新增了一些生命周期函数： getDerivedStateFromProps getSnapshotBeforeUpdate 同时 FB 声明在 react17 将删除： componentWillMount、 componentWillReceiveProps、 componentWillUpdate 在 16.3 的版本中将保留这三个函数，并添加了别名： UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate 在此我们主要介绍 getDerivedStateFromProps getSnapshotBeforeUpdate getDerivedStateFromProps(nextProps, prevState)：从 props 派生出 state 执行次数：多次 触发条件：组件实例化及接收新 props 后调用 替代：替代原来的 componentWillReceiveProps，并且加载第一次时也调用初始化的时候 123456789101112class todoList extends Component &#123; constructor(props)&#123; console.log(&#x27;constructor&#x27;); super(props) this.state=&#123;&#125; &#125; static getDerivedStateFromProps (props, state)&#123; console.log(&#x27;getDerivedStateFromProps&#x27;); console.log(props); console.log(state); return null; &#125; 为什么要用static？static 是 ES6 的写法，当我们定义一个函数为 static 时，就意味着无法通过 this 调用我们在类中定义的方法（原理和 js 中原型链继承相关，具体我就不说了，可自行搜索）。 不足之处：在getDerivedStateFromProps中，在条件限制下(if/else)调用 setState。如果不设任何条件 setState，这个函数超高的调用频率，不停的 setState，会导致频繁的重绘，既有可能产生性能问题，同时也容易产生 bug。 getSnapshotBeforeUpdate(nextProps, prevState)：从 props 派生出 state 执行次数：多次 触发条件：组件 render 时调用 返回值：返回值传递给 componentDidUpdate(prevProps, prevState, snapshot) 替代：替代原来的 componentWillupdate 123456getSnapshotBeforeUpdate (prevProps, prevState) &#123; console.log(&#x27;getSnapshotBeforeUpdate&#x27;); console.log(prevProps); console.log(prevState); return null &#125; getSnapshotBeforeUpdate 是在 render 之后触发，它的要点在于触发时，Dom 还没有更新，开发者可以做一些事情，返回值会作为第三个参数传递给接下来将要触发的 componentDidUpdate。 作为一个不常用的生命周期，getSnapshotBeforeUpdate React 16 给的建议当然还是：能不用就尽量不要用。 - - ！！！ 最后小结：到目前为止(React 16.4)，React 的渲染机制遵循同步渲染: 首次渲染: willMount &gt; render &gt; didMount， props 更新时: receiveProps &gt; shouldUpdate &gt; willUpdate &gt; render &gt; didUpdate state 更新时: shouldUpdate &gt; willUpdate &gt; render &gt; didUpdate 卸载时: willUnmount 参考React v15 到 v16.3, v16.4 新生命周期总结以及使用场景 React 生命周期执行顺序详解","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_prop与state","slug":"React系列_prop与state","date":"2018-11-14T16:00:00.000Z","updated":"2020-09-16T09:07:47.000Z","comments":true,"path":"2018/11/15/React系列_prop与state/","link":"","permalink":"http://mariogogogo.github.io/2018/11/15/React%E7%B3%BB%E5%88%97_prop%E4%B8%8Estate/","excerpt":"什么是Prop？在React中，从外部传递给组件的数据，一个react组件通过定义自己能接受的prop就定义了自己的对外公共接口；","text":"什么是Prop？在React中，从外部传递给组件的数据，一个react组件通过定义自己能接受的prop就定义了自己的对外公共接口； prop很像HTML中的属性；当prop类型不是字符串类型，必须用花括号&#123;&#125;把prop包住，style的值要2层花括号，外层花括号代表jsx语法，内层花括号代表一个对象常量 传值12345678910class A extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;Counter caption=&quot;First&quot; initValue=&#123;0&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 读取1234567891011121314151617class Counter extends Component&#123; constructor(props)&#123; super(props) &#125; this.state=&#123; count:props.initValue || 0 &#125; render()&#123; const &#123;caption&#125; = this.props; //ES6解构赋值 renturn( ...... ) &#125;&#125; 注意：如果没有super(props)是不能使用this.props赋值的，因为类实例无法访问父组件传过来的props 什么是state？state是组件内部状态比如： 123this.state=&#123; count:props.initValue || 0 &#125; 可以使用defaultProps来初始化内部状态 1234Counter.defaultProps=&#123; initValue:0&#125; 读取和更新内部状态123456let newCount = this.state.count;this.setstate(&#123; count:newCount,&#125;) 注意setstate是个异步函数，后面可以跟一个回调函数比如: 12345678let newCount = this.state.count;this.setstate(&#123; count:newCount,&#125;,function()&#123; //请求改变数据&#125;) props与react的简单对比 prop定义外部接口，state是记录内部状态； prop的赋值在外部世界使用组件时，state的赋值在组件内部； 组件不应该改变prop的值，而state存在的目的是让组件来改变；","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"React系列_JSX","slug":"React系列_JSX","date":"2018-11-13T16:00:00.000Z","updated":"2020-09-16T09:07:47.000Z","comments":true,"path":"2018/11/14/React系列_JSX/","link":"","permalink":"http://mariogogogo.github.io/2018/11/14/React%E7%B3%BB%E5%88%97_JSX/","excerpt":"什么是JSX?12const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;","text":"什么是JSX?12const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; jsx代码看起来和HTML代码一模一样,但2者有不同之处 jsx元素不局限html元素 可以任何一个react组件 React判断一个元素是html还是react组件看第一个字母是否大写 JSX语句是一个对象，是一个运用HTML标签结构却实现了javascript语法的对象，一句话，简直飞起 jsx用法：在JSX中可以加入表达式 1234567891011121314151617181920const use = &quot;abc&quot;;const user = &#123; firstName: &#x27;tm7&#x27;, lastName: &#x27;jxy&#x27;&#125;;function formatName(user) &#123; return user.firstName + &#x27; &#x27; + user.lastName;&#125;const t1 = 1, t2 = 2;const a = &lt;div&gt;&#123;&#x27;abc&#x27;&#125;&lt;/div&gt;;const a = &lt;div&gt;&#123;use&#125;&lt;/div&gt;;const b = &lt;div&gt;&#123;user.firstName&#125;&lt;/div&gt;;const c = &lt;div&gt;&#123;formatName(user)&#125;&lt;/div&gt;;const d = &lt;div&gt;&#123;1+1+1&#125;&lt;/div&gt;;const e = &lt;div&gt;&#123;t1 &amp;&amp; t2&#125;&lt;/div&gt;;const f = &lt;div&gt;&#123;t1 &gt; t2&#125;&lt;/div&gt;;const g = &lt;div&gt;&#123;t1 &lt; t2 ? &#x27;abc&#x27;:&#x27;ccc&#x27;&#125;&lt;/div&gt;;const h = &lt;div&gt;&#123;function()&#123;return &#x27;abc&#x27;;&#125;()&#125;&lt;/div&gt;;const i = &lt;div&gt;&#123;&lt;div&gt;iii&lt;/div&gt;&#125;&lt;/div&gt;; 可以加入自定义属性例如 12const el = &lt;div data-fff=&quot;abc&quot;&gt;&lt;/div&gt;; //必须加data- 12const el = &lt;div className=&quot;abc&quot;&gt;&lt;/div&gt;;const el = &lt;div className=&#123;&#x27;abc&#x27;&#125;&gt;&lt;/div&gt;; 最后看一下JSX 是一种语法糖，经过 babel 转换结果如下，可以发现实际上转化成 React.createElement() 的形式：每一个参数分别对应[标签名，属性，孩子节点]123456789101112131415161718192021const el = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, &lt;span className=&quot;text&quot;&gt; world!&lt;/span&gt; &lt;/h1&gt;);//==========babel编译后==============&quot;use strict&quot;;var el = React.createElement( &quot;h1&quot;, &#123; className: &quot;greeting&quot; &#125;, &quot;Hello,&quot;, React.createElement( &quot;span&quot;, &#123; className: &quot;text&quot; &#125;, &quot; world!&quot; ));因此，我们得出结论：JSX 语法糖经过 Babel 编译后转换成一种对象，该对象即所谓的虚拟 DOM，使用虚拟 DOM 能让页面进行更为高效的渲染。 虚拟 DOM 转化为真实 DOM将虚拟 DOM 转化为真实 DOM 是使用 ReactDOM.render 实现的 1234ReactDOM.render( element, // 上文的 element，即虚拟 dom document.getElementById(&#x27;root&#x27;)) 总结JSX 经过 babel 编译为 React.createElement() 的形式，其返回结果就是 Virtual DOM，最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下： …..暂时想到这几点不全面,还会不断补充","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"简单实现下Promise的原理","slug":"简单实现下Promise的原理","date":"2018-11-13T04:39:04.000Z","updated":"2020-09-16T09:07:05.000Z","comments":true,"path":"2018/11/13/简单实现下Promise的原理/","link":"","permalink":"http://mariogogogo.github.io/2018/11/13/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%8BPromise%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。","text":"所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 promise的简单使用12345678var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;执行完成&#x27;); resolve(&#x27;随便什么数据&#x27;); &#125;, 2000);&#125;); 一步一步实现效果12345678910111213141516171819202122232425262728293031323334353637;(function() &#123; let status = &#123; pending:0, fulfilled:1, rejected:2 &#125; class CustomePromise&#123; //接受一个函数进来 constructor(func)&#123; this._status = status.pending; this._handler(func); &#125; //接受外部传入的函数 调用外部的函数 _handler(func)&#123; func((value)=&gt;&#123; console.log(value); &#125;,(error)=&gt;&#123; console.log(error); &#125;) &#125; //执行成功 _resolve()&#123; &#125; //执行失败 _reject()&#123; &#125; &#125; //挂载到windows window.CustomePromise = CustomePromise;&#125;)(); 对执行次数的限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445(function() &#123; let status = &#123; pending: 0, fulfilled: 1, rejected: 2, &#125;; class CustomePromise &#123; //接受一个函数进来 constructor(func) &#123; this._status = status.pending; this._handler(func); &#125; //接受外部传入的函数 调用外部的函数 _handler(func) &#123; let done = false; func( value =&gt; &#123; if (done) true; // 只执行一次 done = true; console.log(value); this._resolve(value); &#125;, () =&gt; &#123; if (done) true; done = true; this._reject(value); &#125; ); &#125; //成功 _resolve(value) &#123; this._status = status.fulfilled; &#125; //失败 _reject() &#123; this._status = status.rejected; &#125; &#125; //挂载到windows window.CustomePromise = CustomePromise;&#125;)(); 收集失败或成功的执行函数并执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283(function() &#123; ....... class CustomePromise &#123; //接受一个函数进来 constructor(func) &#123; //初始状态 this._status = status.pending; this._handler(func); // 收集成功状态或失败状态要执行的函数 this.resolvedArr = []; this.rejectArr = []; this._value = null; //记录参数 this._error = null; &#125; //接受外部传入的函数 调用外部的函数 _handler(func) &#123; let done = false; func( value =&gt; &#123; if (done) true; done = true; console.log(value); this._resolve(value); &#125;, error =&gt; &#123; if (done) true; done = true; this._reject(error); &#125; ); &#125; //成功 _resolve(value) &#123; // 只执行一次 this._status = status.fulfilled; this._value = value; //收集完执行任务后 执行 this.resolvedArr.forEach(item =&gt; item(this._value)) &#125; //失败 _reject(error) &#123; this._status = status.rejected; this._error = error; //收集完执行任务后 执行 this.rejectArr.forEach(item =&gt; item(this._error)) &#125; // 收集的时机:pending状态收集 _done(resolvedFunc, rejectedFunc) &#123; resolvedFunc = typeof resolvedFunc === &#x27;function&#x27; ? resolvedFunc : null; rejectedFunc = typeof rejectedFunc === &#x27;function&#x27; ? rejectedFunc : null; if (this._status === 0) &#123; if (rejectedFunc) &#123; this.resolvedArr.push(resolvedFunc); &#125; if (rejectedFunc) &#123; this.rejectArr.push(rejectedFunc); &#125; &#125; else if (his._status === 1 &amp;&amp; rejectedFunc) &#123; resolvedFunc(this._value); &#125; else if (his._status === 2 &amp;&amp; rejectedFunc) &#123; rejectedFunc(this._error); &#125; &#125; //收集注册成功状态或者失败状态 then(resolvedFunc, rejectedFunc) &#123; this._done(resolvedFunc, rejectedFunc); &#125; &#125; .......&#125;)(); 模拟实现异步效果1234567891011121314151617181920212223242526......//成功 _resolve(value) &#123; //模拟异步操作 setTimeout(() =&gt; &#123; // 只执行一次 this._status = status.fulfilled; this._value = value; //收集完执行任务后 执行 this.resolvedArr.forEach(item =&gt; item(this._value)); &#125;, 2000); &#125; //失败 _reject(error) &#123; setTimeout(() =&gt; &#123; this._status = status.rejected; this._error = error; //收集完执行任务后 执行 this.rejectArr.forEach(item =&gt; item(this._error)); &#125;, 2000); &#125;...... 期待下次更新继续…………..","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"定时器","slug":"定时器","date":"2018-11-11T16:00:00.000Z","updated":"2020-09-16T09:07:01.000Z","comments":true,"path":"2018/11/12/定时器/","link":"","permalink":"http://mariogogogo.github.io/2018/11/12/%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"怎么实现一个js版本sleep函数?","text":"怎么实现一个js版本sleep函数? 在其他语言中都可能有sleep函数 从最简单的开始讲:123456function sleep(time,callback)&#123; setTimeout(callback,time);&#125;sleep(2000,()=&gt;&#123;console.log(&#x27;sleep recover&#x27;)&#125;) 改进但是这样写很不优雅,都什么年代了,还不快用Promise 1234567function sleep(time)&#123; return new Promise(resolve =&gt; setTimeout(resolve,time)) &#125;sleep(2000).then(()=&gt; console.log(&#x27;sleep recover&#x27;)); 优化ES7提供了更加方便的async/await方法 123456789101112131415161718function sleep(time)&#123; return new Promise(resolve =&gt; setTimeout(resolve,time)) &#125;async init()&#123; await sleep(2000); //只有sleep执行完成才能继续下面的语句 console.log(&#x27;sleep recover&#x27;) &#125;init();//执行init().then(()=&gt; console.log(&#x27;init finish&#x27;)) 定时器还有一个重要的话题:setTimeout与setInterval的区别 setTimeout 当前执行单元都执行完成后才开始执行, setInterval 在设定完计时器后立马计时 123456789101112131415161718192021222324252627282930313233 let scriptBegin = Date.now(); fun1(); fun2(); function act(params) &#123; console.log(params,Date.now() - scriptBegin); let begin = Date.now(); while (Date.now()-begin&lt;20); &#125; function fun1() &#123; let fun3 = ()=&gt; act(&#x27;fun3&#x27;); setTimeout(fun3, 0); //再回到异步完成后开始执行 act(&#x27;fun1&#x27;) //跳过上面的异步 先执行这句 &#125; function fun2() &#123; act(&#x27;fun2-1&#x27;); //再执行这句 let fun4 = ()=&gt; act(&#x27;fun4&#x27;); setInterval(fun4, 20); //最后回开始执行 act(&#x27;fun2-2&#x27;) //跳过上面的异步 先执行这句 &#125; //结果 fun1 0 fun2-1 22 fun2-2 42 fun3 64 fun4 84fun4 104fun4 124fun4 144fun4 164","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"函数节流 throttling","slug":"函数节流 throttling","date":"2018-11-10T16:00:00.000Z","updated":"2020-09-16T09:07:04.000Z","comments":true,"path":"2018/11/11/函数节流 throttling/","link":"","permalink":"http://mariogogogo.github.io/2018/11/11/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%20throttling/","excerpt":"节流是什么? 浏览器的DOM操作比起非DOM交互需要更多的内存和cpu时间，连续过多的DOM操作可能会导致浏览器挂起甚至崩溃。比如使用onresize，onscroll这些可能会被连续触发的事件的时候，如果事件处理程序中进行了过多地DOM操作，可能就会使得浏览器崩溃。而为了绕开这个问题，可能就需要使用到函数节流。","text":"节流是什么? 浏览器的DOM操作比起非DOM交互需要更多的内存和cpu时间，连续过多的DOM操作可能会导致浏览器挂起甚至崩溃。比如使用onresize，onscroll这些可能会被连续触发的事件的时候，如果事件处理程序中进行了过多地DOM操作，可能就会使得浏览器崩溃。而为了绕开这个问题，可能就需要使用到函数节流。 防止一个事件触发执行的太快,比如: 监听input触发搜索 监听resize做响应调整 监听mousemove调整位置 怎么样实现一个节流?1234567891011function fun()&#123; console.log(&#x27;onresize&#x27;)&#125;function throttle(method,context)&#123; clearTimeout(method.timer); method.timer=setTimeout(function()&#123; method.call(context); &#125;,500);&#125;window.onresize = ()=&gt;throttle(fun,window) 但上述代码有一个问题,就是这个函数可能永远不会执行,因为他一直在触发,一直在清除id.在窗口拖拽过程中不会执行,只有最后一次停下之后才执行这种实现应该叫防抖; 我们继续改进下代码12345678910111213141516function fun()&#123; console.log(&#x27;onresize&#x27;)&#125;function throttle(method,context)&#123; if(method.timer)&#123; return; &#125; clearTimeout(method.timer); method.timer = setTimeout(function()&#123; method.call(context) method.id=0; &#125;,100)&#125;window.onresize = ()=&gt;throttle(fun,window) 我们把setTimeout里的id设置成了0;那么下次执行的时候就会触发也有一个小问题:就是每次执行要延迟100ms 有时候用户可能就是最大化窗口,只触发了一次,但还是延迟100ms才能执行,假设你设置500ms那么延迟就是半秒; 还可以继续优化先判断是否为第一次触发,如果是的话立即执行 123456789101112131415function throttle(method,context)&#123; if(typeof method.timer === &quot;undefined&quot;)&#123; method.call(context) &#125; if(method.timer)&#123; return; &#125; clearTimeout(method.timer); method.timer = setTimeout(function()&#123; method.call(context) method.id=0; &#125;,100)&#125; 但还是有问题 如果用户最大化之后,隔了一会又取消最大化了就又有延迟了,并且第一次触发执行2次 1234567891011function fun()&#123; console.log(&#x27;onresize&#x27;)&#125;function throttle(method,context)&#123; if(!method.timer)&#123; method.call(context) method.timer = 1 setTimeout(()=&gt; method.timer=0,500) &#125;&#125;window.onresize = ()=&gt;throttle(fun,window) 节流会失去灵敏度,如果做一个拖拽一样的应用,会变成一卡一卡,是不可取的. 防抖和节流的区别 防抖是执行重复操作的最后一次;而节流是每多少单位时间内执行一次;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"理解 javascript 中的柯里化","slug":"理解javascript中的柯里化","date":"2018-11-09T16:00:00.000Z","updated":"2020-09-16T09:07:07.000Z","comments":true,"path":"2018/11/10/理解javascript中的柯里化/","link":"","permalink":"http://mariogogogo.github.io/2018/11/10/%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"什么是柯里化? 就是函数与参数值的结合产生一个新的函数","text":"什么是柯里化? 就是函数与参数值的结合产生一个新的函数 简单的例子1234567function add(a, b) &#123; return a + b;&#125;let add1 = add.curry(1);console.log(add1(5)); //6console.log(add1(2)); //3 如何实现(不完整实现)1234567Function.prototype.curry = function() &#123; let defautlArgs = arguments; let that = this; return function() &#123; return that.apply(this, defaultArgs.concat(arguments)); &#125;;&#125;; 由于参数不一定是一个数组,没有 concat 函数,所以要把伪数组转成一个数组 1const arr = Array.prototype.slice; 12345678Function.prototype.curry = function() &#123; const arr = Array.prototype.slice; let defautlArgs = arr.call(arguments); let that = this; return function() &#123; return that.apply(this, defaultArgs.concat(slice.call(arguments))); &#125;;&#125;; 柯里化有用吗?① 案例 12345678910111213141516171819202122232425var currying = function(fn) &#123; // fn 指官员消化老婆的手段 var args = [].slice.call(arguments, 1); // args 指的是那个合法老婆 return function() &#123; // 已经有的老婆和新搞定的老婆们合成一体，方便控制 var newArgs = args.concat([].slice.call(arguments)); // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回 return fn.apply(null, newArgs); &#125;;&#125;;// 下为官员如何搞定7个老婆的测试// 获得合法老婆var getWife = currying(function() &#123; var allWife = [].slice.call(arguments); // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆 console.log(allWife.join(&quot;;&quot;));&#125;, &quot;合法老婆&quot;);// 获得其他6个老婆getWife(&quot;大老婆&quot;, &quot;小老婆&quot;, &quot;俏老婆&quot;, &quot;刁蛮老婆&quot;, &quot;乖老婆&quot;, &quot;送上门老婆&quot;);// 换一批老婆getWife(&quot;超越韦小宝的老婆&quot;); ② 案例举个例子，你有一个商店 🏠，你想给你的顾客 10% 的折扣： 123function discount(price, discount) &#123; return price * discount;&#125; 当一个有价值的客户买了一件\\$500 的商品，你会给他： 1234567891011121314const price = discount(500, 0.1); // $50// $500 - $50 = $450//你会发现从长远来看，我们每天都自己计算10%的折扣。const price = discount(1500, 0.1); // $150// $1,500 - $150 = $1,350const price = discount(2000, 0.1); // $200// $2,000 - $200 = $1,800const price = discount(50, 0.1); // $5// $50 - $5 = $45const price = discount(5000, 0.1); // $500// $5,000 - $500 = $4,500const price = discount(300, 0.1); // $30// $300 - $30 = $270 我们可以柯里化这个折扣函数，这样就不需要每天都添加 0.10 这个折扣值： 123456789function discount(discount) &#123; return price =&gt; &#123; return price * discount; &#125;;&#125;const tenPercentDiscount = discount(0.1);//现在，我们可以只用你有价值的客户购买的商品价格来进行计算了：tenPercentDiscount(500); // $50// $500 - $50 = $450 再一次，发生了这样的情况，有一些有价值的客户比另一些有价值的客户更重要 – 我们叫他们超级价值客户。并且我们想给超级价值客户 20%的折扣。 返回的函数twentyPercentDiscount将被用于计算超级价值客户的折扣： 123456twentyPercentDiscount(500); // 100// $500 - $100 = $400twentyPercentDiscount(5000); // 1000// $5,000 - $1,000 = $4,000twentyPercentDiscount(1000000); // 200000// $1,000,000 - $200,000 = $600,000 避免频繁调用具有相同参数的函数 举个例子，我们有一个函数来计算圆柱体的体积： 123456function volume(l, w, h) &#123; return l * w * h;&#125;volume(200, 30, 100); // 2003000lvolume(32, 45, 100); //144000lvolume(2322, 232, 100); // 53870400l 为了解决这个问题，需要柯里化这个计算体积的函数（像我们之前做的一样）： 1234567function volume(h) &#123; return w =&gt; &#123; return l =&gt; &#123; return l * w * h; &#125;; &#125;;&#125; 我们可以定义一个特定的函数，这个函数用于计算特定的圆柱体高度： 123const hCylinderHeight = volume(100);hCylinderHeight(200)(30); // 600,000lhCylinderHeight(2322)(232); // 53,870,400l ③ 案例 12let data = [1, 5, 2, 10, 8, 0];data.sort((a, b) =&gt; b - a); //[10,8,5,2,1,0]; 如果操作的数量比较多,每一次都需要写一个函数参数.因此可以使用柯里化把参数固定起来; 1234Array.prototype.sortDescending = Array.prototype.sort.curry((a, b) =&gt; b - a);let data = [1, 5, 2, 10, 8, 0];data.sortDescending(); //[10,8,5,2,1,0]; 最后引用大佬的话其实这些模式在实际使用的时候，或多或少都使用过，当看到“模式”概念的时候，我们就会猛然惊起：“哦，原来这个就叫做‘观察者模式’等”。现在要讨论的问题是，我们有没有必要把这些“模式”都记住呢，都理解其对应的核心呢？这个问题类似于，我可以看懂 NBA 的篮球比赛，那我有没有必要把各个球队以及球队的队员都记住呢？ 如果想成为 JS 大神，从这个目标来看，这是需要的；好比优秀的篮球解说员必须要知道每个球队的名字、球员甚至周边八卦。但是，现实很重要。如果连 JS 函数相关的基本东西都驾驭不好，显然，硬是啃这些似懂非懂的概念只会造成混乱。如果你觉得可以更近一步，先通透几个自己习惯的熟悉的使用模式，足够应付实际项目；其他一些概念什么的，更多的只是噱头，实用性其实并不大。正如本文的柯里化，看上去很高级，似乎也有点用处，然而 JS 的灵活性使得很多实现完全摆脱“柯里化”这个概念的束缚，以更通俗易懂的方式实现。 然而，即使实用性不高，我们还是要有所了解，因为，你不知道什么时候会用到它。比方说 CSS 中的display:table;某些情况下可以解决一些棘手问题(secret!). 参考JS 中的柯里化(currying) 「译」理解 JavaScript 的柯里化","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"Ubuntu14.04安装MySQL5.5图解安装流程！","slug":"Ubuntu14.04安装MySQL5.5图解安装流程！","date":"2018-11-07T16:00:00.000Z","updated":"2020-09-16T09:07:54.000Z","comments":true,"path":"2018/11/08/Ubuntu14.04安装MySQL5.5图解安装流程！/","link":"","permalink":"http://mariogogogo.github.io/2018/11/08/Ubuntu14.04%E5%AE%89%E8%A3%85MySQL5.5%E5%9B%BE%E8%A7%A3%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B%EF%BC%81/","excerpt":"删除mysql的数据文件1sudo rm /var/lib/mysql/ -R 删除mysql的配置文件1sudo rm /etc/mysql/ -R 自动卸载mysql（包括server和client）12sudo apt-get autoremove mysql* --purge sudo apt-get remove apparmor 检查是否卸载干净1dpkg -l | grep mysql # 若没有返回，说明已完成卸载 接下来安装就是件简单的事情默认安装5.5版本1sudo apt-get install mysql-server mysql-client查看mysql版本：1sudo mysqladmin -u root -p version 记录下安装步骤","text":"删除mysql的数据文件1sudo rm /var/lib/mysql/ -R 删除mysql的配置文件1sudo rm /etc/mysql/ -R 自动卸载mysql（包括server和client）12sudo apt-get autoremove mysql* --purge sudo apt-get remove apparmor 检查是否卸载干净1dpkg -l | grep mysql # 若没有返回，说明已完成卸载 接下来安装就是件简单的事情默认安装5.5版本1sudo apt-get install mysql-server mysql-client查看mysql版本：1sudo mysqladmin -u root -p version 记录下安装步骤 安装msyql12345678910111213apt-get update//说明没有你不是root用户，则需要用sudo命令sudo apt-get updateapt-get install MySQL-client-core-5.6apt-get install mysql-client-5.6apt-get install mysql-server-5.6 检查mysql是否启动12检查mysql是否启动ps -ef | grep mysql 查看msyql 监听端口12检查mysql是否启动netstat -tap | grep mysql Mysql 服务远程访问修改配置文件：sudo gedit /etc/mysql/conf.cnf 重启msyql1service mysql restart 分配所有访问权限,如果已分配过，该步骤可跳过123mysql -u root -p//输入密码mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root密码&#x27; WITH GRANT OPTION;强制刷新权限1mysql&gt; flush privileges;再次查看用户表,root用户的host变成%，即允许所有的ip远程访问，如果需要指定具体的ip，就写上具体的ip即可 123# netstat -an|grep 3306tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 配置阿里云安全组规则登录阿里云进入控制台，依次访问网络和安全-&gt;安全组-&gt;配置规则，在入方向上开放MySQL监听端口3306即可，如下所示 阿里云服务器的MYSQL数据库远程访问开启成功，使用客户端测试连接成功。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://mariogogogo.github.io/tags/mysql/"}]},{"title":"React+阿里云部署静态网页","slug":"React+阿里云部署静态网页","date":"2018-10-30T16:00:00.000Z","updated":"2020-09-16T09:07:45.000Z","comments":true,"path":"2018/10/31/React+阿里云部署静态网页/","link":"","permalink":"http://mariogogogo.github.io/2018/10/31/React+%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/","excerpt":"部署在服务器上的静态页面其实很简单只是做个简单的记录,安全及性能相关问题暂不考虑太多;","text":"部署在服务器上的静态页面其实很简单只是做个简单的记录,安全及性能相关问题暂不考虑太多; 一、远程登录服务器1.1 ssh 远程登录服务器123456789101112# ssh 登录ssh root@47.xx.xx.xx# 接着，输入密码（购买服务器时的密码）******# 然后，可以做你想做的事情，简单点：# 查看硬盘fdisk -l# 查看硬盘使用情况df -h 1.2 配置 root 及应用账号权限123456789101112# 增加用户adduser chan # chan 为用户名，然后输入密码，创建完成# 用户授权gpasswd -a chan sudo # 添加用户到 sudo 组中sudo visudo # 接着，为用户授权chan ALL=(ALL:ALL) ALL# 重新开启一个终端，就可以以 tanya 的身份登录啦ssh chan@47.xx.xx.xx # 然后输入密码，即可登录成功 1.3 修改服务器默认登录端口1234567891011121314# 编辑文件sudo vi /etc/ssh/sshd_config# 修改 Port 项，端口范围 0 ~ 65536Port xx# 在末尾添加AllowUsers tanya# 重启服务sudo service ssh restart# 重新开启一个终端：ssh -p 端口 tanya@47.xx.xx.xxssh -p xx tanya@47.xx.xx.xx 三、搭建 Nodejs 生产环境3.1 搭建服务器的 Nodejs 环境 1234567891011121314151617181920212223242526# 更新服务器sudo apt-get update# 安装工具sudo apt-get install vim openssl build-essential libssl-dev wget curl git# 安装 nvm (node 版本管理工具) https://github.com/creationix/nvmwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.7/install.sh | bash# 安装 Node.js (最新稳定版) https://nodejs.org/en/nvm install v9.6.3# 指定 Node.js 版本nvm use v9.6.3# 安装 npmnpm --registry=https://registry.npm.taobao.org install -g npm# 如果有多个 Node.js 版本，通过这种方式指定默认版本nvm alias default v9.6.3# 增加系统文件监控数目echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p# 安装一些常用模块npm install yarn pm2 webpack -g 3.2 借助 pm2 让 Node.js 服务常驻 1234567891011# 启动服务pm2 start app.js# 查看所有服务pm2 list# 查看应用pm2 show app# 查看日志pm2 logs 四、配置 Nginx 实现反向代理配置 Nginx 反向代理 Nodejs 端口安装 nginx 1sudo apt-get install nginx nginx 配置规则：可以通过 http://47.xx.xx.xx 访问服务器 http://127.0.0.1:8081 端口的服务 配置 Nginx，Linux 服务器是进入到： 1cd / etc / nginx / sites - enabled; 然后以管理员身份，新建一个你的 react 项目的配置文件，比如：react-demo.conf，然后，编辑文件 123456789101112131415161718upstream gusaifei &#123; server 127.0.0.1:8081;&#125;server &#123; listen 80; server_name 47.xx.xx.xx; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://gusaifei; proxy_redirect off; &#125;&#125; 或者 路径地址 cd /etc/nginx/conf.d 1234567891011server&#123; listen 80; server_name mall.52react.cn; root /root/www/firstweb/dist2; index index.html; #location / &#123; # proxy_pass http://admintest.happymmall.com; # &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; #配置监听端口 server_name first.52react.cn; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /root/www/firstweb/dist; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 部署一个静态资料文件123456789101112131415161718192021222324252627282930313233server&#123; listen 80; server_name mall.52react.cn; root &#x2F;root&#x2F;product&#x2F;mall_shop&#x2F;dist&#x2F;view&#x2F;; #多入口文件路径View 单入口文件路径 dist&#x2F; index index.html; #如果css和js无法加载出来可能需要配置以下信息 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|css|js|eot|svg|ttf|woff|woff2|properties|json)$ &#123; root &#x2F;root&#x2F;product&#x2F;mall_shop; #路径到项目根目录 if (-f $request_filename) &#123; expires 1d; break; &#125; &#125; #默认加载首页 location &#x3D; &#x2F; &#123; root &#x2F;root&#x2F;product&#x2F;mall_shop&#x2F;dist&#x2F;view&#x2F;; index index.html; &#125; location ~ .*\\.html$ &#123; root &#x2F;root&#x2F;product&#x2F;mall_shop&#x2F;dist&#x2F;view&#x2F;; index index.html; &#125; #请求反向代理用别的借口 location ~ .*\\.do$ &#123; proxy_pass http:&#x2F;&#x2F;test.happymmall.com; &#125; #错误页面跳转回首页 location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.html; &#125;&#125; 注意 webpakc 输出路径配置123456output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;js/[name].js&#x27;, //必须[name] 不然冲突文件名一样&#125;, 重启之前，可以先检测一下配置规则12345sudo nginx -t//重启sudo nginx -s reload Nginx 安装过程比较简单，再次不在赘述。文章从出来 Nginx 的默认页面之后，部署自己的网站开始。最新版本 nginx 配置是由 4 个文件构成，在 Ubuntu 中，这几个文件的路径在：/etc/nginx 下： conf.d：用户自己定义的 conf 配置文件 sites-available：系统默认设置的配置文件 sites-available：系统默认设置的配置文件 sites-enabled：由 sites-available 中的配置文件转换生成 sites-enabled：由 sites-available 中的配置文件转换生成 nginx.conf：汇总以上三个配置文件的内容，同时配置我们所需要的参数 nginx.conf：汇总以上三个配置文件的内容，同时配置我们所需要的参数在部署需要的 web 服务时，我们可以拷贝 sites-enabled 中的 default 文件到 conf.d 并且修改名字为 **.conf ,然后进行配置： 如果 nginx 还是无法访问还需要该一个地方(之前坑了我一天)","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"了解下css3自适应布局单位vw,vh","slug":"了解下css3自适应布局单位vw,vh","date":"2018-10-29T16:00:00.000Z","updated":"2020-09-16T09:07:06.000Z","comments":true,"path":"2018/10/30/了解下css3自适应布局单位vw,vh/","link":"","permalink":"http://mariogogogo.github.io/2018/10/30/%E4%BA%86%E8%A7%A3%E4%B8%8Bcss3%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E5%8D%95%E4%BD%8Dvw,vh/","excerpt":"视口单位(Viewport units) 什么是视口？ 在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。","text":"视口单位(Viewport units) 什么是视口？ 在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport。 根据CSS3规范，视口单位主要包括以下4个： 1.vw：1vw等于视口宽度的1%。 2.vh：1vh等于视口高度的1%。 3.vmin：选取vw和vh中最小的那个。 4.vmax：选取vw和vh中最大的那个。 vh and vw：相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。 比如：浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px。 vmax相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。 vmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。 vh/vw与%区别 兼容性问题(在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持)","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://mariogogogo.github.io/tags/css/"}]},{"title":"🚀建造小飞机场🚁🚁🚁","slug":"🚀建造小飞机场🚁🚁🚁","date":"2018-10-29T16:00:00.000Z","updated":"2020-09-16T09:06:52.000Z","comments":true,"path":"2018/10/30/🚀建造小飞机场🚁🚁🚁/","link":"","permalink":"http://mariogogogo.github.io/2018/10/30/%F0%9F%9A%80%E5%BB%BA%E9%80%A0%E5%B0%8F%E9%A3%9E%E6%9C%BA%E5%9C%BA%F0%9F%9A%81%F0%9F%9A%81%F0%9F%9A%81/","excerpt":"每天看看墙外,神清气爽,不会被某些组织蒙蔽双眼","text":"每天看看墙外,神清气爽,不会被某些组织蒙蔽双眼 Debian/Ubuntu/CentOS6 系统 ShadowsocksR 一键安装脚本 (集成锐速) 使用此教程，可以完全不过脑子的搭建好 SSR，且速度进行了优化 注意 1： KVM/VMWARE/XEN 才有用，锐速不支持 openVZ ！ 注意 2：脚本会不断更新（目前时间 2016.11.27），请关注逗比根据地原文 12wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 使用说明运行脚本 1bash ssr.sh 输入对应的数字来执行相应的命令。 12345678910111213141516171.安装ShadowsocksR服务端2.安装libsodium(chacha20加密方式)3.查看账号信息4.修改账号信息5.手动修改账号信息6.卸载ShadowsocksR服务端7.更新ShadowsocksR服务端————————————8.启动ShadowsocksR9.停止ShadowsocksR10.重启ShadowsocksR————————————11.安装锐速（ServerSpeeder）12.查看锐速状态13.停止锐速14.重启锐速15.卸载锐速 安装步骤 输入 1 ，就会开始安装 ShadowsocksR 服务端，并且会提示你输入 Shadowsocks 的 端口/密码/加密方式/协议/混淆 等参数。 123456789101112131415Please input port for shadowsocksR [1-65535]:(Default port: 2333):Please input password for ShadowsocksR:(Default password: dou-bi.co):Please input method for ShadowsocksR:(Default method: aes-256-cfb):Please input protocol for ShadowsocksR:(Default protocol: auth_sha1_v4):Please input obfs for ShadowsocksR:(Default obfs: tls1.2_ticket_auth): 同时最后也会提示是否设置 协议和混淆 兼容原版（也就是使用原版 SS 也能链接），不懂 直接回车 或 输入 y 。 如果安装过程没有出错，那么最后就会提示：12345678910111213141516171819202122############################################################ Your ShadowsocksR info : Server IP: VPS_IP Server Port: 2333 Password: dou-bi.co Method: aes-256-cfb Protocol: auth_sha1_v4_compatible Obfs: tls1.2_ticket_auth_compatible SS url: ss://XXXXXXXXXXXXXXXXXXXXX QR code: http://pan.baidu.com/share/qrcode?w=300&amp;h=300&amp;url=ss://XXXXXXXXXXXXXXXXXXXXX Tip: Open the link above will be able to see two-dimensional code picture.Tip: The protocol and obfs last [ _compatible ] refer to the compatible original.############################################################ShadowsocksR install completed!https://www.dou-bi.co############################################################ SS url 是 SS 链接（格式： ss://XXXXXXX ，很长），可以从剪辑版导入 Shadowsocks 客户端，不懂的话看下面二维码。 QR code 是二维码，复制后面的链接在浏览器打开，就会显示一个二维码的图片，可以用 Shadowsocks 客户端扫描二维码来添加。 之后回到菜单界面 按14一键安装速锐 其他说明默认已经添加开机启动。 ShadowsocksR 默认支持 UDP 转发。 本脚本已经集成了 安装 / 卸载 锐速 (ServerSpeeder) 开心版，但是是否支持请查看 Linux 支持内核列表 。（锐速不支持 OpenVZ） 多端口配置的话，脚本实现很麻烦，所以不会加入这个功能，需要的人还是手动更改为多端口吧：ShadowsocksR 多端口配置 ShadowsocksR 目前支持的协议和混淆： 协议（Protocol）：origin，verify_sha1，auth_sha1_v2，auth_sha1_v4，auth_aes128_md5，auth_aes128_sha1混淆（Obfs）：plain，http_simple，http_post，random_head，tls1.2_ticket_authorigin 和 plain 是原版，加粗的是推荐使用的，均支持 兼容原版（也就是加后缀 _compatible）。 如何修改CentOS6内核支持安装锐速的内核 在锐速ServerSpeeder无限带宽版Linux一键自动安装包文章中介绍了如何使用一键包安装锐速，优化服务器网络速度。其实要想在自己的VPS安装锐速，首先内核必须要匹配锐速版本。如果内核不支持安装锐速，我们需要手动修改内核为支持安装锐速版本，不过OpenVZ虚拟技术架设的VPS是无法是无法更换内核，另外并不是所有的XEN和KVM虚拟技术架设的VPS都支持更换内核，像Linode VPS就不支持以下方法修改，需在VPS管理页面修改（Linode VPS如何在管理页面更换内核）。 CentOS 6支持安装锐速的内核：2.6.32-504.3.3.el6.x86_64 1、首先运行下面命令为自己的VPS下载安装内核。1234uname -r #查看当前内核版本rpm -ivh http://xz.wn789.com/CentOSkernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpmrpm -ivh http://xz.wn789.com/CentOSkernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 2、执行命令“rpm -qa | grep kernel”，查看内核是否安装成功。如果显示你安装的内核版本，表示安装成功。12rpm -qa | grep kernel 3、重启VPS，查看内核是否修改成功。123reboot #重启VPSuname -r #当前使用内核版本 最后","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"小飞机","slug":"小飞机","permalink":"http://mariogogogo.github.io/tags/%E5%B0%8F%E9%A3%9E%E6%9C%BA/"}]},{"title":"webpack4.0 升级","slug":"webpack4.0 升级","date":"2018-10-25T16:00:00.000Z","updated":"2020-09-16T09:07:58.000Z","comments":true,"path":"2018/10/26/webpack4.0 升级/","link":"","permalink":"http://mariogogogo.github.io/2018/10/26/webpack4.0%20%E5%8D%87%E7%BA%A7/","excerpt":"webpack3.0—–&gt;4.0的升级","text":"webpack3.0—–&gt;4.0的升级packjson.js webpack.js","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"React如何渲染大数据量的列表","slug":"React如何渲染大数据量的列表","date":"2018-10-24T16:00:00.000Z","updated":"2020-09-16T09:07:45.000Z","comments":true,"path":"2018/10/25/React如何渲染大数据量的列表/","link":"","permalink":"http://mariogogogo.github.io/2018/10/25/React%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%88%97%E8%A1%A8/","excerpt":"我们经常会遇到这种需求，根据数据展示列表。这种代码估计你已经撸过成百上千次了。 但如果你需要同时展示成千上万条数据呢，必然会造成浏览器卡顿，丢帧，甚至卡死的问题。现在介绍利用react-virtualized来高效渲染大数据量列表。","text":"我们经常会遇到这种需求，根据数据展示列表。这种代码估计你已经撸过成百上千次了。 但如果你需要同时展示成千上万条数据呢，必然会造成浏览器卡顿，丢帧，甚至卡死的问题。现在介绍利用react-virtualized来高效渲染大数据量列表。 首先创建一个React 应用12345678create-react-app virtualizationcd virtualizationnpm install --save lorem-ipsum //引入第三方库lorem-ipsum来生成模拟数据：import loremIpsum from &#x27;lorem-ipsum&#x27;; 接下来创造一个1000条数据的数组：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const rowCount = 1000;class App extends Component &#123; constructor() &#123; super(); this.list = Array(rowCount).fill().map((val, idx) =&gt; &#123; return &#123; id: idx, name: &#x27;John Doe&#x27;, image: &#x27;http://via.placeholder.com/40&#x27;, text: loremIpsum(&#123; count: 1, units: &#x27;sentences&#x27;, sentenceLowerBound: 4, sentenceUpperBound: 8 &#125;) &#125; &#125;); &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; &lt;/header&gt; &lt;div className=&quot;list&quot;&gt; &#123;this.list.map(this.renderRow.bind(this))&#125; &lt;/div&gt; &lt;/div&gt; );&#125;renderRow(item) &#123; return ( &lt;div key=&#123;item.id&#125; className=&quot;row&quot;&gt; &lt;div className=&quot;image&quot;&gt; &lt;img src=&#123;item.image&#125; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div className=&quot;content&quot;&gt; &lt;div&gt;&#123;item.name&#125;&lt;/div&gt; &lt;div&gt;&#123;item.text&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );&#125;&#125; 在 src/App.css 中加点样式：1234567891011121314151617181920.list &#123; padding: 10px;&#125;.row &#123; border-bottom: 1px solid #ebeced; text-align: left; margin: 5px 0; display: flex; align-items: center;&#125;.image &#123; margin-right: 10px;&#125;.content &#123; padding: 10px;&#125; 下面我们用Chrome，只需几步，快速测试性能： 打开开发者工具 按Command+Shift+P (Mac) or Control+Shift+P (Windows, Linux) 来打开命令菜单 输入 render，下拉框中选择 Show Rendering。 点击 render 页签，FPS Meter 前打钩。 滚动列表 我们可以看到，当滚动条滚动的时候，帧率从60掉到了38左右。这还是只有1000条数据情况，如果再增大数据，浏览器会出现卡顿，甚至卡死。 接着我们来看看react-virtualized是如何提高性能的？ react-virtualized原理核心原理：只渲染你所见的。上面的应用渲染了1000条评论，但屏幕只为你展示了10来条数据，那另外990条的渲染就是浪费的。如果我们只渲染可见的评论，当鼠标滚动查看更多的时候，将新的节点替换旧的节点。这样就完美解决了性能瓶颈的问题。 修改app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, &#123; Component &#125; from &quot;react&quot;;import loremIpsum from &quot;lorem-ipsum&quot;;import &#123; List &#125; from &quot;react-virtualized&quot;;const rowCount = 1000; //总条数const listHeight = 1000;const rowHeight = 100;const rowWidth = 800;class App extends Component &#123; constructor() &#123; super(); this.list = Array(rowCount) .fill() .map((val, idx) =&gt; &#123; return &#123; id: idx, name: &quot;John Doe&quot;, image: &quot;http://via.placeholder.com/40&quot;, text: loremIpsum(&#123; count: 1, units: &quot;sentences&quot;, sentenceLowerBound: 4, sentenceUpperBound: 8 &#125;) &#125;; &#125;); &#125; render() &#123; return ( &lt;div className=&quot;list&quot;&gt; &lt;div className=&quot;list&quot;&gt; &lt;List width=&#123;rowWidth&#125; height=&#123;listHeight&#125; rowHeight=&#123;rowHeight&#125; rowRenderer=&#123;this.renderRow.bind(this)&#125; rowCount=&#123;this.list.length&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125; renderRow(&#123; index, key, style &#125;) &#123; return ( &lt;div key=&#123;key&#125; style=&#123;style&#125; className=&quot;row&quot;&gt; &lt;div className=&quot;image&quot;&gt; &lt;img src=&#123;this.list[index].image&#125; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div className=&quot;content&quot;&gt; &lt;div&gt;&#123;this.list[index].name&#125;&lt;/div&gt; &lt;div&gt;&#123;this.list[index].text&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 性能明显提升💪👍👍👍👍👍👍👍👍","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"}]},{"title":"一起来玩，Koa2!（四）","slug":"一起来玩，Koa2!（四）","date":"2018-10-23T16:00:00.000Z","updated":"2020-09-16T09:07:15.000Z","comments":true,"path":"2018/10/24/一起来玩，Koa2!（四）/","link":"","permalink":"http://mariogogogo.github.io/2018/10/24/%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%8E%A9%EF%BC%8CKoa2!%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"写个最简单的API吧","text":"写个最简单的API吧 先写个app.js 再写routes.js 最后再调用user.js 1node app.js","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"android状态栏与背景图片的融合","slug":"Android状态栏与背景图片的融合","date":"2018-10-19T16:00:00.000Z","updated":"2020-09-16T09:07:17.000Z","comments":true,"path":"2018/10/20/Android状态栏与背景图片的融合/","link":"","permalink":"http://mariogogogo.github.io/2018/10/20/Android%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E8%9E%8D%E5%90%88/","excerpt":"状态栏融合","text":"状态栏融合 优化前效果 12345678910/** * 实现背景与状态栏融合在一起 android大于5.0支持 */if (Build.VERSION.SDK_INT &gt;= 21) &#123; View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION ; decorView.setSystemUiVisibility(option); getWindow().setStatusBarColor(Color.TRANSPARENT);//设置状态栏透明&#125; 优化后效果 增加状态栏高度","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"RecyclerView✌️进阶","slug":"RecyclerView✌️进阶","date":"2018-10-11T16:00:00.000Z","updated":"2020-09-16T09:07:50.000Z","comments":true,"path":"2018/10/12/RecyclerView✌️进阶/","link":"","permalink":"http://mariogogogo.github.io/2018/10/12/RecyclerView%E2%9C%8C%EF%B8%8F%E8%BF%9B%E9%98%B6/","excerpt":"现在做项目90%要用到recyclerView","text":"现在做项目90%要用到recyclerView 1 引入recyclerView在moudle中的build.gradle文件里，找到dependencies，添加关于recyclerView的引用： 1compile &#x27;com.android.support:recyclerview-v7:24.2.0&#x27; 其实design包中含有Material Design相关的很多控件，其中也包括了recyclerView的代码，所以你也可以通过引用design包来使用recyclerView： 1compile &#x27;com.android.support:design:23.2.0&#x27; 2 在xml中写一个recyclerView在MainActivity中添加一个RecyclerView进行展示，代码如下： 123456... &lt;android.support.v7.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/recyclerView&quot;/&gt;... 3 在java中给recyclerView设置数据在MainActivity中的代码如下： 123456789101112131415161718192021222324@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); initView(); initData();&#125;private void initData() &#123; ArrayList&lt;String&gt; datas = new ArrayList&lt;&gt;(); for(char i =&#x27;A&#x27;;i&lt;=&#x27;Z&#x27;;i++)&#123; datas.add(i+&quot;&quot;); &#125; mRecyclerView.setAdapter(new MyAdapter(getApplicationContext(),datas));&#125;private void initView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); //必须要指定展示的效果，设置一个LayoutManager，不然还是会一片空白 LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext()); mRecyclerView.setLayoutManager(linearLayoutManager);&#125; 在MyAdapter中的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyAdapter extends RecyclerView.Adapter &#123; private ArrayList&lt;String&gt; datas; private Context mContext; public MyAdapter(Context applicationContext, ArrayList&lt;String&gt; datas) &#123; this.datas = datas; this.mContext = applicationContext; &#125; //RecyclerView的Adapter已经集成了ViewHolder //getView中的两段逻辑 1 创建view对象（将xml转为view） 2 找到view对象里面的一些控件，对其进行一些展示的设置 //onCreateViewHolder 中执行第一段逻辑，创建出view，设置到一个ViewHolder中，再将holder返回 @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //第三个参数为false，如果为true的话，生成的这个view其实就是第二个参数指向的parent，会造成报错的 View view = LayoutInflater.from(mContext).inflate(R.layout.item_recyclerview, parent,false); MyViewHolder holder = new MyViewHolder(view); return holder; &#125; //给holder里的控件设置数据 @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; ((MyViewHolder)holder) .mTextView.setText(datas.get(position)); &#125; //Count 控制控件有多少个item @Override public int getItemCount() &#123; return datas.size(); &#125;&#125;class MyViewHolder extends RecyclerView.ViewHolder&#123; public TextView mTextView; public MyViewHolder(View itemView) &#123; super(itemView); mTextView = (TextView) itemView.findViewById(R.id.tv_item); &#125;&#125; 4 给recyclerView设置不同的展示效果设置菜单来提供多个点击事件。首先给res/menu/menu_main.xml修改为以下代码： 12345678910111213141516171819202122232425&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;com.a520it.recyclerview.MainActivity&quot;&gt; &lt;item android:id=&quot;@+id/action_listview&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;listView&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/action_gridview&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;gridView&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/action_hor_gridview&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;横向的gridView&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/action_stagger&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;交错的瀑布流&quot; app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; 然后在MainActivity中，修改菜单代码： 123456789101112131415161718192021222324252627@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); if (id == R.id.action_listview) &#123; Toast.makeText(MainActivity.this, &quot;listview&quot;, Toast.LENGTH_SHORT).show(); return true; &#125;else if(id == R.id.action_gridview) &#123; GridLayoutManager gridLayoutManager = new GridLayoutManager(getApplicationContext(), 3); mRecyclerView.setLayoutManager(gridLayoutManager); Toast.makeText(MainActivity.this, &quot;gridview&quot;, Toast.LENGTH_SHORT).show(); return true; &#125;else if(id == R.id.action_hor_gridview) &#123; GridLayoutManager gridLayoutManager = new GridLayoutManager(getApplicationContext(), 3,GridLayoutManager.HORIZONTAL,true); mRecyclerView.setLayoutManager(gridLayoutManager); Toast.makeText(MainActivity.this, &quot;横向的gridview&quot;, Toast.LENGTH_SHORT).show(); return true; &#125;else if(id == R.id.action_stagger) &#123; StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.HORIZONTAL); mRecyclerView.setLayoutManager(staggeredGridLayoutManager); Toast.makeText(MainActivity.this, &quot;交错的瀑布流&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item);&#125; 其实就是设置了不同的LayoutManager给RecyclerView而已。 5 给RecyclerView添加点击效果RecyclerView没有提供OnItemClick相关的item点击方法，需要自己去实现。这里是通过在Adapter中去实现的。在Adapter中先自定义一个OnItemClickListener，然后在Adapter中的onBindViewHolder方法中，给holder.itemView设置OnClickListener，并在OnClickListener的点击方法中，调用自定义的OnItemClickListener。代码如下： 1234567891011121314151617181920212223 //给holder里的控件设置数据 @Override public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) &#123; ((MyViewHolder)holder) .mTextView.setText(datas.get(position)); //给item添加一个点击 holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// Toast.makeText(mContext, &quot;点击了item&quot;+position, Toast.LENGTH_SHORT).show(); mOnItemClickListener.onItemClick(position,holder.itemView); &#125; &#125;); &#125; public void setOnItemClickListener(OnItemClickListener onItemClickListener)&#123; this.mOnItemClickListener = onItemClickListener; &#125; private OnItemClickListener mOnItemClickListener = null; public interface OnItemClickListener&#123; void onItemClick(int position,View itemView); &#125; 然后在MainActivity中设置自定义的OnItemClickListener即可。代码如下： 123456789private void initData() &#123; .... myAdapter.setOnItemClickListener(new MyAdapter.OnItemClickListener() &#123; @Override public void onItemClick(int position, View itemView) &#123; Toast.makeText(MainActivity.this, &quot;position: &quot;+position, Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 6 给RecyclerView设置动画效果给菜单再添加两个按钮，点击时就插入、删除数据。修改menu_main.xml代码如下： 12345678910111213141516171819&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;com.a520it.recyclerview.MainActivity&quot;&gt; ... &lt;item android:id=&quot;@+id/action_add&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;add&quot; android:icon=&quot;@drawable/ic_menu_add&quot; app:showAsAction=&quot;always&quot;/&gt; &lt;item android:id=&quot;@+id/action_delete&quot; android:orderInCategory=&quot;100&quot; android:title=&quot;delete&quot; android:icon=&quot;@drawable/ic_menu_delete&quot; app:showAsAction=&quot;always&quot;/&gt;&lt;/menu&gt; 在MainActivity中设置onOptionsItemSelected方法代码如下： 1234567891011121314@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); ....else if(id == R.id.action_add) &#123; mMyAdapter.addItem(1,&quot;B&quot;); Toast.makeText(MainActivity.this, &quot;add&quot;, Toast.LENGTH_SHORT).show(); return true; &#125;else if(id == R.id.action_delete) &#123; mMyAdapter.deleteItem(3); Toast.makeText(MainActivity.this, &quot;delete&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item);&#125; 插入、删除数据的代码写在MyAdapter里： 1234567891011 public void addItem(int position,String str)&#123; datas.add(position,str);// notifyDataSetChanged(); notifyItemInserted(position); &#125; public void deleteItem(int position)&#123; datas.remove(position);// notifyDataSetChanged(); notifyItemRemoved(position); &#125; 7 给RecyclerView设置分割线RecyclerView不像ListView，它没有已设置好的分割线，需要自己处理。给RecyclerView设置分割线需要执行以下代码： 12345678910111213141516mRecyclerView.addItemDecoration(new RecyclerView.ItemDecoration() &#123; String str = &quot;我是分割线&quot;; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; .... c.drawText(str,left,top,paint); &#125; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; //通过outRect设置各个item之间的位移间距 outRect.set(0,0,0,getStringHeight(paint)); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"RecyclerView简单使用😲","slug":"RecyclerView简单使用😲","date":"2018-10-10T16:00:00.000Z","updated":"2020-09-16T09:07:51.000Z","comments":true,"path":"2018/10/11/RecyclerView简单使用😲/","link":"","permalink":"http://mariogogogo.github.io/2018/10/11/RecyclerView%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%F0%9F%98%B2/","excerpt":"RecyclerView简单使用😲","text":"RecyclerView简单使用😲 基本使用：1.使用前需要在在gradle中添加依赖1implementation &#x27;com.android.support:recyclerview-v7:27.0.2&#x27;2.编写代码，首先我们需要在Xml中写RecyclerView的布局，12345&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;3.然后在activity中获取RecyclerView，并设置LayoutManager以及adapter1234567891011//通过findViewById拿到RecyclerView实例mRecyclerView = findViewById(R.id.recyclerView);//设置RecyclerView管理器mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));//初始化适配器mAdapter = new MyRecyclerViewAdapter(list); //设置添加或删除item时的动画，这里使用默认动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//设置适配器mRecyclerView.setAdapter(mAdapter);下面是MyRecyclerViewAdapter的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.sharejoys.recyclerviewdemo.actvity; import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView; import com.sharejoys.recyclerviewdemo.R; import java.util.List; public class MyRecyclerViewAdapterextends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; private List&lt;String&gt; list; public MyAdapter(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_base_use, parent, false); MyAdapter.ViewHolder viewHolder = new MyAdapter.ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(MyAdapter.ViewHolder holder, int position) &#123; holder.mText.setText(list.get(position)); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView mText; ViewHolder(View itemView) &#123; super(itemView); mText = itemView.findViewById(R.id.item_tx); &#125; &#125;&#125; 设置横向布局：12mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"解决ScrollView底部有布局不能滑动的问题","slug":"解决ScrollView底部有布局不能滑动的问题","date":"2018-10-09T16:00:00.000Z","updated":"2020-09-16T09:07:06.000Z","comments":true,"path":"2018/10/10/解决ScrollView底部有布局不能滑动的问题/","link":"","permalink":"http://mariogogogo.github.io/2018/10/10/%E8%A7%A3%E5%86%B3ScrollView%E5%BA%95%E9%83%A8%E6%9C%89%E5%B8%83%E5%B1%80%E4%B8%8D%E8%83%BD%E6%BB%91%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"今天在做项目时用到ScrollView,我发现如果在ScrollView控件之后没有别的布局时它能正常滑动.但是如果底部有功能按钮,比如下图这样就不能显示完全.","text":"今天在做项目时用到ScrollView,我发现如果在ScrollView控件之后没有别的布局时它能正常滑动.但是如果底部有功能按钮,比如下图这样就不能显示完全. 解决办法必须知道底部菜单的高度 然后就 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--头部--&gt; &lt;RelativeLayout android:id=&quot;@+id/layout_me_header&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#008cc9&quot;&gt; &lt;Button android:id=&quot;@+id/login_btn&quot; android:layout_width=&quot;66dp&quot; android:layout_height=&quot;66dp&quot; android:background=&quot;@mipmap/login_btn&quot; android:layout_centerHorizontal=&quot;true&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:layout_below=&quot;@+id/login_btn&quot; android:layout_marginBottom=&quot;10dp&quot; &gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:src=&quot;@mipmap/me_menu_yh&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;收藏&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:src=&quot;@mipmap/me_menu_go&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;购物券&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:src=&quot;@mipmap/me_menu_sail&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;优惠券&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;!--空白占位符--&gt; &lt;RelativeLayout android:id=&quot;@+id/layout_me_bottom&quot; android:layout_width=&quot;match_parent&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_height=&quot;70dp&quot;&gt; &lt;/RelativeLayout&gt; &lt;!--滚动列表 功能区--&gt; &lt;ScrollView android:layout_below=&quot;@+id/layout_me_header&quot; android:layout_above=&quot;@+id/layout_me_bottom&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#fff&quot; android:paddingTop=&quot;6dp&quot; &gt; &lt;ImageView android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:src=&quot;@mipmap/list_save&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/text_my_save&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我的收藏&quot; android:textSize=&quot;28sp&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#ccc&quot; android:layout_below=&quot;@+id/text_my_save&quot; android:paddingTop=&quot;8dp&quot; android:layout_marginRight=&quot;10dp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#fff&quot; android:paddingTop=&quot;6dp&quot; &gt; &lt;ImageView android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:src=&quot;@mipmap/list_pwd&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/text_my_pwd&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我的口令&quot; android:textSize=&quot;28sp&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#ccc&quot; android:layout_below=&quot;@+id/text_my_pwd&quot; android:paddingTop=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#fff&quot; android:paddingTop=&quot;6dp&quot; android:paddingBottom=&quot;6dp&quot; &gt; &lt;ImageView android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:src=&quot;@mipmap/list_safe_center&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/text_my_safecenter&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我的锦囊&quot; android:textSize=&quot;28sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/RelativeLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"ListView的使用","slug":"Android颜色设置的几种方法","date":"2018-10-03T16:00:00.000Z","updated":"2020-09-16T09:07:17.000Z","comments":true,"path":"2018/10/04/Android颜色设置的几种方法/","link":"","permalink":"http://mariogogogo.github.io/2018/10/04/Android%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"class中设置 今天主要记录这个","text":"class中设置 今天主要记录这个利用系统自带的颜色类tx.setTextColor(android.graphics.Color.RED);利用数字设置tx.setTextColor(0xffff00f);利用xml中已经定义好的颜色代码tx.setTextColor(getResources().getColor(R.color.red));利用16进制 字符串tx.setTextColor(Color.parseColor(“#FFFFFF”)); 附上一段颜色代码。以供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt; &lt;!--白色 --&gt; &lt;color name=&quot;ivory&quot;&gt;#FFFFF0&lt;/color&gt; &lt;!--象牙色 --&gt; &lt;color name=&quot;lightyellow&quot;&gt;#FFFFE0&lt;/color&gt; &lt;!--亮黄色 --&gt; &lt;color name=&quot;yellow&quot;&gt;#FFFF00&lt;/color&gt; &lt;!--黄色 --&gt; &lt;color name=&quot;snow&quot;&gt;#FFFAFA&lt;/color&gt; &lt;!--雪白色 --&gt; &lt;color name=&quot;floralwhite&quot;&gt;#FFFAF0&lt;/color&gt; &lt;!--花白色 --&gt; &lt;color name=&quot;lemonchiffon&quot;&gt;#FFFACD&lt;/color&gt; &lt;!--柠檬绸色 --&gt; &lt;color name=&quot;cornsilk&quot;&gt;#FFF8DC&lt;/color&gt; &lt;!--米绸色 --&gt; &lt;color name=&quot;seashell&quot;&gt;#FFF5EE&lt;/color&gt; &lt;!--海贝色 --&gt; &lt;color name=&quot;lavenderblush&quot;&gt;#FFF0F5&lt;/color&gt; &lt;!--淡紫红 --&gt; &lt;color name=&quot;papayawhip&quot;&gt;#FFEFD5&lt;/color&gt; &lt;!--番木色 --&gt; &lt;color name=&quot;blanchedalmond&quot;&gt;#FFEBCD&lt;/color&gt; &lt;!--白杏色 --&gt; &lt;color name=&quot;mistyrose&quot;&gt;#FFE4E1&lt;/color&gt; &lt;!--浅玫瑰色 --&gt; &lt;color name=&quot;bisque&quot;&gt;#FFE4C4&lt;/color&gt; &lt;!--桔黄色 --&gt; &lt;color name=&quot;moccasin&quot;&gt;#FFE4B5&lt;/color&gt; &lt;!--鹿皮色 --&gt; &lt;color name=&quot;navajowhite&quot;&gt;#FFDEAD&lt;/color&gt; &lt;!--纳瓦白 --&gt; &lt;color name=&quot;peachpuff&quot;&gt;#FFDAB9&lt;/color&gt; &lt;!--桃色 --&gt; &lt;color name=&quot;gold&quot;&gt;#FFD700&lt;/color&gt; &lt;!--金色 --&gt; &lt;color name=&quot;pink&quot;&gt;#FFC0CB&lt;/color&gt; &lt;!--粉红色 --&gt; &lt;color name=&quot;lightpink&quot;&gt;#FFB6C1&lt;/color&gt; &lt;!--亮粉红色 --&gt; &lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt; &lt;!--橙色 --&gt; &lt;color name=&quot;lightsalmon&quot;&gt;#FFA07A&lt;/color&gt; &lt;!--亮肉色 --&gt; &lt;color name=&quot;darkorange&quot;&gt;#FF8C00&lt;/color&gt; &lt;!--暗桔黄色 --&gt; &lt;color name=&quot;coral&quot;&gt;#FF7F50&lt;/color&gt; &lt;!--珊瑚色 --&gt; &lt;color name=&quot;hotpink&quot;&gt;#FF69B4&lt;/color&gt; &lt;!--热粉红色 --&gt; &lt;color name=&quot;tomato&quot;&gt;#FF6347&lt;/color&gt; &lt;!--西红柿色 --&gt; &lt;color name=&quot;orangered&quot;&gt;#FF4500&lt;/color&gt; &lt;!--红橙色 --&gt; &lt;color name=&quot;deeppink&quot;&gt;#FF1493&lt;/color&gt; &lt;!--深粉红色 --&gt; &lt;color name=&quot;fuchsia&quot;&gt;#FF00FF&lt;/color&gt; &lt;!--紫红色 --&gt; &lt;color name=&quot;magenta&quot;&gt;#FF00FF&lt;/color&gt; &lt;!--红紫色 --&gt; &lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt; &lt;!--红色 --&gt; &lt;color name=&quot;oldlace&quot;&gt;#FDF5E6&lt;/color&gt; &lt;!--老花色 --&gt; &lt;color name=&quot;lightgoldenrodyellow&quot;&gt;#FAFAD2&lt;/color&gt; &lt;!--亮金黄色 --&gt; &lt;color name=&quot;linen&quot;&gt;#FAF0E6&lt;/color&gt; &lt;!--亚麻色 --&gt; &lt;color name=&quot;antiquewhite&quot;&gt;#FAEBD7&lt;/color&gt; &lt;!--古董白 --&gt; &lt;color name=&quot;salmon&quot;&gt;#FA8072&lt;/color&gt; &lt;!--鲜肉色 --&gt; &lt;color name=&quot;ghostwhite&quot;&gt;#F8F8FF&lt;/color&gt; &lt;!--幽灵白 --&gt; &lt;color name=&quot;mintcream&quot;&gt;#F5FFFA&lt;/color&gt; &lt;!--薄荷色 --&gt; &lt;color name=&quot;whitesmoke&quot;&gt;#F5F5F5&lt;/color&gt; &lt;!--烟白色 --&gt; &lt;color name=&quot;beige&quot;&gt;#F5F5DC&lt;/color&gt; &lt;!--米色 --&gt; &lt;color name=&quot;wheat&quot;&gt;#F5DEB3&lt;/color&gt; &lt;!--浅黄色 --&gt; &lt;color name=&quot;sandybrown&quot;&gt;#F4A460&lt;/color&gt; &lt;!--沙褐色 --&gt; &lt;color name=&quot;azure&quot;&gt;#F0FFFF&lt;/color&gt; &lt;!--天蓝色 --&gt; &lt;color name=&quot;honeydew&quot;&gt;#F0FFF0&lt;/color&gt; &lt;!--蜜色 --&gt; &lt;color name=&quot;aliceblue&quot;&gt;#F0F8FF&lt;/color&gt; &lt;!--艾利斯兰 --&gt; &lt;color name=&quot;khaki&quot;&gt;#F0E68C&lt;/color&gt; &lt;!--黄褐色 --&gt; &lt;color name=&quot;lightcoral&quot;&gt;#F08080&lt;/color&gt; &lt;!--亮珊瑚色 --&gt; &lt;color name=&quot;palegoldenrod&quot;&gt;#EEE8AA&lt;/color&gt; &lt;!--苍麒麟色 --&gt; &lt;color name=&quot;violet&quot;&gt;#EE82EE&lt;/color&gt; &lt;!--紫罗兰色 --&gt; &lt;color name=&quot;darksalmon&quot;&gt;#E9967A&lt;/color&gt; &lt;!--暗肉色 --&gt; &lt;color name=&quot;lavender&quot;&gt;#E6E6FA&lt;/color&gt; &lt;!--淡紫色 --&gt; &lt;color name=&quot;lightcyan&quot;&gt;#E0FFFF&lt;/color&gt; &lt;!--亮青色 --&gt; &lt;color name=&quot;burlywood&quot;&gt;#DEB887&lt;/color&gt; &lt;!--实木色 --&gt; &lt;color name=&quot;plum&quot;&gt;#DDA0DD&lt;/color&gt; &lt;!--洋李色 --&gt; &lt;color name=&quot;gainsboro&quot;&gt;#DCDCDC&lt;/color&gt; &lt;!--淡灰色 --&gt; &lt;color name=&quot;crimson&quot;&gt;#DC143C&lt;/color&gt; &lt;!--暗深红色 --&gt; &lt;color name=&quot;palevioletred&quot;&gt;#DB7093&lt;/color&gt; &lt;!--苍紫罗兰色 --&gt; &lt;color name=&quot;goldenrod&quot;&gt;#DAA520&lt;/color&gt; &lt;!--金麒麟色 --&gt; &lt;color name=&quot;orchid&quot;&gt;#DA70D6&lt;/color&gt; &lt;!--淡紫色 --&gt; &lt;color name=&quot;thistle&quot;&gt;#D8BFD8&lt;/color&gt; &lt;!--蓟色 --&gt; &lt;color name=&quot;lightgray&quot;&gt;#D3D3D3&lt;/color&gt; &lt;!--亮灰色 --&gt; &lt;color name=&quot;lightgrey&quot;&gt;#D3D3D3&lt;/color&gt; &lt;!--亮灰色 --&gt; &lt;color name=&quot;tan&quot;&gt;#D2B48C&lt;/color&gt; &lt;!--茶色 --&gt; &lt;color name=&quot;chocolate&quot;&gt;#D2691E&lt;/color&gt; &lt;!--巧可力色 --&gt; &lt;color name=&quot;peru&quot;&gt;#CD853F&lt;/color&gt; &lt;!--秘鲁色 --&gt; &lt;color name=&quot;indianred&quot;&gt;#CD5C5C&lt;/color&gt; &lt;!--印第安红 --&gt; &lt;color name=&quot;mediumvioletred&quot;&gt;#C71585&lt;/color&gt; &lt;!--中紫罗兰色 --&gt; &lt;color name=&quot;silver&quot;&gt;#C0C0C0&lt;/color&gt; &lt;!--银色 --&gt; &lt;color name=&quot;darkkhaki&quot;&gt;#BDB76B&lt;/color&gt; &lt;!--暗黄褐色--&gt; &lt;color name=&quot;rosybrown&quot;&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt; &lt;color name=&quot;mediumorchid&quot;&gt;#BA55D3&lt;/color&gt; &lt;!--中粉紫色 --&gt; &lt;color name=&quot;darkgoldenrod&quot;&gt;#B8860B&lt;/color&gt; &lt;!--暗金黄色 --&gt; &lt;color name=&quot;firebrick&quot;&gt;#B22222&lt;/color&gt; &lt;!--火砖色 --&gt; &lt;color name=&quot;powderblue&quot;&gt;#B0E0E6&lt;/color&gt; &lt;!--粉蓝色 --&gt; &lt;color name=&quot;lightsteelblue&quot;&gt;#B0C4DE&lt;/color&gt; &lt;!--亮钢兰色--&gt; &lt;color name=&quot;paleturquoise&quot;&gt;#AFEEEE&lt;/color&gt; &lt;!--苍宝石绿 --&gt; &lt;color name=&quot;greenyellow&quot;&gt;#ADFF2F&lt;/color&gt; &lt;!--黄绿色 --&gt; &lt;color name=&quot;lightblue&quot;&gt;#ADD8E6&lt;/color&gt; &lt;!--亮蓝色 --&gt; &lt;color name=&quot;darkgray&quot;&gt;#A9A9A9&lt;/color&gt; &lt;!--暗灰色 --&gt; &lt;color name=&quot;darkgrey&quot;&gt;#A9A9A9&lt;/color&gt; &lt;!--暗灰色 --&gt; &lt;color name=&quot;brown&quot;&gt;#A52A2A&lt;/color&gt; &lt;!--褐色 --&gt; &lt;color name=&quot;sienna&quot;&gt;#A0522D&lt;/color&gt; &lt;!--赭色 --&gt; &lt;color name=&quot;darkorchid&quot;&gt;#9932CC&lt;/color&gt; &lt;!--暗紫色 --&gt; &lt;color name=&quot;palegreen&quot;&gt;#98FB98&lt;/color&gt; &lt;!--苍绿色 --&gt; &lt;color name=&quot;darkviolet&quot;&gt;#9400D3&lt;/color&gt; &lt;!--暗紫罗兰色 --&gt; &lt;color name=&quot;mediumpurple&quot;&gt;#9370DB&lt;/color&gt; &lt;!--中紫色 --&gt; &lt;color name=&quot;lightgreen&quot;&gt;#90EE90&lt;/color&gt; &lt;!--亮绿色 --&gt; &lt;color name=&quot;darkseagreen&quot;&gt;#8FBC8F&lt;/color&gt; &lt;!--暗海兰色 --&gt; &lt;color name=&quot;saddlebrown&quot;&gt;#8B4513&lt;/color&gt; &lt;!--重褐色 --&gt; &lt;color name=&quot;darkmagenta&quot;&gt;#8B008B&lt;/color&gt; &lt;!--暗洋红 --&gt; &lt;color name=&quot;darkred&quot;&gt;#8B0000&lt;/color&gt; &lt;!--暗红色 --&gt; &lt;color name=&quot;blueviolet&quot;&gt;#8A2BE2&lt;/color&gt; &lt;!--紫罗兰蓝色 --&gt; &lt;color name=&quot;lightskyblue&quot;&gt;#87CEFA&lt;/color&gt; &lt;!--亮天蓝色 --&gt; &lt;color name=&quot;skyblue&quot;&gt;#87CEEB&lt;/color&gt; &lt;!--天蓝色 --&gt; &lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt; &lt;!--灰色 --&gt; &lt;color name=&quot;grey&quot;&gt;#808080&lt;/color&gt; &lt;!--灰色 --&gt; &lt;color name=&quot;olive&quot;&gt;#808000&lt;/color&gt; &lt;!--橄榄色 --&gt; &lt;color name=&quot;purple&quot;&gt;#800080&lt;/color&gt; &lt;!--紫色 --&gt; &lt;color name=&quot;maroon&quot;&gt;#800000&lt;/color&gt; &lt;!--粟色 --&gt; &lt;color name=&quot;aquamarine&quot;&gt;#7FFFD4&lt;/color&gt; &lt;!--碧绿色 --&gt; &lt;color name=&quot;chartreuse&quot;&gt;#7FFF00&lt;/color&gt; &lt;!--黄绿色 --&gt; &lt;color name=&quot;lawngreen&quot;&gt;#7CFC00&lt;/color&gt; &lt;!--草绿色 --&gt; &lt;color name=&quot;mediumslateblue&quot;&gt;#7B68EE&lt;/color&gt; &lt;!--中暗蓝色 --&gt; &lt;color name=&quot;lightslategray&quot;&gt;#778899&lt;/color&gt; &lt;!--亮蓝灰 --&gt; &lt;color name=&quot;lightslategrey&quot;&gt;#778899&lt;/color&gt; &lt;!--亮蓝灰 --&gt; &lt;color name=&quot;slategray&quot;&gt;#708090&lt;/color&gt; &lt;!--灰石色 --&gt; &lt;color name=&quot;slategrey&quot;&gt;#708090&lt;/color&gt; &lt;!--灰石色 --&gt; &lt;color name=&quot;olivedrab&quot;&gt;#6B8E23&lt;/color&gt; &lt;!--深绿褐色 --&gt; &lt;color name=&quot;slateblue&quot;&gt;#6A5ACD&lt;/color&gt; &lt;!--石蓝色 --&gt; &lt;color name=&quot;dimgray&quot;&gt;#696969&lt;/color&gt; &lt;!--暗灰色 --&gt; &lt;color name=&quot;dimgrey&quot;&gt;#696969&lt;/color&gt; &lt;!--暗灰色 --&gt; &lt;color name=&quot;mediumaquamarine&quot;&gt;#66CDAA&lt;/color&gt; &lt;!--中绿色 --&gt; &lt;color name=&quot;cornflowerblue&quot;&gt;#6495ED&lt;/color&gt; &lt;!--菊兰色 --&gt; &lt;color name=&quot;cadetblue&quot;&gt;#5F9EA0&lt;/color&gt; &lt;!--军兰色 --&gt; &lt;color name=&quot;darkolivegreen&quot;&gt;#556B2F&lt;/color&gt; &lt;!--暗橄榄绿--&gt; &lt;color name=&quot;indigo&quot;&gt;#4B0082&lt;/color&gt; &lt;!--靛青色 --&gt; &lt;color name=&quot;mediumturquoise&quot;&gt;#48D1CC&lt;/color&gt; &lt;!--中绿宝石 --&gt; &lt;color name=&quot;darkslateblue&quot;&gt;#483D8B&lt;/color&gt; &lt;!--暗灰蓝色 --&gt; &lt;color name=&quot;steelblue&quot;&gt;#4682B4&lt;/color&gt; &lt;!--钢兰色 --&gt; &lt;color name=&quot;royalblue&quot;&gt;#4169E1&lt;/color&gt; &lt;!--皇家蓝 --&gt; &lt;color name=&quot;turquoise&quot;&gt;#40E0D0&lt;/color&gt; &lt;!--青绿色 --&gt; &lt;color name=&quot;mediumseagreen&quot;&gt;#3CB371&lt;/color&gt; &lt;!--中海蓝 --&gt; &lt;color name=&quot;limegreen&quot;&gt;#32CD32&lt;/color&gt; &lt;!--橙绿色 --&gt; &lt;color name=&quot;darkslategray&quot;&gt;#2F4F4F&lt;/color&gt; &lt;!--暗瓦灰色 --&gt; &lt;color name=&quot;darkslategrey&quot;&gt;#2F4F4F&lt;/color&gt; &lt;!--暗瓦灰色 --&gt; &lt;color name=&quot;seagreen&quot;&gt;#2E8B57&lt;/color&gt; &lt;!--海绿色 --&gt; &lt;color name=&quot;forestgreen&quot;&gt;#228B22&lt;/color&gt; &lt;!--森林绿 --&gt; &lt;color name=&quot;lightseagreen&quot;&gt;#20B2AA&lt;/color&gt; &lt;!--亮海蓝色 --&gt; &lt;color name=&quot;dodgerblue&quot;&gt;#1E90FF&lt;/color&gt; &lt;!--闪兰色 --&gt; &lt;color name=&quot;midnightblue&quot;&gt;#191970&lt;/color&gt; &lt;!--中灰兰色 --&gt; &lt;color name=&quot;aqua&quot;&gt;#00FFFF&lt;/color&gt; &lt;!--浅绿色 --&gt; &lt;color name=&quot;cyan&quot;&gt;#00FFFF&lt;/color&gt; &lt;!--青色 --&gt; &lt;color name=&quot;springgreen&quot;&gt;#00FF7F&lt;/color&gt; &lt;!--春绿色 --&gt; &lt;color name=&quot;lime&quot;&gt;#00FF00&lt;/color&gt; &lt;!--酸橙色 --&gt; &lt;color name=&quot;mediumspringgreen&quot;&gt;#00FA9A&lt;/color&gt; &lt;!--中春绿色 --&gt; &lt;color name=&quot;darkturquoise&quot;&gt;#00CED1&lt;/color&gt; &lt;!--暗宝石绿 --&gt; &lt;color name=&quot;deepskyblue&quot;&gt;#00BFFF&lt;/color&gt; &lt;!--深天蓝色 --&gt; &lt;color name=&quot;darkcyan&quot;&gt;#008B8B&lt;/color&gt; &lt;!--暗青色 --&gt; &lt;color name=&quot;teal&quot;&gt;#008080&lt;/color&gt; &lt;!--水鸭色 --&gt; &lt;color name=&quot;green&quot;&gt;#008000&lt;/color&gt; &lt;!--绿色 --&gt; &lt;color name=&quot;darkgreen&quot;&gt;#006400&lt;/color&gt; &lt;!--暗绿色 --&gt; &lt;color name=&quot;blue&quot;&gt;#0000FF&lt;/color&gt; &lt;!--蓝色 --&gt; &lt;color name=&quot;mediumblue&quot;&gt;#0000CD&lt;/color&gt; &lt;!--中兰色 --&gt; &lt;color name=&quot;darkblue&quot;&gt;#00008B&lt;/color&gt; &lt;!--暗蓝色 --&gt; &lt;color name=&quot;navy&quot;&gt;#000080&lt;/color&gt; &lt;!--海军色 --&gt; &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt; &lt;!--黑色 --&gt;&lt;/resources&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"Log封装","slug":"Log封装","date":"2018-10-02T16:00:00.000Z","updated":"2020-09-16T09:07:39.000Z","comments":true,"path":"2018/10/03/Log封装/","link":"","permalink":"http://mariogogogo.github.io/2018/10/03/Log%E5%B0%81%E8%A3%85/","excerpt":"在调试代码的时候我们需要查看调试信息，那我们就需要用Android Log类。","text":"在调试代码的时候我们需要查看调试信息，那我们就需要用Android Log类。android.util.Log常用的方法有以下5个：Log.v() Log.d() Log.i() Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG,INFO, WARN，ERROR。 Log.v 的调试颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v(“”,””); Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择. Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息 Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。 Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。 注意：不同的打印方法在使用时都是某个方法带上(String tag, String msg)参数，tag表示的是打印信息的标签，msg表示的是需要打印的信息。 123456789101112131415161718192021222324252627282930313233343536public class LogUtil &#123; public static final int VERBOSE =1; public static final int DEBUG =2; public static final int INFO =3; public static final int WARN =4; public static final int ERROR =5; public static final int NOTHING =6; public static final int level =VERBOSE; public static void v(String tag,String msg)&#123; if(level &lt;= VERBOSE)&#123; Log.v(tag,msg); &#125; &#125; public static void d(String tag,String msg)&#123; if(level &lt;= VERBOSE)&#123; Log.d(tag,msg); &#125; &#125; public static void i(String tag,String msg)&#123; if(level &lt;= VERBOSE)&#123; Log.i(tag,msg); &#125; &#125; public static void w(String tag,String msg)&#123; if(level &lt;= VERBOSE)&#123; Log.w(tag,msg); &#125; &#125; public static void e(String tag,String msg)&#123; if(level &lt;= VERBOSE)&#123; Log.e(tag,msg); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"写个Splash闪屏页","slug":"写个Splash闪屏页","date":"2018-10-01T16:00:00.000Z","updated":"2020-09-16T09:07:14.000Z","comments":true,"path":"2018/10/02/写个Splash闪屏页/","link":"","permalink":"http://mariogogogo.github.io/2018/10/02/%E5%86%99%E4%B8%AASplash%E9%97%AA%E5%B1%8F%E9%A1%B5/","excerpt":"知识点 倒计时如何写？ 点击跳转 更新UI 跳转之后的handle处理","text":"知识点 倒计时如何写？ 点击跳转 更新UI 跳转之后的handle处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.imooc.book;import android.app.Activity;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.Toast;import com.loopj.android.http.AsyncHttpClient;import com.loopj.android.http.AsyncHttpResponseHandler;import java.lang.ref.WeakReference;import cz.msebera.android.httpclient.Header;public class SpashActivity extends Activity &#123; public static final int CODE = 1001; public static final int TOTAL_TIME = 3000; //总共三秒 public static final int INTERVAL_TIME = 1000; //间隔时间 private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_spash); mTextView = (TextView) findViewById(R.id.time_text_view); final MyHandler handler = new MyHandler(this);// 而Handler中obtainMessage与new Message的差别：// obtainmessage（）是从消息池中拿来一个msg 不须要另开辟空间new// new须要又一次申请，效率低，obtianmessage能够循环利用。// Message message = new Message(); Message message = Message.obtain(); message.what = CODE; message.arg1 = TOTAL_TIME; handler.sendMessage(message);// mTextView.setOnClickListener(this); mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击跳过 BookListActivity.start(SpashActivity.this); SpashActivity.this.finish(); //必须关闭handler中的服务 handler.removeMessages(CODE); &#125; &#125;); AsyncHttpClient client = new AsyncHttpClient(); client.get(&quot;https://www.google.com&quot;, new AsyncHttpResponseHandler() &#123; @Override public void onStart() &#123; // called before request is started &#125; @Override public void onSuccess(int statusCode, Header[] headers, byte[] response) &#123; // called when response HTTP status is &quot;200 OK&quot; &#125; @Override public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) &#123; // called when response HTTP status is &quot;4XX&quot; (eg. 401, 403, 404) &#125; @Override public void onRetry(int retryNo) &#123; // called when request is retried &#125; &#125;); &#125;// @Override// public void onClick(View v) &#123;// switch (v.getId())&#123;// case R.id.time_text_view:// //点击跳过// BookListActivity.start(SpashActivity.this);// SpashActivity.this.finish();// break;// &#125;// &#125; public static class MyHandler extends Handler&#123; public final WeakReference&lt;SpashActivity&gt; mWwakReference; public MyHandler(SpashActivity activity)&#123; mWwakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg)&#123; super.handleMessage(msg); SpashActivity activity = mWwakReference.get(); if(msg.what == CODE)&#123; if(activity != null)&#123; //设置textview 更新UI int time = msg.arg1; //第一次就是三秒 activity.mTextView.setText(time/INTERVAL_TIME + &quot;秒，点击跳过&quot;); //再发送倒计时 Message message = Message.obtain(); message.what = CODE; message.arg1 = time-INTERVAL_TIME; if(time&gt;0)&#123; //倒计时继续 sendMessageDelayed(message,INTERVAL_TIME); &#125;else&#123; //TODO:跳转页面 Toast.makeText(activity,&quot;跳转到列表&quot;,Toast.LENGTH_SHORT).show(); BookListActivity.start(activity); activity.finish(); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"泛型知识点","slug":"泛型知识点","date":"2018-09-30T16:00:00.000Z","updated":"2020-09-16T09:07:02.000Z","comments":true,"path":"2018/10/01/泛型知识点/","link":"","permalink":"http://mariogogogo.github.io/2018/10/01/%E6%B3%9B%E5%9E%8B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"点击我传送过去看看吧","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"ListView的使用","slug":"ListView的使用","date":"2018-09-12T16:00:00.000Z","updated":"2020-09-16T09:07:39.000Z","comments":true,"path":"2018/09/13/ListView的使用/","link":"","permalink":"http://mariogogogo.github.io/2018/09/13/ListView%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"ListView 简介一、ListView 是 android 中常用的一个控件,通常是以列表的形式展示数据,并且当加载的数据过多的时候可以分页加载,动态显示数据,通常是横向显示数据。","text":"ListView 简介一、ListView 是 android 中常用的一个控件,通常是以列表的形式展示数据,并且当加载的数据过多的时候可以分页加载,动态显示数据,通常是横向显示数据。 Adapter一般有以下的几种实现类:ArrayAdapter，SimpleAdapter，SimpleCursorAdapter,BaseAdapter ArrayAdapter的每一个列表只能是一个TextView，ArrayAdapter的使用方法如下: ArrayAdapter adapter=new ArrayAdapter(Context,一个TextView布局,String 数组); 二、ListView 实现数据加载的步骤:ListView 适合“自底向上”的开发模式即从每个条目的显示组件到对其进行 控制的数据结构最后通过 Activity 等进行使用。a）首先是 item 组件,即用于每项布局输出的 xml 文件。 Android SDK 中有 simple_list_item_1、simple_list_item_2 可用 当需要比较丰富的显示效果时, 一般通过自定义 xml 实现。b）其次是父对象 layout 文件,即用于 Activity 或者 Fragment 的布局输出文件,一 般在此输出文件中包含 ListView。 当然,如果采用 ListFragment 或 ListActivity, 并不需要再显示的定义 ListView 组件 c）定义数据结构(容器),即用于持有单个 Item 的数据,可以是简单的 String,也 可以通过抽象 Items 所需字段组成一个类,抽象的原则是与 Item 中的组件对应。 本文中上图涉及多个字段,因此通过抽象组件形成 BBSTopicItem 类。 d）列表适配器。决定每行 Item 中具体显示什么内容,以怎样的样式显示等,通常通 过继承 ArrayAdapter、SimpleAdapter 等实现。本文定义 BBSTopicAdapter, 继承于 ArrayAdapter。 e）最后,需要定义一个 Activity 或 Fragment 来使用上述模块。 ListView的简单用法实现步骤：首先新建一个项目， 并让ADT 自动帮我们创建好活动。然后修改activity_main.xml 中的代码，如下所示： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; 在MainActivity 中首页 123//1.创建一个列表ListView listView = (ListView)findViewById(R.id.list_view); 然后123456789101112131415161718192021222324252627//2.创建一些数据 initFruits(); private void initFruits() &#123; for (int i = 0; i &lt; 12; i++) &#123; Fruit apple = new Fruit(&quot;Apple&quot;, R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(&quot;Orange&quot;, R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(&quot;Pear&quot;, R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic); fruitList.add(mango); &#125; &#125;然后1234//3 将数据导入ListView// 创建实例化一个adapter 将数据传入其中NewFuritAdapter adapter = new NewFuritAdapter(fruitList);最后12listView.setAdapter(adapter);创建Adapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FuritAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; /** * 重写父类的构造函数 * @param context 上下文对象 * @param textViewResourceId 子项布局的ID * @param objects 数据源 */ public FuritAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects)&#123; super(context,textViewResourceId,objects); resourceId = textViewResourceId; &#125; /** *这个方法再子项目滚动到屏幕内的时候会被调用， * @param position * @param convertView 缓存数据的参数 * @param parent * @return */ @Override public View getView(int position, View convertView, ViewGroup parent)&#123; //获取当前fruit的实例 Fruit fruit = getItem(position); //默认初始化viewHolder类 ViewHolder viewHolder; if(convertView == null)&#123; convertView = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); //当convertView刚创建的时候 存储viewholder子控件 viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name) ; //view与setTag绑定 当往下滑动会调用getView的方法 convertView.setTag(viewHolder); &#125;else&#123; viewHolder = (ViewHolder)convertView.getTag(); &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return convertView; &#125; class ViewHolder&#123; ImageView fruitImage; TextView fruitName; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"Android studio断点调试","slug":"Android studio断点调试","date":"2018-09-11T16:00:00.000Z","updated":"2020-09-16T09:07:17.000Z","comments":true,"path":"2018/09/12/Android studio断点调试/","link":"","permalink":"http://mariogogogo.github.io/2018/09/12/Android%20studio%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"工具如何使用","text":"工具如何使用 设置断点（点击红点位置添加或取消断点） 点击debug模式运行 一、简单调试1. step over：一步步往下走 当前程序运行的位置，我们看到i的值已经在程序代码中展示出来了，黄色的代码处，这个是AS的功能，对于我们调试来讲，这简直是非常大的福利了。 这时我们继续F8，我们切换到logcat查看日志，我打印出的i的值是0 2. step into：看到方法往里走 比如我们的for循环当中调用了一个stepNext(int i)方法，当我们走到这里想看看这个方法里面的运行过程的时候我们可以这样，当走到这个方法的时候我们可以按下F7,或者如下图的图标。 这时就走到了stepNext方法当中。在这里打印了一个log，我们再按一下F8我们来看看Logcat, 这里我打印的log都是为了做教程用，调试我们就不用打log了直接看显示面板就OK了 4. step out ：有断点下一个，走完断点继续走 这里如果我们的一个流程当中，包括调用的方法，如果有断点走到下一个断点，如果没有断点，而是在一个调用的方法当中，会跳出这个方法，继续走。 我现在程序位置在第一个断点位置（24行），我调用的stepNext方法中也有一个断点，此时我按下step out按钮会走到stepNext中的断点处（39行）我此时如果再按一下step out 会走到stepNext方法的调用出的下一个可执行代码（30行） 5. run to Cursor ：下个断点我们见 这里的意思就是说，会很快执行到下一个断点的位置，而且可以静如任何调用的方法 二、高级调试1. 跨断点调试 如果我们设置了多个断点，现在我们需要直接跳转到下一个断点，那么直接点击下图就可以了 2.观察变量 如果我们想观察1个或者几个变量的值的变化，如果我们在Variables显示面版中观察如果我这里有太多太多的自定义变量和系统变量了，那么就难观察了，我们可以做如下操作:点击Watches,点击＋号，然后输入变量的名称回车就OK了，而且会有历史记录哦 如果变量名比较长我们可以这样：选择［Variables］中的变量名然后点击［右键］，选择［Add to Watches],然后Watches面板中就有了","categories":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mariogogogo.github.io/tags/Android/"}]},{"title":"浅谈fetch与axios与ajax","slug":"浅谈fetch与axios与ajax","date":"2018-05-31T16:00:00.000Z","updated":"2020-09-16T09:07:11.000Z","comments":true,"path":"2018/06/01/浅谈fetch与axios与ajax/","link":"","permalink":"http://mariogogogo.github.io/2018/06/01/%E6%B5%85%E8%B0%88fetch%E4%B8%8Eaxios%E4%B8%8Eajax/","excerpt":"1 JQuery ajax这个我就不用多言了把，是对原生XHR的封装，除此以外还增添了对JSONP的支持。有一说一的说一句，JQuery ajax经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有","text":"1 JQuery ajax这个我就不用多言了把，是对原生XHR的封装，除此以外还增添了对JSONP的支持。有一说一的说一句，JQuery ajax经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有123456789$.ajax(&#123; type: &#x27;POST&#x27;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） 尽管JQuery对我们前端的开发工作曾有着（现在也仍然有着）深远的影响，但是我们可以看到随着VUE，REACT新一代框架的兴起，以及ES规范的完善，更多API的更新，JQuery这种大而全的JS库，未来的路会越走越窄。 2 Axios123456789101112131415axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让Axios进入了很多人的目光中。Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，从它的官网上可以看到它有以下几条特性： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作） 这个支持防止CSRF其实挺好玩的，是怎么做到的呢，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 Axios既提供了并发的封装，也没有下文会提到的fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。- 3 Fetch1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 我认为fetch的优势主要优势就是： 更加底层，提供的API丰富（request, response） 脱离了XHR，是ES规范里新的实现方式大家都喜欢新的东西，坦白说，作为一个前端工程师，我在使用原生XHR的时候，尽管偶尔觉得写的丑陋，但是在使用了JQuery和axios之后，已经对这一块完全无所谓了。当然，如果新的fetch能做的同样好，我为了不掉队也会选择使用fetch。这个道理其实很好理解：你有一架歼8，魔改了N次，性能达到了歼10的水准，但是要是有个人给你拿来一架新的歼10，你也会毫不犹豫的选择新的歼10——不仅仅是新，也代表了还有新的魔改潜力。 但是我最近在使用fetch的时候，也遇到了不少的问题： fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装必须重视以下几点 fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 fetch默认不会带cookie，需要添加配置项 fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 fetch没有办法原生监测请求的进度，而XHR可以 看到这里，你心里一定有个疑问，这鬼东西就是个半拉子工程嘛，我还是回去用Jquery或者Axios算了——其实我就是这么打算的。但是，必须要提出的是，我发现fetch在前端的应用上有一项xhr怎么也比不上的能力：跨域的处理。 我们都知道因为同源策略的问题，浏览器的请求是可能随便跨域的——一定要有跨域头或者借助JSONP，但是，fetch中可以设置mode为”no-cors”（不跨域），如下所示： 12345fetch(&#x27;/users.json&#x27;, &#123; method: &#x27;post&#x27;, mode: &#x27;no-cors&#x27;, data: &#123;&#125;&#125;).then(function() &#123; /* handle response */ &#125;); 这样之后我们会得到一个type为“opaque”的返回。需要指出的是，这个请求是真正抵达过后台的，所以我们可以使用这种方法来进行信息上报，在我们之前的image.src方法中多出了一种选择，另外，我们在network中可以看到这个请求后台设置跨域头之后的实际返回，有助于我们提前调试接口（当然，通过chrome插件我们也可以做的到）。总之，fetch现在还不是很好用，我尝试过几个fetch封装的包，都还不尽如人意。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"一起来玩，Koa2!（三）","slug":"一起来玩，Koa2!(三)","date":"2018-05-19T16:00:00.000Z","updated":"2020-09-16T09:07:15.000Z","comments":true,"path":"2018/05/20/一起来玩，Koa2!(三)/","link":"","permalink":"http://mariogogogo.github.io/2018/05/20/%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%8E%A9%EF%BC%8CKoa2!(%E4%B8%89)/","excerpt":"常用服务1. 静态文件服务使用koa-static","text":"常用服务1. 静态文件服务使用koa-static12345678const Koa = require(&#x27;koa&#x27;);const app = new Koa();const serve = require(&quot;koa-static&quot;);app.use(server(_dirname+&quot;/static/html&quot;,&#123;extensions:[&#x27;html&#x27;]&#125;));app.listen(3000) 2. 路由服务1234567891011121314151617181920212223242526272829303132const Koa = require(&#x27;koa&#x27;);const app = new Koa();const router = require(&quot;koa-router&quot;)();var bodyParser= require(&#x27;Koa-bodyparser&#x27;);app.use(bodyParser());app.use(router.routes());router.get(&#x27;/&#x27;,async(ctx,next)=&gt;&#123; ctx.response.body=&#x27;hello,word&#x27;&#125;)router.post(&#x27;/login&#x27;,async(ctx,next)=&gt;&#123; let name = ctx.request.body.name || &#x27;&#x27;; let pwd = ctx.request.body.password || &quot;&quot; if(name === &#x27;koa&#x27; &amp;&amp; pwd === &#x27;123&#x27;)&#123; ctx.body = &#x27;sucdess&#x27; &#125;else&#123; ctx.body = &#x27;false&#x27; &#125;&#125;)//路由也可以这样router.post(&#x27;/del/blog/:blogId&#x27;,async(ctx,next)=&gt;&#123; await dbAPI.deletetblogID(ctx.params.blogId) await next();&#125;) 3. 数据存储安装mongoose1npm i mongoose --save新建db.js 12345678910var mongoose = require(&#x27;mongoose&#x27;);mongoose.connect(&#x27;mongodb://localhost/test&#x27;);var db = mongoose.connection;db.on(&#x27;error&#x27;,console.error.bind(console,&#x27;connection,error&#x27;));db.once(&#x27;open&#x27;,function(callback)&#123; //connected!!!!&#125;) 接下去创建2类文件 schema一种文件形式存储的数据库模型骨架，不具备数据库的操作能力 model又schema发布生成的模型，具备抽象属性和行为的数据库操作对 下面看栗子： 123456789101112131415161718192021const loginSchema = new mongoose.Schema(&#123; username:String, pwd:String&#125;)var login = db.model(&#x27;login&#x27;,loginSchema,&#x27;login&#x27;);var user1 = new login(&#123; username:&#x27;len&#x27;, pwd:&#x27;123&#x27;&#125;)user1.save(function(err)&#123; if(err) return handleError(err) //savee&#125;)//查询var query = login.find(&#123;username:&#x27;len&#x27;&#125;);query.then(function(doc)&#123; console.log(doc)&#125;) 4. 页面渲染使用ejs 前端渲染和后端渲染 服务器渲染优点：首屏加载快，对seo有利 缺点：前后端耦合，代码难易维护且不美观","categories":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/categories/Koa2/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"一起来玩，Koa2!（二）","slug":"一起来玩，Koa2!(二)","date":"2018-05-18T16:00:00.000Z","updated":"2020-09-16T09:07:14.000Z","comments":true,"path":"2018/05/19/一起来玩，Koa2!(二)/","link":"","permalink":"http://mariogogogo.github.io/2018/05/19/%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%8E%A9%EF%BC%8CKoa2!(%E4%BA%8C)/","excerpt":"什么是中间件中间件的本质是接受请求并且做出相应动作的函数，该函数接受req和res,在web应用中，客户端发起的每一个请求，首先要经过中间件处理才能继续向下。","text":"什么是中间件中间件的本质是接受请求并且做出相应动作的函数，该函数接受req和res,在web应用中，客户端发起的每一个请求，首先要经过中间件处理才能继续向下。中间件的第三个参数是next,它代表一个方法，即下一个中间件。 举个栗子：12345function md(req,res,next)&#123; console.log(&#x27;i am a middleware&#x27;); next();&#125; 中间件的功能1.修改req，res对象2.终结请求，响应循环3.调用下一个中间件如果某一个中间件没有调用next方法，则代表请求处理到此为止。 中间件的加载使用use， 12var app = express()app.use(md); next()方法当我们调用app.use方法时，在内部形成了一个中间件数组，在内部会将执行下一个中间件的操作放在next方法内部，当我们执行next方法就代表执行下一个中间件， 中间件的串行调用在实际开发中我们希望一些操作能够串行执行，比如等待写入日志完成后再执行数据库操作，最后再进行路由处理，这样就需要串行调用某些异步中间件 举个Express栗子：12345678910111213var app = require(&#x27;express&#x27;)();app.use(function(req,res,next)&#123; next() console.log(&#x27;i am middleware1&#x27;)&#125;)app.use(function(req,res,next)&#123; process.nextTick(function()&#123; console.log(&#x27;i am middleware1&#x27;) next() &#125;)&#125;)app.listen(3000) 结果：//i am middleware1//i am middleware2 原理就是 第二个中间件调用了 process.nextTick是一个异步调用，因此马上返回到第一个中间件继续执行 举个Koa2栗子：1234567891011121314var Koa = require(&#x27;Koa&#x27;)();var app = new Koa();app.use(async(ctx,next)&#123; await next() console.log(&#x27;i am middleware1&#x27;)&#125;)app.use(async(ctx,next)&#123; process.nextTick(function()&#123; console.log(&#x27;i am middleware1&#x27;) next() &#125;)&#125;)app.listen(3000) 原理 使用了 await ,知道next内部的异步方法完成之前，middleware1都不会向下执行。 再举一个例子-如何实现超时响应使用async 和 promise.race方法来比较setimeout和之后的中间件哪个更快完成。 promise.race方法：哪个返回快，就返回哪个结果，不管成功还是失败 123456789101112131415161718192021app.use(async(ctx,next)=&gt;&#123; var tmr = null const timeout = 5000 await Promise.race([ new Promise(function(resolve,reject)&#123; tmr = setTimeout(function()&#123; var e = new Error(&#x27;request timeout&#x27;) e.status = 408, reject(e) &#125;,timeout) &#125;), new Promise(function(resolve,reject)&#123; (async function()&#123; await next(); clearTimeout(tmr); resolve() &#125;)(); //执行后面加载的中间件 &#125;) ])&#125;) 后续如有更深的体会再补充……","categories":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/categories/Koa2/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"一起来玩，Koa2!（一）","slug":"一起来玩，Koa2!","date":"2018-05-17T16:00:00.000Z","updated":"2020-09-16T09:07:14.000Z","comments":true,"path":"2018/05/18/一起来玩，Koa2!/","link":"","permalink":"http://mariogogogo.github.io/2018/05/18/%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%8E%A9%EF%BC%8CKoa2!/","excerpt":"一 历史渊源：在谈Koa2之前，我们先来认识下Connect,诞生于2010年，可以将Connect理解成node中间件的脚手架，只提供基本的调用逻辑，不具备处理业务逻辑的能力。","text":"一 历史渊源：在谈Koa2之前，我们先来认识下Connect,诞生于2010年，可以将Connect理解成node中间件的脚手架，只提供基本的调用逻辑，不具备处理业务逻辑的能力。例如 用USE next Express这个框架出现在2010年，继承了Connect的大部分思想，在最新的4.x版本，Express拜托了Connect的依赖，摒弃了静态文件模块之外的所有中间件，只保留核心路由处理逻辑及一些其他代码。 但是Express很多场景以及存在问题，之后就推出了Koa1.x Koa2.x.初衷是彻底解决Node web开发异步问题。 二.创建一个最简单的服务器 123456789const Koa = require(&#x27;Koa&#x27;);const app = new Koa;app.use(ctx =&gt;&#123; ctx.body=&#x27;hello,koa2!!!&#x27;&#125;)app.listen(3000); Node提供了request和response这2个对象，Koa把他封装了起来 ctx 是缩写；常用的request： ctx.header ctx,path ctx.query ctx,querystring ctx,get 常用的response ctx.body ctx.status ctx.set() ctx.append() 介绍常用的ctx.state:可以将后端传过来的数据到前端。 12ctx.state.user = await User.find(id) 处理http请求ctx相当与ctx.requert或者ctx.response,判断http方法用ctx.method,get请求用ctx.query 123456app.get(url,async(ctx,next)=&gt;&#123; console.log(ctx.method); console.log(ctx.query); await next();&#125;) get请求直觉拿ctx.req先引入 bodyParserpost请求用ctx.request.body.xxx 12345router.post(url,(ctx,next)=&gt;&#123; const name = ctx.request.body.name const password = ctx.request.body.password&#125;)","categories":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/categories/Koa2/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"http://mariogogogo.github.io/tags/Koa2/"}]},{"title":"Nodejs是什么","slug":"第一章 Nodejs是什么","date":"2018-05-09T16:00:00.000Z","updated":"2020-09-16T09:07:00.000Z","comments":true,"path":"2018/05/10/第一章 Nodejs是什么/","link":"","permalink":"http://mariogogogo.github.io/2018/05/10/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Nodejs%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"1.什么是运行时？举一个例子 所谓运行时（runtime) 就想象成一种编程员的运行的环境 这个运行环境包括代码运行的编译器以及操作系统的底层支持","text":"1.什么是运行时？举一个例子 所谓运行时（runtime) 就想象成一种编程员的运行的环境 这个运行环境包括代码运行的编译器以及操作系统的底层支持 2.什么是回调？回调与异步调用有必然联系吗？回调就是一个函数作为参数传递给另一个函数，并且作为参数的函数可以被执行， 1234[1,2,3].map(function(value)&#123; alert(value)&#125;) 回调函数既可以同步（map）又可以异步（setTimeOut） 与异步调用的关系：在Node中 如果遇到IO操作比如磁盘写入写出，代码发起一个调用后继续向下执行，Io操作完成后，再执行对应的回调函数，虽然代码在单线程环境下，单依靠异步+回调 实现对高并发的支持 12345678910var fs = require(&#x27;fs&#x27;)var callback = function(err,data)&#123; if(err) return console.log(data.toString())&#125;fs.readerFile(&quot;foo.txt&quot;,callback)console.log(&#x27;猜猜谁是不是先被执行啊？&#x27;) 3 什么是事件在交互的页面上，用户发生一系列事件：单击按钮，拖动元素 这些事件按照一定的顺序加载到一个队列中区。 4并行与并发有什么区别和联系举一个例子 并发：火车站取票，2排队伍 只有一个取票机，只能队列头排的人去取票 同时向前移动 并行：火车站取票 2个队伍 2个取票机，同时向前移动 速度是一个窗口的2倍以上。并发是希望做更多的事情（处理多个队列）并行是希望更快的完成任务 联系： 并发中可以存在并行 5.同步与异步，阻塞与非阻塞的区别同步异步是描述进程/线程的调用方式 阻塞非阻塞是针对Io状态而言，关注程序在等待IO调用返回这段事件的状态 他们之间没有必然的联系 阻塞 不等于 同步 非阻塞 不等于 异步 为什么官网 Node没有 标榜自己是异步io 而是非阻塞io呢？因为非阻塞是实打实的 Node的异步Io 是靠 Libuv模拟出来的 同步调用会造成进程的Io阻塞 异步调用不会造成进行的Io阻塞** 6.事件循环的运行过程浏览器循环：Ajax为例，当javascript执行对应代码，注册一个事件，请求后就执行完毕了，后续操作会交给回调函数来处理，浏览器会在不断的遍历事件队列，ajax完成之前，事件队列还是空的（不是请求这动作被加入队列，而是请求完成这一事件被加入队列），当ajax完成后这个队列就好增加一个事件，如果这个事件绑定回调，则循环就去执行这个回调 Node的循环：事件循环由libuv来实现 timers：出来settimeout 和 setinterval的回调 I/O callbacks 除了timers close setImmediate事件回调外，大多数回调在这个阶段执行 idle prepare：内部使用，不管他 poll：轮询 不断检查是否由新的io事件，事件循环可能会在这里阻塞 check： 处理setimmediate事件的回调 close callbacks 处理close相关的事件 7.nextTick的原理是什么 和 setImmaite有什么区别process.nextTick 是一个异步动作 在事件循环当前阶段结束后执行 123456process.nextTick(function()&#123; console.log(&#x27;first&#x27;)&#125;)console.log(&#x27;next&#x27;)//next//first 但是 Node限制了nextTickQueue的大小，当达到最大限制后就会报错区别：setImmediate 不接受一个时间作为参数 在当前事件循环结尾触发，对应的回调在当前事件的循环尾执行process.nextTick 会在当前操作完成后立即执行 会比setImmediate 先执行","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"less的常用方法","slug":"less的常用方法","date":"2018-05-08T16:00:00.000Z","updated":"2020-09-16T09:07:39.000Z","comments":true,"path":"2018/05/09/less的常用方法/","link":"","permalink":"http://mariogogogo.github.io/2018/05/09/less%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"常常用less解决一些问题，一些常用的再记录下","text":"常常用less解决一些问题，一些常用的再记录下 &amp;相当于父元素里的谁12345678910111213141516171819202122@width:10;nav&#123; height: 50px; background-color: #738797; .content&#123; a&#123; color:#fff; &amp;:hover&#123; color: skyblue; &#125; &#125; .left&#123; float:left; &amp;.padding_left&#123; padding-left: @width*2px; &#125; ; &#125; .right&#123; float:right; &#125; &#125; 变量12345678@height :document.documentElement.clientHeight;.content&#123; background: #738797; margin: 0; height: @height *1px;&#125; ; 混合1234567891011121314151617.classa&#123; border:1px solid #b7b7b7;&#125;.clearFix&#123; *zoom:1; &amp;:after&#123; content: &#x27;&#x27;; display: block; clear: both; &#125;&#125;.classb&#123; .classa; .clearFix;&#125; 带参数混合1234567891011121314.border(@color)&#123; border:1px solid @color;&#125;.box1&#123; .border(#b7b7b7);&#125;.box2&#123; .border(#ff0000);&#125;.box3&#123; .border(#b7b7b7);&#125; 多个参数的混合123456789101112131415161718.border(@width,@style,@color)&#123; border:@width @style @color;&#125;.box1&#123; .border(1px,solid,#b7b7b7);&#125;.box2&#123; .border(1px,solid,#ff0000);&#125;.box3&#123; .border(2px,solid,#b7b7b7);&#125;.box4&#123; .border(1px,dotted,#b7b7b7);&#125;* 带默认值的参数混合1234567891011121314151617.border(@width:1px,@style:solid)&#123; border:@width @style #033333;&#125;.box1&#123; .border(1px,dotted);&#125;.box2&#123; .border();&#125;.box3&#123; .border(2px);&#125;.box4&#123; .border();&#125; 模式匹配12345678910111213141516171819202122232425262728293031323334.border(top,@width:1px)&#123; border-top:@width solid #033333;&#125;.border(right,@width:1px)&#123; border-right:@width solid #033333;&#125;.border(bottom,@width:1px)&#123; border-bottom:@width solid #033333;&#125;.border(left,@width:1px)&#123; border-left:@width solid #033333;&#125;.border(@_,@width:1px)&#123; width:round(5.5)*1px;&#125;.box1&#123; .border(top,5px);&#125;.box2&#123; .border(right);&#125;.box3&#123; .border(bottom);&#125;.box4&#123; .border(left);&#125; @_表示无论匹配谁最后都还会执行一次这个方法带上里面的属性** 命名空间123456789101112131415161718.blue&#123; .button&#123; background: blue; &#125;&#125;.red&#123; .button&#123; background: red; &#125;&#125;.box&#123; .blue &gt; .button&#125; 避免编译1234567.box&#123; width:@rem; //转义字符 用二边算法算font要用括号括起来 font:(12/@rem)~&#x27;/&#x27;(20/@rem) &#x27;宋体&#x27;;&#125; 1234//这种注释方法不会被编译到css文件里面去（通常用于生产环节）/* 这种注释会被解析到css文件里面去*/","categories":[{"name":"CSS","slug":"CSS","permalink":"http://mariogogogo.github.io/categories/CSS/"}],"tags":[{"name":"less","slug":"less","permalink":"http://mariogogogo.github.io/tags/less/"}]},{"title":"webpack初体验","slug":"webpack初体验","date":"2018-05-07T16:00:00.000Z","updated":"2020-09-16T09:07:58.000Z","comments":true,"path":"2018/05/08/webpack初体验/","link":"","permalink":"http://mariogogogo.github.io/2018/05/08/webpack%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"前端为什么需要WebPack？现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SCSS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。","text":"前端为什么需要WebPack？现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SCSS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。 现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。 React.js+WebPack Vue.js+WebPack AngluarJS+WebPack 什么是WebPack？ WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 这段话有三个重点： 打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。 转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。 安装12345678//全局安装npm install -g webpacknpm initnpm install --save-dev webpack@3.10.0&lt;!--查看webpack版本--&gt;webpack -v 主要配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&quot;use strict&quot;;const path = require(&quot;path&quot;);const HTMLPlugin = require(&quot;html-webpack-plugin&quot;);const webpack = require(&quot;webpack&quot;);const isDev = process.env.NODE_ENV === &quot;development&quot;;const config = &#123; entry: &#123; app: path.join(__dirname, &quot;../client/app.js&quot;) //入口文件 &#125;, output: &#123; filename: &quot;[name].[hash].js&quot;, path: path.resolve(__dirname, &quot;../dist&quot;), //打包后输出文件 publicPath: &quot;/public/&quot; &#125;, module: &#123; rules: [ &#123; test: /\\.jsx$/, use: &quot;babel-loader&quot; // 编译文件 &#125;, &#123; test: /\\.js$/, use: &quot;babel-loader&quot;, exclude: [path.join(__dirname, &quot;../node_modules&quot;)] //排除文件 &#125; ] &#125;, plugins: [ new HTMLPlugin(&#123; template: path.join(__dirname, &quot;../client/template.html&quot;) //dist生产的html以他为模板 &#125;) ]&#125;;if (isDev) &#123; // 客户端热更新需要的 config.entry = &#123; app: [&quot;react-hot-loader/patch&quot;, path.join(__dirname, &quot;../client/app.js&quot;)] &#125;; config.devServer = &#123; host: &quot;0.0.0.0&quot;, compress: true, port: &quot;3000&quot;, contentBase: path.join(__dirname, &quot;../dist&quot;), // 默认会以根文件夹提供本地服务器，这里指定文件夹 hot: true, overlay: &#123; errors: true &#125;, publicPath: &quot;/public/&quot;, historyApiFallback: &#123; index: &quot;/public/index.html&quot; &#125; &#125;; //热替换方法 来自webpack自带 config.plugins.push(new webpack.HotModuleReplacementPlugin());&#125;module.exports = config; package.json文件123456789&quot;scripts&quot;: &#123; &quot;build:client&quot;: &quot;webpack --config build/webpack.config.js&quot;, &quot;build:server&quot;: &quot;webpack --config build/webpack.server.js&quot;, &quot;clear&quot;: &quot;rimraf dist&quot;, &quot;build&quot;: &quot;npm run clear &amp;&amp; npm run build:client &amp;&amp; npm run build:server&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node server/server.js&quot;, &quot;dev:client&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js&quot;&#125;, .babelrc文件12345678&#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123; &quot;loose&quot;: true &#125;], &quot;react&quot; ], &quot;plugins&quot;: [&quot;react-hot-loader/babel&quot;] &#125; 要热更新的主文件12345678910111213141516171819202122232425import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./views/App.jsx&#x27;;import &#123;AppContainer&#125; from &#x27;react-hot-loader&#x27;;const root = document.getElementById(&#x27;root&#x27;)const render = (Component) =&gt;&#123; const renderMethod = module.hot? ReactDOM.render : ReactDOM.hydrate renderMethod( &lt;AppContainer&gt; &lt;Component/&gt; &lt;/AppContainer&gt;, root )&#125;render(App);if(module.hot)&#123; module.hot.accept(&#x27;./views/App.jsx&#x27;,()=&gt;&#123; const NextApp = require(&#x27;./views/App.jsx&#x27;).default; render(NextApp) &#125;)&#125;","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"这个叫Puppeteer的小爬虫，了解一下！","slug":"这个叫Puppeteer的小爬虫，了解一下！","date":"2018-04-30T16:00:00.000Z","updated":"2020-09-16T09:07:16.000Z","comments":true,"path":"2018/05/01/这个叫Puppeteer的小爬虫，了解一下！/","link":"","permalink":"http://mariogogogo.github.io/2018/05/01/%E8%BF%99%E4%B8%AA%E5%8F%ABPuppeteer%E7%9A%84%E5%B0%8F%E7%88%AC%E8%99%AB%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%81/","excerpt":"你讲会学到如何使用JavaScript自动化抓取网页里面感兴趣的内容。我们将会使用Puppeteer，Puppeteer是一个Node库，提供接口来控制headless Chrome。Headless Chrome是一种不使用Chrome来运行Chrome浏览器的方式。 如果你不知道Puppeteer，也不了解headless Chrome，那么你只要知道我们将要编写JavaScript代码来自动化控制Chrome就行。","text":"你讲会学到如何使用JavaScript自动化抓取网页里面感兴趣的内容。我们将会使用Puppeteer，Puppeteer是一个Node库，提供接口来控制headless Chrome。Headless Chrome是一种不使用Chrome来运行Chrome浏览器的方式。 如果你不知道Puppeteer，也不了解headless Chrome，那么你只要知道我们将要编写JavaScript代码来自动化控制Chrome就行。 安装12npm install –save puppeteer 举例1 截屏1234567891011121314const puppeteer = require(&#x27;puppeteer&#x27;);async function getPic() &#123; const browser = await puppeteer.launch(&#123;headless: false&#125;); const page = await browser.newPage(); await page.goto(&#x27;https://google.com&#x27;); await page.setViewport(&#123;width: 1000, height: 500&#125;) await page.screenshot(&#123;path: &#x27;google.png&#x27;&#125;); await browser.close();&#125;getPic(); 第1行：引入我们需要的库Puppeteer； 第3-10行：主函数getPic()包含了所有的自动化代码； 第12行：调用getPic()函数。 第4行：const broswer = await puppeteer.launch();这行代码启动puppeteer，我们实际上启动了一个Chrome实例，并且和我们声明的browser变量绑定起来。因为我们使用了await关键字，该函数会暂停直到Promise完全被解析。也就是说成功创建Chrome实例或则报错。 第5行：const page = await browser.newPage();我们在浏览器中创建一个新的页面，通过使用await关键字来等待页面成功创建。 第6行：await page.goto(‘https://google.com&#39;);使用page.goto()打开谷歌首页。 第7行：await page.screenshot({path: ‘google.png’});调用screenshot()函数将当前页面截屏。 第9行：await browser.close();将浏览器关闭。 举例2 百度关键字搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344// 演示自动访问百度网站并抓取相关搜索关键词const puppeteer = require(&#x27;puppeteer&#x27;);(async () =&gt; &#123; const browser = await puppeteer.launch( &#123;headless: false&#125;); const page = await browser.newPage(); await page.goto(&#x27;https://www.baidu.com/&#x27;); // 焦点到搜索关键字输入框 await page.focus(&#x27;#kw&#x27;); // 输入关键字 Chrome Headless await page.type(&#x27;#kw&#x27;, &#x27;Chrome Headless&#x27;, &#123;delay: 100&#125;); await page.click(&#x27;#su&#x27;); // 点击“百度一下”提交按钮 const waitForElement = page.waitForSelector(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; th:nth-child(5) &gt; a&#x27;, &#123;visible:true,timeout: 3000&#125;); // 等待 3 秒或者页面显示完成 注释1 try &#123;// 此处是可能产生例外的语句 await waitForElement; var kw = []; // 注释2 kw[0] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(1) &gt; th:nth-child(1) &gt; a&#x27;, el =&gt; el.innerHTML); //注释3 kw[1] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(1) &gt; th:nth-child(3) &gt; a&#x27;, el =&gt; el.innerHTML); kw[2] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(1) &gt; th:nth-child(5) &gt; a&#x27;, el =&gt; el.innerHTML); kw[3] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; th:nth-child(1) &gt; a&#x27;, el =&gt; el.innerHTML); kw[4] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; th:nth-child(3) &gt; a&#x27;, el =&gt; el.innerHTML); kw[5] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; th:nth-child(5) &gt; a&#x27;, el =&gt; el.innerHTML); kw[6] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; th:nth-child(1) &gt; a&#x27;, el =&gt; el.innerHTML); kw[7] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; th:nth-child(3) &gt; a&#x27;, el =&gt; el.innerHTML); kw[8] = await page.$eval(&#x27;#rs &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; th:nth-child(5) &gt; a&#x27;, el =&gt; el.innerHTML); console.log(&#x27;相关搜索关键词：&#x27;); //遍历相关搜索关键词. for(var i=0;i&lt;kw.length;i++)&#123; console.log(kw[i]); &#125; &#125; catch (error) &#123; // 此处是负责例外处理的语句 console.log(&#x27;网页中没有找到相关搜索&#x27;); &#125; finally &#123; // 此处是出口语句 &#125; browser.close(); // 关闭退出。可注释掉此行代码，便于观察最后的结果&#125;)(); 举例3 抓取数据 首先，了解一下Puppeteer的API。文档提供了非常丰富的方法不仅支持在网页上点击，而且可以填写表单，读取数据。 接下来我们会爬取Books to Scrape，这是一个伪造的网上书店专门用来练习爬取数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const puppeteer = require(&quot;puppeteer&quot;);const fs = require(&quot;fs&quot;);// 延时器const sleep = time =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, time); console.log(&quot;执行&quot; + time + &quot;秒&quot;); &#125;);/** * One 爬虫类 */class OnePaChong &#123; constructor() &#123; // 最大索引 this.maxIndex = 5; // 初始化 this.init(); &#125; // 初始化函数 async init() &#123; var arr = []; console.log(&quot;正在启动浏览器...&quot;); this.browser = await puppeteer.launch(&#123; args: [&quot;--no-sandbox&quot;], dumpio: false, headless: false &#125;); console.log(&quot;正在打开新页面...&quot;); this.page = await this.browser.newPage(); // 顺序爬取页面 await sleep(1000); for (let i = 1; i &lt; this.maxIndex; i++) &#123; await this.getPageInfo(i); &#125; this.closeBrowser(); &#125; // 抓取页面内容 async getPageInfo(actPage) &#123; // 延时 1000 毫秒 await sleep(1000); console.log(&quot;现在进入第&quot; + actPage + &quot;页面&quot;); let page = this.page; await page.goto(`http://books.toscrape.com/catalogue/page-$&#123;actPage&#125;.html`,&#123; waitUntil:&#x27;networkidle2&#x27; &#125;); // 获取信息 try &#123; // 获取文本 const result = await page.evaluate(() =&gt; &#123; let elements = document.querySelectorAll(&quot;.product_pod&quot;); // 获取所有书籍元素 let data = []; // 初始化空数组来存储数据 for (var element of elements) &#123; // 循环 let title = element.childNodes[5].innerText; // 获取标题 let price = element.childNodes[7].children[0].innerText; // 获取价格 data.push(&#123; title, price &#125;); // 存入数组 &#125; return data; &#125;); let arr = [...result] console.log(&#x27;-------------------------------------------- start&#x27;) console.log(&#x27;页面页码：&#x27;, actPage); console.log(&#x27;采集状态：&#x27;, &#x27;成功&#x27;); console.log(&#x27;采集数据：&#x27;, result); console.log(&#x27;采集数据：&#x27;, arr.length); console.log(&#x27;-------------------------------------------- end&#x27;) process.send(result) &#125; catch (error) &#123; console.log(&quot;-------------------------------------------- start&quot;); console.log(&quot;页面页码：&quot;, actPage); console.log(&quot;采集状态：&quot;, &quot;失败&quot;); console.log(&quot;错误信息：&quot;, error); console.log(&quot;-------------------------------------------- end&quot;); &#125; &#125; // 关闭浏览器 async closeBrowser() &#123; console.log(&quot;正在关闭浏览器...&quot;); process.exit(0) await this.browser.close(); &#125;&#125;// 启用爬虫new OnePaChong(); TODO1.类似分页抓取数据如何实现全部数据都抓取到（现在只能实现一个页面的抓取）然后传给数据库保存","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"},{"name":"测试","slug":"测试","permalink":"http://mariogogogo.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Git 个人常用命令","slug":"Git个人常用命令","date":"2018-04-25T16:00:00.000Z","updated":"2020-12-08T01:41:35.000Z","comments":true,"path":"2018/04/26/Git个人常用命令/","link":"","permalink":"http://mariogogogo.github.io/2018/04/26/Git%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"刚进入新公司，被告知团队是用 Git 管理项目代码的，而你却从来没用过 Git。纵然同事告诉你「没事，先自学一下」「有问题可以问我」，但你肯定不想一进公司就花太多时间在自我学习上，也不想过多地打扰这些刚认识的同事。怎么办？ 对你来说，最重要的是，先知道 Git 怎么用。先把最基本的掌握了，至于正规团队使用 Git 有什么额外要求、Git 有什么高级用法、Git 的原理这些，都可以放在这之后。万事开头难，你先把 Git 最基本的使用掌握了，后面的再一步一步来。…","text":"刚进入新公司，被告知团队是用 Git 管理项目代码的，而你却从来没用过 Git。纵然同事告诉你「没事，先自学一下」「有问题可以问我」，但你肯定不想一进公司就花太多时间在自我学习上，也不想过多地打扰这些刚认识的同事。怎么办？ 对你来说，最重要的是，先知道 Git 怎么用。先把最基本的掌握了，至于正规团队使用 Git 有什么额外要求、Git 有什么高级用法、Git 的原理这些，都可以放在这之后。万事开头难，你先把 Git 最基本的使用掌握了，后面的再一步一步来。… 把远程仓库取到本地1git clone 你刚复制的地址 它会列出你的提交历史1git log status 是用来查看工作目录当前状态的指令1git status 你在 master branch 当前 branch 没有落后于 origin/master 你有 untracked files （未追踪的文件），文件名是 shopping list.txt。 你可以使用 git add 来开始追踪文件。… 你通过 add 指令暂存的内容，都会被写进这个文件里1git add . 提交的方式是用 commit 指令1git commit 提交一次或多次之后，把本地提交 push 到中央仓库（git push）1git push 你想创建一个叫做 “feature1” 的 branch 分支12git branch feature1git checkout -b feature1 切换 branch1git checkout feature1 删除 branch1git branch -d feature1 合并分支1git merge feature1 思维导图分享 常用 Git 命令总结 git config –global user.name “你的名字” 让你全部的 Git 仓库绑定你的名字 git config –global user.email “你的邮箱” 让你全部的 Git 仓库绑定你的邮箱 git init 初始化你的仓库 git add . 把工作区的文件全部提交到暂存区 git add .// 把工作区的 &lt; file &gt; 文件提交到暂存区 git commit -m “xxx” 把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来 git push -u origin master 把仓库区的主分支 master 提交到远程仓库里 git push -u origin &lt;其他分支&gt; 把其他分支提交到远程仓库 git status 查看当前仓库的状态 git diff 查看文件修改的具体内容 git log 显示从最近到最远的提交历史 git clone + 仓库地址下载克隆文件 git reset –hard + 版本号 回溯版本，版本号在 commit 的时候与 master 跟随在一起 git reflog 显示命令历史 git checkout – 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是 Git 世界的 ctrl + z git rm 删除版本库的文件 git branch 查看当前所有分支 git branch &lt;分支名字&gt; 创建分支 git checkout &lt;分支名字&gt; 切换到分支 git merge &lt;分支名字&gt; 合并分支 git branch -d &lt;分支名字&gt; 删除分支, 有可能会删除失败，因为 Git 会保护没有被合并的分支 git branch -D + &lt;分支名字&gt; 强行删除，丢弃没被合并的分支 git log –graph 查看分支合并图 git merge –no-ff &lt;分支名字&gt; 合并分支的时候禁用 Fast forward 模式, 因为这个模式会丢失分支历史信息 git stash 当有其他任务插进来时，把当前工作现场 “存储” 起来, 以后恢复后继续工作 git stash list 查看你刚刚 “存放” 起来的工作去哪里了 git stash apply 恢复却不删除 stash 内容 git stash drop 删除 stash 内容 git stash pop 恢复的同时把 stash 内容也删了 git remote 查看远程库的信息，会显示 origin，远程仓库默认名称为 origin git remote -v 显示更详细的信息 git pull 把最新的提交从远程仓库中抓取下来，在本地合并, 和 git push 相反 git rebase 把分叉的提交历史 “整理” 成一条直线，看上去更直观 git tag 查看所有标签，可以知道历史版本的 tag git tag 打标签，默认为 HEAD。比如 git tag v1.0 git tag &lt; 版本号 &gt; 把版本号打上标签，版本号就是 commit 时，跟在旁边的一串字母数字 git show 查看标签信息 git tag -a -m “&lt; 说明 &gt;” 创建带说明的标签。-a 指定标签名，-m 指定说明文字 git tag -d 删除标签 git push origin 推送某个标签到远程 git push origin –tags 一次性推送全部尚未推送到远程的本地标签 git push origin :refs/tags/ 删除远程标签 &lt; tagname&gt; git config –global color.ui true 让 Git 显示颜色，会让命令输出看起来更醒目 git add -f 强制提交已忽略的的文件 git check-ignore -v 检查为什么 Git 会忽略该文件","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://mariogogogo.github.io/tags/Git/"},{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"仿美团App（个人中心组件）","slug":"仿美团App（个人中心组件）","date":"2018-04-25T16:00:00.000Z","updated":"2020-09-16T09:07:03.000Z","comments":true,"path":"2018/04/26/仿美团App（个人中心组件）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/26/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E4%B8%AA%E4%BA%BA%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%89/","excerpt":"写一个个人中心组件","text":"写一个个人中心组件 效果图 虚拟数据123456789101112131415161718192021222324getDataList = () =&gt; &#123; return ( [ [ &#123;title: &#x27;我的钱包&#x27;, subtitle: &#x27;办信用卡&#x27;, image: require(&#x27;../../img/mine/icon_mine_wallet.png&#x27;)&#125;, &#123;title: &#x27;余额&#x27;, subtitle: &#x27;￥95872385&#x27;, image: require(&#x27;../../img/mine/icon_mine_balance.png&#x27;)&#125;, &#123;title: &#x27;抵用券&#x27;, subtitle: &#x27;63&#x27;, image: require(&#x27;../../img/mine/icon_mine_voucher.png&#x27;)&#125;, &#123;title: &#x27;会员卡&#x27;, subtitle: &#x27;2&#x27;, image: require(&#x27;../../img/mine/icon_mine_membercard.png&#x27;)&#125; ], [ &#123;title: &#x27;好友去哪&#x27;, image: require(&#x27;../../img/mine/icon_mine_friends.png&#x27;)&#125;, &#123;title: &#x27;我的评价&#x27;, image: require(&#x27;../../img/mine/icon_mine_comment.png&#x27;)&#125;, &#123;title: &#x27;我的收藏&#x27;, image: require(&#x27;../../img/mine/icon_mine_collection.png&#x27;)&#125;, &#123;title: &#x27;会员中心&#x27;, subtitle: &#x27;v15&#x27;, image: require(&#x27;../../img/mine/icon_mine_membercenter.png&#x27;)&#125;, &#123;title: &#x27;积分商城&#x27;, subtitle: &#x27;好礼已上线&#x27;, image: require(&#x27;../../img/mine/icon_mine_member.png&#x27;)&#125; ], [ &#123;title: &#x27;客服中心&#x27;, image: require(&#x27;../../img/mine/icon_mine_customerService.png&#x27;)&#125;, &#123;title: &#x27;关于美团&#x27;, subtitle: &#x27;我要合作&#x27;, image: require(&#x27;../../img/mine/icon_mine_aboutmeituan.png&#x27;)&#125; ] ] ) &#125; 12345678910111213141516171819renderHeader = () =&gt; &#123; return ( &lt;View style=&#123;styles.header&#125;&gt; &lt;Image style=&#123;styles.avatar&#125; source=&#123;require(&#x27;../../img/mine/avatar.png&#x27;)&#125; /&gt; &lt;View&gt; &lt;View style=&#123;&#123;flexDirection: &#x27;row&#x27;, alignItems: &#x27;center&#x27;&#125;&#125;&gt; &lt;Heading2 style=&#123;&#123;color: &#x27;white&#x27;&#125;&#125;&gt;大保健&lt;/Heading2&gt; &lt;Image source=&#123;require(&#x27;../../img/mine/beauty_technician_v15.png&#x27;)&#125; /&gt; &lt;/View&gt; &lt;Paragraph style=&#123;&#123;color: &#x27;white&#x27;, marginTop: 10&#125;&#125;&gt;个人信息 &gt;&lt;/Paragraph&gt; &lt;/View&gt; &lt;/View&gt; ) &#125; index.js 123456789101112131415161718192021render() &#123; return ( &lt;View style=&#123;&#123;flex: 1, backgroundColor: color.paper&#125;&#125;&gt; &lt;View style=&#123;styles.headerBackground&#125; /&gt; &lt;ScrollView refreshControl=&#123; &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this.onHeaderRefresh&#125; tintColor=&#x27;gray&#x27; /&gt; &#125; &gt; &#123;this.renderHeader()&#125; &lt;SpacingView /&gt; &#123;this.renderCells()&#125; &lt;/ScrollView&gt; &lt;/View&gt; )&#125; renderCells方法 2个for循环 分解成三块内容显示 每一快的组件DetailCell1234567891011121314151617181920212223242526272829renderCells = () =&gt; &#123; let cells = [] let dataList = this.getDataList() for (let i = 0; i &lt; dataList.length; i++) &#123; let sublist = dataList[i] for (let j = 0; j &lt; sublist.length; j++) &#123; let data = sublist[j] let cell = ( &lt;DetailCell key=&#123;data.title&#125; title=&#123;data.title&#125; subtitle=&#123;data.subtitle&#125; image=&#123;data.image&#125; /&gt; ) cells.push(cell) &#125; cells.push( &lt;SpacingView key=&#123;i&#125; /&gt; ) &#125; return ( &lt;View&gt; &#123;cells&#125; &lt;/View&gt; ) &#125; DetailCell.js1234567891011121314151617181920212223class DetailCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125;; &#125; render() &#123; let &#123;image,title,subtitle,style&#125; = this.props; let iconElement = this.props.image &amp;&amp; ( &lt;Image style=&#123;styles.icon&#125; source=&#123;image&#125;/&gt; ) return ( &lt;TouchableOpacity &gt; &lt;View style=&#123;[styles.container,style]&#125;&gt; &#123;iconElement&#125; &lt;Heading3&gt;&#123;title&#125;&lt;/Heading3&gt; &lt;View style=&#123;&#123;flex:1&#125;&#125;/&gt; &lt;Paragraph style=&#123;&#123;color:&#x27;#999&#x27;&#125;&#125;&gt;&#123;subtitle&#125;&lt;/Paragraph&gt; &lt;Image style=&#123;styles.arrow&#125; source=&#123;require(&#x27;../img/public/cell_arrow.png&#x27;)&#125; /&gt; &lt;/View&gt; &lt;Separator/&gt; &lt;/TouchableOpacity&gt; )&#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"仿美团App（猜你喜欢部分组件）","slug":"仿美团App（猜你喜欢部分组件）","date":"2018-04-24T16:00:00.000Z","updated":"2020-09-16T09:07:03.000Z","comments":true,"path":"2018/04/25/仿美团App（猜你喜欢部分组件）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/25/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E7%8C%9C%E4%BD%A0%E5%96%9C%E6%AC%A2%E9%83%A8%E5%88%86%E7%BB%84%E4%BB%B6%EF%BC%89/","excerpt":"写一个猜你喜欢组件","text":"写一个猜你喜欢组件 效果图 index.js12345678910111213//点击详情跳转 onCellSelected(info) &#123; this.props.navigation.navigate(&quot;GroupPurchaseScene&quot;, &#123; info: info &#125;); &#125; renderItem = rowData =&gt; &#123; return ( &lt;GroupPurchaseCell onPress=&#123;this.onCellSelected.bind(this)&#125; info=&#123;rowData.item&#125; /&gt; ); &#125;; GroupPurchaseCell.js1234567891011121314151617181920212223242526272829class GroupPurchaseCell extends Component &#123; render() &#123; let &#123; info, onPress, waiting &#125; = this.props; let imageUrl = info.imageUrl.replace(&quot;w.h&quot;, &quot;160.0&quot;); return ( &lt;TouchableOpacity style=&#123;styles.container&#125; onPress=&#123;() =&gt; &#123; NoDoublePress.onPress(() =&gt; &#123; onPress(info); &#125;); &#125;&#125; &gt; &lt;Image style=&#123;styles.icon&#125; source=&#123;&#123; uri: imageUrl &#125;&#125; /&gt; &lt;View style=&#123;styles.rightContainer&#125;&gt; &lt;Heading2&gt;&#123;info.title&#125;&lt;/Heading2&gt; &lt;Paragraph numberOfLines=&#123;0&#125; style=&#123;&#123; marginTop: 8 &#125;&#125;&gt; &#123;info.subtitle&#125; &lt;/Paragraph&gt; &lt;View style=&#123;&#123; flex: 1, justifyContent: &quot;flex-end&quot; &#125;&#125;&gt; &lt;Heading2 style=&#123;styles.price&#125;&gt;&#123;info.price&#125;元&lt;/Heading2&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125;&#125; 详情页面效果图 GroupPurchaseScene.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class GroupPurchaseScene extends Component &#123; static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123; headerTitle: &quot;团购详情&quot;, headerRight: ( &lt;NavigationItem icon=&#123;require(&quot;../../img/public/icon_navigationItem_share.png&quot;)&#125; onPress=&#123;() =&gt; &#123; alert(&quot;share&quot;); &#125;&#125; /&gt; ), headerStyle:&#123; borderBottomWidth: 0, //取消底部阴影 elevation: 0, &#125; &#125;); constructor(props) &#123; super(props); &#125; render() &#123; let &#123; info &#125; = this.props.navigation.state.params; let imageUrl = info.imageUrl.replace(&quot;w.h&quot;, &quot;480.0&quot;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View&gt; &lt;Image source=&#123;&#123; uri: imageUrl &#125;&#125; style=&#123;styles.banner&#125; /&gt; &lt;View style=&#123;styles.topContainer&#125;&gt; &lt;Heading2 style=&#123;&#123; color: color.primary &#125;&#125;&gt;￥&lt;/Heading2&gt; &lt;Heading1 style=&#123;&#123; marginBottom: -8 &#125;&#125;&gt;&#123;info.price&#125;&lt;/Heading1&gt; &lt;Paragraph style=&#123;&#123; marginLeft: 10 &#125;&#125;&gt; 门市价：￥&#123;(info.price * 1.1).toFixed(0)&#125; &lt;/Paragraph&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125; /&gt; &lt;Button title=&#x27;立即抢购&#x27; titleStyle=&#123;&#123;color: &#x27;white&#x27;, fontSize: 18&#125;&#125; style=&#123;styles.buyButton&#125; /&gt; &lt;/View&gt; &lt;/View&gt; &lt;Separator /&gt; &lt;View style=&#123;styles.tagContainer&#125;&gt; &lt;Image style=&#123;&#123; width: 20, height: 20 &#125;&#125; source=&#123;require(&quot;../../img/home/icon_deal_anytime_refund.png&quot;)&#125; /&gt; &lt;Paragraph style=&#123;&#123; color: &quot;#89B24F&quot; &#125;&#125;&gt; 随时退&lt;/Paragraph&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125; /&gt; &lt;Paragraph&gt;已售123&lt;/Paragraph&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"仿美团App（团购部分组件）","slug":"仿美团App（团购部分组件）","date":"2018-04-23T16:00:00.000Z","updated":"2020-09-16T09:07:04.000Z","comments":true,"path":"2018/04/24/仿美团App（团购部分组件）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/24/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E5%9B%A2%E8%B4%AD%E9%83%A8%E5%88%86%E7%BB%84%E4%BB%B6%EF%BC%89/","excerpt":"写一个中间团购部分组件","text":"写一个中间团购部分组件 index.js12345678910111213141516171819202122232425262728293031323334353637//请求componentDidMount() &#123;this.requestData();&#125; requestData = async () =&gt; &#123;this.requestRecommend();//团购加载this.requestDiscount();&#125;; //团购加载requestDiscount = async () =&gt; &#123;try &#123; let response = await fetch(api.discount); let json = await response.json(); console.log(&quot;json&quot; + JSON.stringify(json)); this.setState(&#123; discounts: json.data &#125;);&#125; catch (error) &#123; alert(&quot;error &quot; + error);&#125;&#125;; onGridSelected = index =&gt; &#123;console.log(&quot;进来了&quot;);let url = &quot;http://www.baidu.com&quot;;this.props.navigation.navigate(&quot;WebScreen&quot;, &#123; url: url &#125;);&#125;;&lt;SpacingView /&gt; &lt;HomeGridView infos=&#123;this.state.discounts&#125; onGridSelected=&#123;this.onGridSelected&#125; /&gt;&lt;SpacingView /&gt; HomeGridVie.js12345678910111213141516171819class HomeGridView extends Component &#123; render() &#123; let &#123;infos, onGridSelected&#125; = this.props return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;infos.map((info, index) =&gt; ( &lt;HomeGridItem key=&#123;index&#125; info=&#123;info&#125; onPress=&#123;() =&gt; &#123; onGridSelected(index) &#125;&#125; /&gt; ))&#125; &lt;/View&gt; ) &#125;&#125; HomeGridItem.js123456789101112131415161718192021222324252627282930class HomeGridItem extends Component&#123; render() &#123; let &#123;info, onPress&#125; = this.props let title = info.title; let subtitle = info.subtitle; let imageUrl = info.image let color = &#x27;red&#x27; // let title = info.maintitle // let color = info.typeface_color // let subtitle = info.deputytitle // let imageUrl = info.imageurl.replace(&#x27;w.h&#x27;, &#x27;120.0&#x27;) return ( &lt;TouchableOpacity style=&#123;styles.container&#125; onPress=&#123;onPress&#125;&gt; &lt;View&gt; &lt;Heading2 style=&#123;&#123;color: color, marginBottom: 10&#125;&#125;&gt;&#123;title&#125;&lt;/Heading2&gt; &lt;Heading3&gt;&#123;subtitle&#125;&lt;/Heading3&gt; &lt;/View&gt; &lt;Image style=&#123;styles.icon&#125; source=&#123;&#123;uri: imageUrl&#125;&#125; /&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"仿美团App（头部导航）","slug":"仿美团App（头部导航）","date":"2018-04-21T16:00:00.000Z","updated":"2020-09-16T09:07:04.000Z","comments":true,"path":"2018/04/22/仿美团App（头部导航）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/22/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E5%A4%B4%E9%83%A8%E5%AF%BC%E8%88%AA%EF%BC%89/","excerpt":"首先App开始写一个头部导航按钮","text":"首先App开始写一个头部导航按钮 效果图如下 注意安卓环境下默认状态栏是要单独设置的 1&lt;StatusBar backgroundColor=&#123;color.primary&#125; barStyle=&quot;light-content&quot; /&gt; 12345678910111213141516171819202122static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123; headerTitle: ( &lt;TouchableOpacity style=&#123;styles.searchBar&#125;&gt; &lt;Image source=&#123;require(&quot;../../img/home/search_icon.png&quot;)&#125; style=&#123;styles.searchIcon&#125; /&gt; &lt;Text&gt;搜索&lt;/Text&gt; &lt;/TouchableOpacity&gt; ), headerLeft: &lt;NavigationItem title=&quot;定位&quot; titleStyle=&#123;&#123; color: &quot;white&quot; &#125;&#125; /&gt;, headerRight: ( &lt;NavigationItem icon=&#123;require(&quot;../../img/mine/icon_navigationItem_message_white.png&quot;)&#125; onPress=&#123;() =&gt; &#123; navigation.navigate(&quot;WebScene&quot;); &#125;&#125; /&gt; ), headerStyle: &#123; backgroundColor: color.primary &#125; &#125;); NavigationItem.js组件1234567891011121314151617181920class NavigationItem extends Component &#123; render() &#123; let titleElement = this.props.title &amp;&amp; ( &lt;Text style=&#123;[styles.title, this.props.titleStyle]&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; ) let iconElement = this.props.icon &amp;&amp; ( &lt;Image style=&#123;[styles.icon, this.props.iconStyle]&#125; source=&#123;this.props.icon&#125; /&gt; ) return ( &lt;TouchableOpacity onPress=&#123;this.props.onPress&#125;&gt; &#123;iconElement&#125; &#123;titleElement&#125; &lt;/TouchableOpacity&gt; ) &#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"仿美团App（底部导航）","slug":"仿美团App（底部导航）","date":"2018-04-20T16:00:00.000Z","updated":"2020-09-16T09:07:03.000Z","comments":true,"path":"2018/04/21/仿美团App（底部导航）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/21/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%EF%BC%89/","excerpt":"首先App开始写一个底部导航按钮","text":"首先App开始写一个底部导航按钮 效果图如下 注意点：安卓默认位置TopiOS默认位置是 bottom组件化思想封装的重要性 react-navigation 标题在安卓上不居中问题12345678headerTitleStyle:&#123; flex: 1, textAlign: &#x27;center&#x27;, &#125;, headerTintColor:&#x27;#000&#x27;, headerBackTitle:null, &#125; react-navigation 导航去掉下面边框，阴影12345678static navigationOptions = &#123; headerStyle:&#123; borderBottomWidth: 0, elevation: 0, &#125; &#125; react-native 防止重复点击12345678910111213var NoDoublePress = &#123; lastPressTime: 1, onPress(callback)&#123; let curTime = new Date().getTime(); if (curTime - this.lastPressTime &gt; 1000) &#123; this.lastPressTime = curTime; callback(); &#125; &#125;,&#125;;module.exports = NoDoublePress; 使用 1234567891011&lt;MyButton onPress=&#123;() =&gt; &#123; NoDoublePress.onPress(() =&gt; &#123; this.onPressLogin(); &#125;); &#125;&#125;&gt; &lt;Text&gt; 登 录 &lt;/Text&gt;&lt;/MyButton&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class RootScene extends Component&#123; render() &#123; return ( &lt;Navigation/&gt; ) &#125;&#125;const Tab = TabNavigator(&#123; Home: &#123; screen: HomeScene, navigationOptions: () =&gt; (&#123; tabBarLabel: &#x27;团购&#x27;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&#x27;./img/tabbar/tabbar_homepage.png&#x27;)&#125; selectedImage=&#123;require(&#x27;./img/tabbar/tabbar_homepage_selected.png&#x27;)&#125; /&gt; ) &#125;) &#125;, Nearby: &#123; screen: NearbyScene, navigationOptions: () =&gt; (&#123; tabBarLabel: &#x27;附近&#x27;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&#x27;./img/tabbar/tabbar_merchant.png&#x27;)&#125; selectedImage=&#123;require(&#x27;./img/tabbar/tabbar_merchant_selected.png&#x27;)&#125; /&gt; ) &#125;) &#125;, Order: &#123; screen: OrderScene, navigationOptions: () =&gt; (&#123; tabBarLabel: &#x27;订单&#x27;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&#x27;./img/tabbar/tabbar_order.png&#x27;)&#125; selectedImage=&#123;require(&#x27;./img/tabbar/tabbar_order_selected.png&#x27;)&#125; /&gt; ) &#125;) &#125;, Mine: &#123; screen: MineScene, navigationOptions: () =&gt; (&#123; tabBarLabel: &#x27;我的&#x27;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&#x27;./img/tabbar/tabbar_mine.png&#x27;)&#125; selectedImage=&#123;require(&#x27;./img/tabbar/tabbar_mine_selected.png&#x27;)&#125; /&gt; ) &#125;) &#125;&#125;, &#123; //第二个参数代表 tabBarComponent: TabBarBottom, //tab要用的组件 tabBarPosition: &#x27;bottom&#x27;, //tab位置选择 lazy: true, // true代表只加载当前 animationEnabled:false, //是否有动画 swipeEnabled:false, //切换动画 tabBarOptions: &#123; activeTintColor:color.primary, //激活图标颜色 inactiveTintColor:color.gray, //非激活状态颜色 style: &#123;backgroundColor: &#x27;white&#x27;&#125; &#125; &#125;)const Navigation = StackNavigator(&#123; Tab:&#123;screen:Tab&#125;, WebScreen:&#123; screen:WebScreen &#125;, GroupPurchaseScene:&#123; screen:GroupPurchaseScene &#125; &#125;,&#123; navigationOptions:&#123; headerTintColor:&#x27;red&#x27;, &#125;&#125;)export default RootScene TabBarItem.js12345678910111213class TabBarItem extends Component &#123; render() &#123; let &#123;focused, selectedImage, normalImage, tintColor&#125; = this.props return ( &lt;Image source=&#123;focused ? selectedImage : normalImage&#125; style=&#123;&#123;tintColor: tintColor, width: 25, height: 25&#125;&#125; /&gt; ) &#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"仿美团App（轮播导航组件）","slug":"仿美团App（轮播导航组件）","date":"2018-04-20T16:00:00.000Z","updated":"2020-09-16T09:07:03.000Z","comments":true,"path":"2018/04/21/仿美团App（轮播导航组件）/","link":"","permalink":"http://mariogogogo.github.io/2018/04/21/%E4%BB%BF%E7%BE%8E%E5%9B%A2App%EF%BC%88%E8%BD%AE%E6%92%AD%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6%EF%BC%89/","excerpt":"写一个头部轮播菜单导航组件","text":"写一个头部轮播菜单导航组件 效果图 注意循环事件的获取点击事件的获取 index.js123456&lt;HomeMenuView menuInfos=&#123;api.menuInfos&#125; onMenuSelected=&#123;index =&gt; &#123; alert(&quot;test &quot; + index); &#125;&#125; /&gt; 小圆点组件import PageControl from ‘react-native-page-control’ HomeMenuView.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 class HomeMenuView extends Component&#123; constructor(props) &#123; super(props) this.state = &#123; currentPage: 0, &#125; &#125; //手势移动计算偏移量 onScroll = (e) =&gt; &#123; let x = e.nativeEvent.contentOffset.x console.log(&#x27;x &#x27;+x) let currentPage = Math.round(x / screen.width) console.log(currentPage) if (this.state.currentPage != currentPage) &#123; this.setState(&#123;currentPage: currentPage&#125;) &#125; &#125; render() &#123; let &#123;menuInfos, onMenuSelected&#125; = this.props //根据请求过来的图片数量分页 let pageCount = Math.ceil(menuInfos.length / 10) //图标组件 let menuElements = menuInfos.map((info, index) =&gt; ( &lt;HomeMenuItem key=&#123;index&#125; title=&#123;info.title&#125; icon=&#123;info.icon&#125; onPress=&#123;() =&gt; &#123; onMenuSelected &amp;&amp; onMenuSelected(index) &#125;&#125; /&gt; )) let menuViews = [] //每一页都有图标 循环得到 for (let i = 0; i &lt; pageCount; i++) &#123; let elementsPerPage = menuElements.slice(i * 10, i * 10 + 10) let menuView = ( &lt;View key=&#123;i&#125; style=&#123;styles.itemsView&#125;&gt; &#123;elementsPerPage&#125; &lt;/View&gt; ) menuViews.push(menuView) &#125; console.log(menuViews) return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView horizontal pagingEnabled showsHorizontalScrollIndicator=&#123;false&#125; onScroll=&#123;this.onScroll&#125; &gt; &lt;View style=&#123;styles.menuContainer&#125;&gt; &#123;menuViews&#125; &lt;/View&gt; &lt;/ScrollView&gt; //小圆点组件 &lt;PageControl style=&#123;styles.pageControl&#125; numberOfPages=&#123;pageCount&#125; currentPage=&#123;this.state.currentPage&#125; pageIndicatorTintColor=&#x27;gray&#x27; currentPageIndicatorTintColor=&#123;color.primary&#125; /&gt; &lt;/View&gt; ) &#125;&#125; HomeMenuItem.js12345678910111213class HomeMenuItem extends PureComponent&lt;Props, State&gt; &#123; render() &#123; let &#123;title, icon, onPress&#125; = this.props return ( &lt;TouchableOpacity onPress=&#123;onPress&#125; style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;icon&#125; style=&#123;styles.icon&#125; /&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"几分钟带你入门-ES7异步神器async-await","slug":"几分钟带你入门-ES7异步神器async-awaitasync","date":"2018-04-11T16:00:00.000Z","updated":"2020-09-16T09:07:05.000Z","comments":true,"path":"2018/04/12/几分钟带你入门-ES7异步神器async-awaitasync/","link":"","permalink":"http://mariogogogo.github.io/2018/04/12/%E5%87%A0%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-ES7%E5%BC%82%E6%AD%A5%E7%A5%9E%E5%99%A8async-awaitasync/","excerpt":"关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。————-哎姓克哎喂特","text":"关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。————-哎姓克哎喂特 async-await和Promise的关系最近更新2019-06-21经常会看到有了 async-await、promise 还有必要学习吗、async await优于promise的几个特点，接收了这些信息后，就蒙圈了。现在才知道，async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。 基本语法 1234567async function basicDemo() &#123; let result = await Math.random(); console.log(result); &#125; basicDemo(); 123456789101112131415161718192021222324var sleep = function(time) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(resolve); console.log(reject); reject(&quot;这里返回错误&quot;); // resolve(&#x27;这里返回正确&#x27;) &#125;, time); &#125;);&#125;;var start = async function() &#123; try &#123; // 在这里使用起来就像同步代码那样直观 console.log(&quot;start&quot;); let res = await sleep(3000); console.log(&quot;end&quot;); console.log(&#x27;ok &#x27;+res); &#125; catch (error) &#123; console.log(&#x27;错误返回 &#x27;+error); &#125;&#125;;start(); 举例说明啊， 你有三个请求需要发生， 第三个请求是依赖于第二个请求的解构第二个请求依赖于第一个请求的结果。 若用 ES5实现会有3层的回调，若用Promise 实现至少需要3个then。 一个是代码横向发展，另一个是纵向发展。今天指给出 async-await 的实现哈~ 123456789101112131415function sleep(second, param) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(param); &#125;, second); &#125;);&#125;async function test() &#123; let result1 = await sleep(2000, &quot;req01&quot;); let result2 = await sleep(1000, &quot;req02&quot; + result1); let result3 = await sleep(500, &quot;req03&quot; + result2); console.log(` $&#123;result3&#125; $&#123;result2&#125; $&#123;result1&#125; `);&#125;test(); // req03req02req01 req02req01 req01 小心你的并行处理!!!我这里为啥加了三个感叹号呢~，因为对于初学者来说一不小心就将 ajax 的并发请求发成了阻塞式同步的操作了，我就真真切切的在工作中写了这样的代码。await 若等待的是 promise 就会停止下来。业务是这样的，我有三个异步请求需要发送，相互没有关联，只是需要当请求都结束后将界面的 loading 清除掉即可。刚学完 async await 开心啊，到处乱用~ // 总结 promise.all 的特点// 1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象， // 2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象 // 3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调 // 4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调// all() 的返回值也是新的 Promise 对象 12345678async function correctDemo() &#123; let p1 = sleep(1000); let p2 = sleep(1000); let p3 = sleep(1000); await Promise.all([p1, p2, p3]); console.log(&quot;clear the loading~&quot;);&#125;correctDemo(); // clear the loading~ await in for 循环==await必须在async函数的上下文中的== 1234567async function forDemo() &#123; let arr = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; arr.length; i++) &#123; await arr[i]; &#125;&#125;forDemo() 2018-06-01更新引入bluebrid 串行12345678910111213141516171819202122232425262728293031323334353637383940async function getApi1() &#123; await bluebird.delay(1000) const url = &#x27;http://rap2api.taobao.org/app/mock/17194//list1&#x27;; const response = await fetch(url,&#123;&#x27;id&#x27;:1111&#125;); if(response.status !== 200) &#123; throw new Error(response.statusText); &#125; return await response.json()&#125;async function getApi2()&#123; console.log(&#x27;等待1秒哦&#x27;) await bluebird.delay(1000) const url = &#x27;http://rap2api.taobao.org/app/mock/17194/list2&#x27;; const response = await fetch(url,&#123;&#x27;token&#x27;:111&#125;); if(response.status !== 200)&#123; throw new Error(response.statusText); &#125; return await response.json()&#125;const showGetInfo = async ()=&gt;&#123; try &#123; console.time(&#x27;时间&#x27;); const names = [&#x27;getApi1&#x27;,&#x27;getApi2&#x27;,&#x27;getApi3&#x27;,&#x27;getApi4&#x27;]; for (const name in names) &#123; if (names.hasOwnProperty(name)) &#123; const res = await getApi1(name) console.log(&#x27;bool1&#x27;,res.success); console.log(&#x27;bool2&#x27;,res.results); &#125; &#125; console.timeEnd(&#x27;时间&#x27;); &#125; catch (error) &#123; console.timeEnd(&#x27;时间&#x27;); console.error(&#x27;错误error:&#x27;+error); &#125;&#125;showGetInfo(); 2018-06-01更新 引入bluebrid 并行12345678910111213141516171819202122232425262728293031323334353637383940414243const fetch = require(&quot;node-fetch&quot;);const bluebird = require(&quot;bluebird&quot;);async function getApi1(name) &#123; await bluebird.delay(2000); const url = &quot;https://easy-mock.com/mock/5d09c91f44339368a2ce4c22/myapi/name&quot;; const response = await fetch(url, &#123; method: &quot;POST&quot;, //post请求 headers: &#123; Accept: &quot;application/json&quot;, &quot;Content-Type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; //post请求参数 name: name &#125;) &#125;); if (response.status !== 200) &#123; throw new Error(response.statusText); &#125; return await response.json();&#125;const showGetInfo = async () =&gt; &#123; try &#123; console.time(&quot;时间&quot;); //参数设置成数组 const names = [&quot;jordan&quot;, &quot;james&quot;,&quot;kobe&quot;]; &lt;!--先触发所有的请求，组成一个数组--&gt; const promisesArr = names.map(x =&gt; getApi1(x)); &lt;!--然后遍历这个数组，等待结果出来--&gt; for (const promise of promisesArr) &#123; const res = await promise; console.log(&quot;bool1&quot;, res.success, res.data.name); &#125; console.timeEnd(&quot;时间&quot;); &#125; catch (error) &#123; console.timeEnd(&quot;时间&quot;); console.error(&quot;错误error:&quot; + error); &#125;&#125;;showGetInfo(); 2018-06-01补充async await的错误处理，知识点的补充 1234567891011121314151617181920212223const fetch = require(&#x27;node-fetch&#x27;)async function getApi() &#123; const url = &#x27;http://rap2api.taobao.org/app/mock/7551//changeroom&#x27;; const response = await fetch(url,&#123;&#x27;id&#x27;:1111&#125;); if(response.status !== 200) &#123; throw new Error(response.statusText); &#125; return await response.json()&#125;const showGetInfo = async ()=&gt;&#123; try &#123; const res = await getApi(); console.log(&#x27;bool&#x27;,res.success); console.log(&#x27;results&#x27;,res.results.length); &#125; catch (error) &#123; console.error(&#x27;错误error:&#x27;+error); &#125;&#125;showGetInfo(); 处理await的串行1234567891011121314151617181920212223242526272829303132333435//串行async function getApi1() &#123; const url = &#x27;http://rap2api.taobao.org/app/mock/17194//list1&#x27;; const response = await fetch(url,&#123;&#x27;id&#x27;:1111&#125;); if(response.status !== 200) &#123; throw new Error(response.statusText); &#125; return await response.json()&#125;async function getApi2()&#123; const url = &#x27;http://rap2api.taobao.org/app/mock/17194/list2&#x27;; const response = await fetch(url,&#123;&#x27;token&#x27;:111&#125;); if(response.status !== 200)&#123; throw new Error(response.statusText); &#125; console.log(&#x27;====================================&#x27;); console.log(response.json); console.log(&#x27;====================================&#x27;); return await response.json()&#125;const showGetInfo = async ()=&gt;&#123; try &#123; const res1 = await getApi1(); const res2 = await getApi2(); console.log(&#x27;bool1&#x27;,res1.success,&#x27;bool2&#x27;,res2.success); console.log(&#x27;results1&#x27;,res1.results.length,&#x27;results2&#x27;,res2.results); &#125; catch (error) &#123; console.error(&#x27;错误error:&#x27;+error); &#125;&#125;showGetInfo(); 处理await的并行123456789101112131415161718192021222324252627282930313233343536373839404142434445//增加一个超时const sleep = (timeout=2000) =&gt; new Promise(resolve =&gt;&#123; setTimeout(resolve,timeout);&#125;) async function getApi1() &#123; await sleep(); const url = &#x27;http://rap2api.taobao.org/app/mock/17194//list1&#x27;; const response = await fetch(url,&#123;&#x27;id&#x27;:1111&#125;); if(response.status !== 200) &#123; throw new Error(response.statusText); &#125; console.log(new Date().getTime()) return await response.json()&#125;async function getApi2()&#123; console.log(&#x27;等待2秒哦&#x27;) await sleep(); const url = &#x27;http://rap2api.taobao.org/app/mock/17194/list2&#x27;; const response = await fetch(url,&#123;&#x27;token&#x27;:111&#125;); if(response.status !== 200)&#123; throw new Error(response.statusText); &#125; console.log(new Date().getTime()) return await response.json()&#125;const showGetInfo = async ()=&gt;&#123; try &#123; console.time(&#x27;时间&#x27;); const res1Promise = getApi1(); const res2Promise = getApi2(); const res1 = await res1Promise; const res2 = await res2Promise; console.log(&#x27;bool1&#x27;,res1.success,&#x27;results1&#x27;,res1.results.length,); console.log(&#x27;bool2&#x27;,res2.success,&#x27;results2&#x27;,res2.results); console.timeEnd(&#x27;时间&#x27;); &#125; catch (error) &#123; console.error(&#x27;错误error:&#x27;+error); &#125;&#125;showGetInfo(); Promise.all处理await的并行123456789101112131415const showGetInfo = async ()=&gt;&#123; try &#123; console.time(&#x27;时间&#x27;); const [res1,res2]= await Promise.all([ getApi1(),getApi2() ]) console.log(&#x27;bool1&#x27;,res1.success,&#x27;results1&#x27;,res1.results.length,); console.log(&#x27;bool2&#x27;,res2.success,&#x27;results2&#x27;,res2.results); console.timeEnd(&#x27;时间&#x27;); &#125; catch (error) &#123; console.error(&#x27;错误error:&#x27;+error); &#125;&#125;showGetInfo(); Promise.all 处理 Rejection 的技巧 Promise.all 这个 API 允许我们在多个操作完成之后继续做某些事情，遗憾的是 Promise.all 只会在所有传给他的 Promise 都 resolve 了之后才会 resolve，如果其中的一个 reject 了，那么 Promise.all 后面的 then 就不会被执行，catch 会被执行 123456789101112131415161718192021222324const fetch = require(&quot;node-fetch&quot;);const showGetInfo = async () =&gt; &#123; console.time(&quot;时间&quot;); Promise.all( [ Promise.resolve(1), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(2), 2000)), Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(4), 3000)), Promise.resolve(2), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(5), 4000)), Promise.resolve(4), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(6), 1000)), Promise.resolve(5), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(7), 1000)), ].map(p =&gt; p.catch(() =&gt; undefined)) ).then(data =&gt; &#123; console.timeEnd(&quot;时间&quot;); console.log(&quot;done!&quot;, data); &#125;);&#125;;showGetInfo();","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ES7","slug":"ES7","permalink":"http://mariogogogo.github.io/tags/ES7/"}]},{"title":"React Native开发实用小技巧(持续更新)","slug":"React Native开发实用技巧(持续更新)","date":"2018-04-09T16:00:00.000Z","updated":"2020-09-16T09:07:44.000Z","comments":true,"path":"2018/04/10/React Native开发实用技巧(持续更新)/","link":"","permalink":"http://mariogogogo.github.io/2018/04/10/React%20Native%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/","excerpt":"代码的缩进，使用4个空格，还是2个空格？我的回答是：2个空格。跟上面一样，我刚转到JavaScript的时候，觉得2个空格很反人类，太挤了。所以一直坚持4个空格。直到UI代码慢慢变多，嵌套变深。。。我才开始慢慢怀疑自己。前几天，我搜索了多个热门的JavaScript开源项目，无一例外使用的是2个空格。所以，我果断把代码改成2个空格。","text":"代码的缩进，使用4个空格，还是2个空格？我的回答是：2个空格。跟上面一样，我刚转到JavaScript的时候，觉得2个空格很反人类，太挤了。所以一直坚持4个空格。直到UI代码慢慢变多，嵌套变深。。。我才开始慢慢怀疑自己。前几天，我搜索了多个热门的JavaScript开源项目，无一例外使用的是2个空格。所以，我果断把代码改成2个空格。 如何根据不同屏幕尺寸，做等比例布局？美工出标注图的时候，通常是按照屏幕宽度750出的。如果需求是UI根据不同屏幕尺寸，做等比例的缩放。我们可以写一个叫px2dp的公共方法 1234567import &#123;Dimensions&#125; from &#x27;react-native&#x27;const basePixelWidth = 750const px2dp = (px: number): number =&gt; &#123; return px * Dimensions.get(&#x27;window&#x27;).width / basePixelWidth&#125; 比如要设置View的宽度为屏幕的一半。就可以这样：1&lt;View style=&#123;&#123;width: px2dp(375)&#125;&#125; /&gt; 如何快速获取屏幕宽高？123456789101112import &#123;Dimensions, PixelRatio&#125; from &#x27;react-native&#x27;const screenWidth = Dimensions.get(&#x27;window&#x27;).widthconst screenHeight = Dimensions.get(&#x27;window&#x27;).heightlet screen = &#123; width: screenWidth, height: screenHeight,&#125;export default screen 如何判断设备是iPhoneX？我们有时候需要对iPhoneX的异形屏做一些特殊的适配，就需要判断一个设备是否是iPhoneX12345678910111213141516171819202122232425import &#123;Platform, Dimensions&#125; from &#x27;react-native&#x27;const isIphoneX = () =&gt; &#123; let dimen = Dimensions.get(&#x27;window&#x27;) return ( Platform.OS === &#x27;ios&#x27; &amp;&amp; !Platform.isPad &amp;&amp; !Platform.isTVOS &amp;&amp; (dimen.height === 812 || dimen.width === 812) )&#125;// 判断是否是iOS设备const isIOS = () =&gt; &#123; return Platform.OS === &#x27;ios&#x27;&#125;// 是否是Android设备const isAndroid = () =&gt; &#123; return Platform.OS === &#x27;android&#x27;&#125;// 状态栏的高度const statusBarHeight = () =&gt; (isIOS() ? (isIphoneX() ? 44 : 20) : 0) 如何优雅的为每个页面增加Loading页、错误页？很多App大部分页面都需要用到Loading页。如果数据获取失败，还需要显示错误页，告诉用户错误原因，并且让用户点击重试。这时候，我们可以定义一个通用的组件叫Scene，然后在这个类中，定义Loading页面和错误页。使用的时候，只需要在我们的component这样实现 123456789101112render() &#123; let &#123;isLoading, error&#125; = this.state return ( &lt;Scene isLoading=&#123;isLoading&#125; error=&#123;error&#125; onRetry=&#123;this.requestData&#125; &gt; &lt;/Scene&gt; )&#125; 当我们需要请求网络的时候，把isLoading设置为true。这样Scene组件就会为我们展示一个Loading页面。当网络请求失败的时候，把isLoading设置为false，error设置为具体的错误信息。Scene组件就会显示一个错误页，并且有一个“重试”按钮。用户点击“重试”后，会调用onRetry回调。Scene的代码简化后，大概是这样 1234567891011121314151617181920type Props = &#123; isLoading?: boolean, error?: ?string, onRetry?: Function, children?: any, style?: Object,&#125;class Scene extends PureComponent&lt;Props&gt; &#123; render() &#123; let &#123;isLoading, style, error, children, onRetry&#125; = this.props return ( &lt;View style=&#123;[styles.container, style]&#125;&gt; &#123;!isLoading &amp;&amp; children&#125; &lt;ErrorView text=&#123;error&#125; onPress=&#123;onRetry&#125; /&gt; &lt;LoadingView isLoading=&#123;isLoading&#125; /&gt; &lt;/View&gt; ) &#125;&#125; 这里需要注意的是，ErrorView、LoadingView需要使用下面这种绝对布局。否则可能会被页面的内容顶到屏幕外面。 12345678&#123; position: &#x27;absolute&#x27;, top: 0, left: 0, right: 0, bottom: 0, &#125;","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"React Native面试题库(持续更新)","slug":"React Native面试题库(持续更新)","date":"2018-04-08T16:00:00.000Z","updated":"2020-09-16T09:07:44.000Z","comments":true,"path":"2018/04/09/React Native面试题库(持续更新)/","link":"","permalink":"http://mariogogogo.github.io/2018/04/09/React%20Native%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/","excerpt":"本文原创首发于公众号：ReactNative开发圈，转载需注明出处。 1.React Native相对于原生的ios和Android有哪些优势？1.性能媲美原生APP2.使用JavaScript编码，只要学习这一种语言3.绝大部分代码安卓和IOS都能共用4.组件式开发，代码重用性很高5.跟编写网页一般，修改代码后即可自动刷新，不需要慢慢编译，节省很多编译等待时间6.支持APP热更新，更新无需重新安装APP","text":"本文原创首发于公众号：ReactNative开发圈，转载需注明出处。 1.React Native相对于原生的ios和Android有哪些优势？1.性能媲美原生APP2.使用JavaScript编码，只要学习这一种语言3.绝大部分代码安卓和IOS都能共用4.组件式开发，代码重用性很高5.跟编写网页一般，修改代码后即可自动刷新，不需要慢慢编译，节省很多编译等待时间6.支持APP热更新，更新无需重新安装APP缺点：内存占用相对较高版本还不稳定，一直在更新，现在还没有推出稳定的1.0版本 2.React Native组件的生命周期 生命周期 调用次数 能否使用 setSate() 周期名称以及调用次数 能否使用 setSate() 还没想好 getDefaultProps 1(全局调用一次) 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 否 3.当你调用setState的时候，发生了什么事？当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。为此，React将构建一个新的 React 元素树（您可以将其视为 UI 的对象表示）。一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ diff ）。通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间。 4.props和state相同点和不同点1.不管是props还是state的改变，都会引发render的重新渲染。2.都能由自身组件的相应初始化函数设定初始值。 不同点1.初始值来源：state的初始值来自于自身的getInitalState（constructor）函数；props来自于父组件或者自身getDefaultProps（若key相同前者可覆盖后者）。 2.修改方式：state只能在自身组件中setState，不能由父组件修改；props只能由父组件修改，不能在自身组件修改。 3.对子组件：props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件；state代表的是一个组件内部自身的状态，只能在自身组件中存在。 5.shouldComponentUpdate 应该做什么其实这个问题也是跟reconciliation有关系。“和解（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。如果我们知道我们的用户界面（UI）的某一部分不会改变，那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。通过从 shouldComponentUpdate 返回 false，React 将假定当前组件及其所有子组件将保持与当前组件相同 6.reactJS的props.children.map函数来遍历会收到异常提示，为什么？应该如何遍历？this.props.children 的值有三种可能： 1.当前组件没有子节点，它就是 undefined; 2.有一个子节点，数据类型是 object ； 3.有多个子节点，数据类型就是 array 。系统提供React.Children.map()方法安全的遍历子节点对象 7.redux状态管理的流程action是用户触发或程序触发的一个普通对象。reducer是根据action操作来做出不同的数据响应，返回一个新的state。store的最终值就是由reducer的值来确定的。（一个store是一个对象, reducer会改变store中的某些值）action -&gt; reducer -&gt; 新store -&gt; 反馈到UI上有所改变。 8.加载bundle的机制要实现RN的脚本热更新，我们要搞明白RN是如何去加载脚本的。 在编写业务逻辑的时候，我们会有许多个js文件，打包的时候RN会将这些个js文件打包成一个叫index.android.bundle(ios的是index.ios.bundle)的文件，所有的js代码(包括rn源代码、第三方库、业务逻辑的代码)都在这一个文件里，启动App时会第一时间加载bundle文件，所以脚本热更新要做的事情就是替换掉这个bundle文件。 9.Flex布局采用Flex布局的元素，称为Flex容器（flex Container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。flex-direction 属性决定主轴的方向（即项目的排列方向)。flex-wrap 属性定义，如果一条轴线排不下，如何换行。flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式。justify-content 定义了项目在主轴上的对齐方式。align-items 属性定义项目在交叉轴上如何对齐。align-content align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 10.请简述 code push 的原理code push 调用 react native 的打包命令，将当前环境的非 native 代码全量打包成一个 bundle 文件，然后上传到微软云服务器（Windows Azure）。 在 app 中启动页（或 splash 页）编写请求更新的代码（请求包含了本地版本，hashCode、appToken 等信息），微软服务端对比本地 js bundle 版本和微软服务器的版本，如果本地版本低，就下载新的 js bundle 下来后实现更新(code push 框架实现)。 11.Redux中同步 action 与异步 action 最大的区别是什么同步只返回一个普通 action 对象。而异步操作中途会返回一个 promise 函数。当然在 promise 函数处理完毕后也会返回一个普通 action 对象。thunk 中间件就是判断如果返回的是函数，则不传导给 reducer，直到检测到是普通 action 对象，才交由 reducer 处理。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/categories/ReactNative/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://mariogogogo.github.io/tags/ReactNative/"}]},{"title":"什么是Redux","slug":"什么是Redux","date":"2018-02-01T07:13:48.000Z","updated":"2020-09-16T09:07:12.000Z","comments":true,"path":"2018/02/01/什么是Redux/","link":"","permalink":"http://mariogogogo.github.io/2018/02/01/%E4%BB%80%E4%B9%88%E6%98%AFRedux/","excerpt":"认识下redux","text":"认识下redux什么是redux当你去开发复杂的单页应用的时候你需要管理各种复杂的应用状态，这鞋状态可能是服务器返回的状，态，本地的数据 url redux可预测的状态管理 只维护数据一个应用如何复杂 只有一个store 数据只存store得到store数据 用 getstate（）不能直接修改store 而是应该发起一个action 请求 然后 reducer会去更改数据，如何更改你不用关心 1234567891011121314151617181920212223242526import &#123;createStore&#125; from &#x27;redux&#x27;;// reducer唯一 statefunction counter(state = 0, action) &#123; let &#123;type&#125; = action; switch (type) &#123; case &#x27;INCREMENT&#x27;: return++ state; default: return state; &#125;&#125;//获取最新的store数据let store = createStore(counter);$(document).click(ev =&gt; &#123; // 发布action来更新数据 store.dispatch(&#123;type: &#x27;INCREMENT&#x27;&#125;);&#125;);// 监听state的变化store.subscribe(() =&gt; &#123; //一旦state变化就可以再去更新View视图相关 let state = store.getState(); console.log(state);&#125;); 错误的更新state 正确的更新state action可能非常多，一个可维护的应用你要把acion放再一个文件里面或者视图相关的action放在某个模块里面 counter不能副作用 什么是副作用 就是里面如果ajax请求 路由跳转 或者 counter1 counter2 react与redux如何一起用","categories":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"React之简书界面demo","slug":"React之简书界面demo","date":"2018-01-31T07:13:48.000Z","updated":"2020-09-16T09:07:49.000Z","comments":true,"path":"2018/01/31/React之简书界面demo/","link":"","permalink":"http://mariogogogo.github.io/2018/01/31/React%E4%B9%8B%E7%AE%80%E4%B9%A6%E7%95%8C%E9%9D%A2demo/","excerpt":"做一些小练习","text":"做一些小练习分析项目界面","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"React","slug":"React","permalink":"http://mariogogogo.github.io/tags/React/"},{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"手写一个 reduce 实现","slug":"手写一个reduce的实现","date":"2017-12-29T16:00:00.000Z","updated":"2020-09-16T09:07:14.000Z","comments":true,"path":"2017/12/30/手写一个reduce的实现/","link":"","permalink":"http://mariogogogo.github.io/2017/12/30/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAreduce%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"我们知道 reduce 方法是 ES5 引入的，reduce 英文解释翻译过来为「减少，缩小，使还原，使变弱」","text":"我们知道 reduce 方法是 ES5 引入的，reduce 英文解释翻译过来为「减少，缩小，使还原，使变弱」 它的使用语法： 1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 这里我们简要介绍一下。 reduce 第一个参数 callback 是核心，它对数组的每一项进行「叠加加工」，其最后一次返回值将作为 reduce 方法的最终返回值。 它包含 4 个参数： previousValue 表示「上一次」 callback 函数的返回值 currentValue 数组遍历中正在处理的元素 currentIndex 可选，表示 currentValue 在数组中对应的索引。如果提供了 initialValue，则起始索引号为 0，否则为 1 array 可选，调用 reduce() 的数组 initialValue 可选，作为第一次调用 callback 时的第一个参数。如果没有提供 initialValue，那么数组中的第一个元素将作为 callback 的第一个参数。 reduce 实现 runPromiseInSequence 我们看它的一个典型应用，按顺序运行 Promise： 12345678910111213141516171819202122const f1 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;p1 running&quot;); resolve(1); &#125;, 1000); &#125;);const f2 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;p2 running&quot;); resolve(2); &#125;, 1000); &#125;);const array = [f1, f2];const runPromiseInSequence = (array, value) =&gt; array.reduce((promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction), Promise.resolve(value));runPromiseInSequence(array, &quot;init&quot;); 实现方案 ① 1234567891011121314151617181920212223242526272829303132// ① 定义到 Array.prototype 上。 函数有两个参数Array.prototype.myReduse = function(callback, init) &#123; // init 是可选的， 这里的 this 是调用的那个array。 init = init || null; const array = this; // ② 定义 prev 之前的结果 和 循环起始点 let prev, startIndex = 0; // ③ 没有初始值 &amp;&amp; 数组是空 =&gt; 报错 if (!init &amp;&amp; array.length == 0) return console.log(&quot;空数组，没有初始值&quot;); // 没有初始值 &amp;&amp; 数组长度=1 =&gt; 直接返回第一项，callback不执行 if (!init &amp;&amp; array.length == 1) return array[0]; // 没有初始值 &amp;&amp; 长度大于1 =&gt; 从第二项开始，prev = 第一项的值 if (!init &amp;&amp; array.length &gt; 1) &#123; prev = array[0]; startIndex = 1; &#125; // 有初始值 &amp;&amp; 长度大于1 =&gt; 从第一项开始，prev = init 初始值 if (init &amp;&amp; array.length &gt; 1) &#123; prev = init; &#125; for (let index = startIndex; index &lt; array.length; index++) &#123; // prev 始终是回调函数执行的结果， // callback 按照顺序传入值： 前面的结果， 当前项的值， 当前索引，原数组 prev = callback(prev, array[index], index, array); &#125; // 返回之前项的结果。 return prev;&#125;; 方案 ② 1234567891011Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) &#123; var arr = this; var base = typeof initialValue === &quot;undefined&quot; ? arr[0] : initialValue; var startPoint = typeof initialValue === &quot;undefined&quot; ? 1 : 0; arr.slice(startPoint).forEach(function(val, index) &#123; base = func(base, val, index + startPoint, arr); &#125;); return base; &#125;; 参考JS Array.prototype.reduce 的一些理解 数组 reduce 方法的相关实现 数组 reduce 一看一整天","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"手写一个call或 apply","slug":"手写一个call或 apply","date":"2017-12-24T16:00:00.000Z","updated":"2020-09-16T09:07:12.000Z","comments":true,"path":"2017/12/25/手写一个call或 apply/","link":"","permalink":"http://mariogogogo.github.io/2017/12/25/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAcall%E6%88%96%20apply/","excerpt":"","text":"call语法： fun.call(thisArg,arg1,arg2,…)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 使用：123456789101112function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = &#x27;food&#x27;;&#125;console.log(new Food(&#x27;cheese&#x27;, 5).name);//&quot;cheese&quot; 简单说下实现原理： 将函数设为对象的属性 执行&amp;删除这个函数 指定 this到函数并传入给定参数执行函数 如果不传入参数，默认指向为 window 乞丐版本： 代码：如果我们想要实现一个新的newcall理想状态应该怎么样？ 123456789101112Function.prototype.newcall = function (content = window) &#123; //this指的是bar(name,age) content.fn = this; // 取出参数中的第一个参数 与其他参数 let args = [...arguments].slice(1); //content.fn就是指bar方法 let result = content.fn(...args); //删除this delete content.fn; //返回新对象 return result;&#125; apply语法： func.apply(thisArg,[argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。 12345678910111213Function.prototype.newapply = function (content = window) &#123; content.fn = this; let result; //判断是否有第二个参数 if(arguments[1])&#123; result = content.fn(...arguments[1]); &#125;else&#123; result = content.fn() &#125; delete content.fn; return result;&#125;bar.newapply(foo,[&quot;jack&quot;]) 手写系列 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"手写一个instanceof","slug":"手写一个instanceof","date":"2017-12-24T16:00:00.000Z","updated":"2020-09-16T09:07:13.000Z","comments":true,"path":"2017/12/25/手写一个instanceof/","link":"","permalink":"http://mariogogogo.github.io/2017/12/25/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAinstanceof/","excerpt":"在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。","text":"在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。instanceof 示例1234567891011121314function F() &#123; this.name = name; get:()=&gt;&#123; console.log(&#x27;这是一个获取方法&#x27;,this) &#125; &#125; F.prototype.get_pro = function () &#123; console.log(&#x27;这是一个原型实例上的方法&#x27;,this) &#125; let w = new F(); console.log(w instanceof F);//true这段代码问的是“变量 w 是否为 F 对象的实例？”w 的确是 F 对象的实例，因此结果是”true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 实现原理：12345678910111213141516171819202122232425262728293031/** * 实现一个instanceof * instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 * @returns &#123;boolean&#125; */function newInstanceof(left,right) &#123; //获取实例的原型对象 let proto = left.__proto__; //获取构造函数的原型对象 let prototype = right.prototype; //默认判断true while (true)&#123; //如果实例对象为空 则为false if(proto == null) return false //如果原型对象 === 构造函数的原型对象 则判断true if(proto == prototype) return true //否则继续想原型对象的上一级寻找原型对象，一直找到Object为止 proto = proto.__proto__; &#125; &#125; function W()&#123; get:()=&gt;&#123; console.log(this) &#125; console.log(&#x27;我是w&#x27;) &#125; console.log(newInstanceof(w,F)) console.log(newInstanceof(w,W)) console.log(newInstanceof(w,Object)) 手写系列 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"手写一个JSON.stringify与JSON.parse","slug":"手写一个JSON.stringify与JSON.parse","date":"2017-12-23T16:00:00.000Z","updated":"2020-09-16T09:07:13.000Z","comments":true,"path":"2017/12/24/手写一个JSON.stringify与JSON.parse/","link":"","permalink":"http://mariogogogo.github.io/2017/12/24/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAJSON.stringify%E4%B8%8EJSON.parse/","excerpt":"","text":"JSON.stringify()我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 JSON.stringify(value[, replacer[, space]]) Boolean|Number|String 类型会自动转换成对应的原始值。 undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 12345678910111213141516171819202122232425262728293031function jsonStringify(obj) &#123; let type = typeof obj; if (type !== &quot;object&quot; || type === null) &#123; if (/string|undefined|function/.test(type)) &#123; obj = &#x27;&quot;&#x27; + obj + &#x27;&quot;&#x27;; &#125; return String(obj) &#125; else &#123; let json = []; // typeof []也是object 继续判断是否是数组 arr = (obj &amp;&amp; obj.constructor === Array); // 遍历对象 for (let k in obj) &#123; let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) &#123; v = &#x27;&quot;&#x27; + v + &#x27;&quot;&#x27;; &#125; else if (type === &quot;object&quot;) &#123; //判断如果是object继续递归 v = jsonStringify(type); &#125; json.push((arr ? &quot;&quot; : &#x27;&quot;&#x27;+ k + &#x27;&quot;:&#x27;)+String(v)) &#125; return (arr ? &quot;[&quot; : &quot;&#123;&quot;) + String(json)+(arr ? &quot;]&quot; : &quot;&#125;&quot;) &#125; &#125; console.log(jsonStringify(2)) console.log(jsonStringify(&#123;x: 5&#125;)) // &quot;&#123;&quot;x&quot;:5&#125;&quot; console.log(jsonStringify([1, &quot;false&quot;, false])) // &quot;[1,&quot;false&quot;,false]&quot; console.log(jsonStringify(&#123;b: undefined&#125;)) JSON.parse()我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 JSON.parse(text[, reviver]) 用法： 12var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site; 第一种写法：12345function jsonParse(opt) &#123; return eval(&#x27;(&#x27; + opt + &#x27;)&#x27;); &#125; console.log(jsonParse(jsonStringify(&#123;x: 1, y: undefined, z: null&#125;)))第二种写法12345// 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。let jsonStr = &#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;let json = (new Function(&#x27;return&#x27;+jsonStr))();console.log(json)原因是：核心： Function与 eval有相同的字符串参数特性。 let func=newFunction(arg1,arg2,…,functionBody); 手写系列 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"【置顶】JavaScript 编码风格指南","slug":"JavaScript 编码风格指南","date":"2017-12-22T04:39:04.000Z","updated":"2020-09-16T09:07:33.000Z","comments":true,"path":"2017/12/22/JavaScript 编码风格指南/","link":"","permalink":"http://mariogogogo.github.io/2017/12/22/JavaScript%20%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/","excerpt":"序语言的编码风格指南对于一个长期维护的软件而言是非常重要的。本指南是基于“Java语言编码规范”（Code Conventions fo the Java Programming Language）和Crockford的（JavaScript）规范，同时结合了我个人的经验和喜好做了一些改动。","text":"序语言的编码风格指南对于一个长期维护的软件而言是非常重要的。本指南是基于“Java语言编码规范”（Code Conventions fo the Java Programming Language）和Crockford的（JavaScript）规范，同时结合了我个人的经验和喜好做了一些改动。1.缩进 每一行的层级由四个空格组成，避免使用制表符（Tab）进行缩进。 1234// 好的写法if (true) &#123; doSomething();&#125; 2.行的长度 每行长度不应该超过80个字符。如果一行多余80个字符，应当在一个运算符（逗号，加号等）后换行。下一行应当增加两极缩进（8个字符）； 123456789// 好的写法doSomething(argument1, argument2, argument3, argument4, argument5);// 不好的写法：第二行只有四个空格的缩进doSomething(argument1, argument2, argument3, argument4, argument5);// 不好的写法：在运算符之前换行doSomething(argument1, argument2, argument3, argument4 ,argument5); 3.原始值 字符串应当始终使用单引号(避免使用双引号)且保持一行。避免在字符串中使用斜线另起一行。 123456789101112131415161718192021222324// 好的写法var name = &#x27;Nicholas&#x27;;// 不好的写法： 双引号var name = &quot;Nicholas&quot;;// 不好的写法：字符串结束之前换行var longString = &#x27;Here is the story, of a man \\named Brady.&#x27;;数字应当使用十进制整数，科学计数法表示整数，十六进制整数，或者十进制浮点小数，小数点前后应当至少保留一位数字。避免使用八进制直接量。// 好的写法var count = 10;// 好的写法var price = 10.0;var price = 10.00;// 好的写法var num = 0xA2;// 好的写法var num = 1e23;// 不好的写法：十进制数字以小数点结尾var price = 10.;// 不好的写法：十进制数字以小数点开头var price = .1;// 不好的写法：八进制（base 8）写法已废弃var num = 010; 特殊值null除了下述情况下应当避免使用。 用来初始化一个变量，这个变量可能被赋值为一个对象。用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个变量。当函数的参数期望是对象时，被用作参数传入。当函数的返回值期望是对象时，被用作返回值传出。例如： 123456789101112131415161718// 好的写法var person = null;// 好的写法function getPersion();if (persion != null) &#123; doSomething();&#125;// 不好的写法：和一个未被初始化的变量比较var persion;if (persion != null) &#123; doSomething();&#125;// 不好的写法：function doSomething(arg1, arg2, arg3, arg4) &#123; if (arg4 != null) &#123; doSomething(Else); &#125;&#125; 避免使用特殊值 undefined。判断一个变量是否定义应当使用typeof操作符。 12345678// 好的写法if (typeof variable == &#x27;undefined&#x27;) &#123; // do something&#125;// 不好的写法：使用了undefined直接量if (variable == undefined) &#123; // do something;&#125; 4.运算符间距 二元运算符前后必须使用一个空格来保持表达式的整洁。操作符包括赋值运算符和逻辑运算符。 1234567891011121314151617181920// 好的写法var found = (values[i] === item);// 好的写法if (found &amp;&amp; (count &gt; 10)) &#123; doSomething();&#125;// 好的写法for (i = 0; i &lt; count; i++) &#123; process(i);&#125;// 不好的写法：丢失空格var found = (values[i]===item);// 不好的写法：丢失空格if (found&amp;&amp;(count&gt;10)) &#123; doSomething();&#125;// 不好的写法：丢失空格for (i=0; i&lt;count; i++) &#123; process(i);&#125; 5.括号间距 当使用括号时，紧接左括号之后和紧接右括号之前不应该有空格。 1234567891011121314151617181920// 好的写法var found = (values[i] === item);// 好的写法if (found &amp;&amp; (count &gt; 10)) &#123; doSomething();&#125;// 好的写法for (i= 0; i &lt; count; i++) &#123; process(i);&#125;// 不好的写法：左括号之后有额外的空格var found = ( values[i] === item);// 不好的写法：右括号之后有额外的空格if (found &amp;&amp; (count &gt; 10) ) &#123; doSomething();&#125;// 不好的写法：参数两边有额外的空格for (i= 0; i &lt; count; i++) &#123; process( i );&#125; 6.对象直接量 对象直接量应当使用如下格式。 其实左括号应当同表达式保持同一行。每个属性的名值对应当保持一个缩进，第一个属性应当在左括号后另起一行。每个属性的名值对应当使用不用引号的属性名，其后紧跟一个冒号（之前不含空格）,而后是值。倘若属性值是函数类型，函数体应当在属性名之下另起一行，而且其后均应保留一个空行。一组相关的属性前后可以插入空行以提升代码的可读性。结束的右括号应当独占一行。 12345678910111213141516171819202122// 好的写法var object = &#123; key1: value1, key2: function() &#123; //做些什么 &#125;, key3: value3&#125;;// 不好的写法：不且当的缩进var object = &#123; key1: value1, key2: value2 &#125;;// 不好的写法：函数体周围缺少空行var object = &#123; key1: value1, key2: function() &#123; //做些什么 &#125;, key3: value3&#125;; 当对象字面量作为函数参数时，如果值是变量，起始花括号应当同函数名在同一行。 所有其余先前列出的规则同样使用。 1234567// 好的写法doSomething(&#123; key1: value1, key2: value2&#125;);// 不好的写法： 所有代码在一行上doSomething(&#123; key1: value1, key2: value2 &#125;); 7.注释频繁地使用注释有助于他人理解你的代码。如下情况应当使用注释。 代码晦涩难懂。可能被误认为错误的代码。必要但不明显的针对特定浏览器的代码。对于对象、方法或者属性，生成文档是有必要的（使用且当的文档注释）。7.1 单行注释 单行注释应当来说明一行代码或者一组相关的代码。单行注释可能有三种使用方式。 独占一行的注释，用来解释下一行代码。 在代码行的尾部注释，用来解释之前的代码。 多行，用来注释掉一个代码块。 这里有一些示例代码。 1234567891011121314151617181920212223242526// 好的写法if (condition) &#123; // 如果代码执行到这里，则表明通过了所有安全性检查 allowed();&#125;// 不好的写法：注释之前没有空行if (condition) &#123; // 如果代码执行到这里，则表明通过了所有安全性检查 allowed();&#125;// 不好的写法：错误的缩进if (condition) &#123;// 如果代码执行到这里，则表明通过了所有安全性检查 allowed();&#125;// 不好的写法：这里应当用多行注释// 接下来的这段代码非常难，那么，让我详细解释一下// 这段代码的作用是首先判断条件是否为真// 只有为真时才执行。这里的条件是通过// 多个函数计算出来的，在整个会话生命期内// 这个值是可以修改的if (condition) &#123; // 如果代码执行到这里，则表明通过了所有安全性检查 allowed();&#125; 对于代码尾单行注释的情况，应确保代码尾同注释之间至少一个缩进。123456789101112// 好的写法var result = something + somethingElse; // somethingElse will never be null// 不好的写法：代码和注释间没有足够的空格var result = something + somethingElse;// somethingElse will never be null注释一个代码块时在连续多行使用单行注释是唯一可以接受的情况。多行注释不应当在这种情况下使用。// 好的写法// if (condition) &#123;// doSomething();// thenDoSomethingElse();// &#125; 7.2 多行注释多行注释应当在代码需要更多文字去解释的时候使用。每个多行注释都至少有如下三行。 首行仅仅包括/*注释开始。该行不应当有其他文字。 接下来的行以*开头并保持左对齐。这些行可以有文字描述。 最后一行以*/开头并同先前行保持对齐。也不应该有其他文字。 多行注释的手行应当保持同它描述代码的相同层次缩进。后续的每行应当有同样层次的缩进并附加一个空格（为了适当保持*字符的对齐）。对每一个多行代码之前应预留一个空格。 1234567891011121314151617181920212223242526272829303132333435// 好的写法if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有的安全检测 */ allowed();&#125;// 不好的写法：注释之前无空行if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有的安全检测 */ allowed();&#125;// 不好的写法：星号后没有空格if (condition) &#123; /* *如果代码执行到这里 *说明通过了所有的安全检测 */ allowed();&#125;// 不好的写法：错误的缩进if (condition) &#123;/* * 如果代码执行到这里 * 说明通过了所有的安全检测 */ allowed();&#125;// 不好的写法：代码尾部注释不要用多行注释格式var result = something + somethingElse; /* somethingElse will never be null */ 7.3 注释声明注释有时候也可以用来给一段代码声明额外的信息。这些声明的格式以单个单词打头并紧跟一个双引号。可使用的声明如下。 TODO 说明代码还未完成。应当包含下一步要做的事情。 HACK 表明代码实现走了一个捷径。应当包含为何使用hack的原因。这也可能表明该问题可能会有更好的解决办法。 XXX 说明代码是有问题的并应当尽快修复。 FIXME 说明代码是有问题的并应尽快修复。重要行略次于XXX。 REVIEW 说明代码任何可能的改动都需要评审。 这些声明可能在一行或多行注释中使用，并且应当遵循一般注释类型相同的格式规则。 例如：1234567891011121314151617181920212223242526// 好的写法// TODO：我希望找到一种更快捷的方式doSomething();// 好的写法/* * HACK：不得不针对IE做的特殊处理。我计划后续有时间时 * 重写这部分。这些代码可能需要在v1.2版本之前替换掉 */if (document.all) &#123; doSomething();&#125;// 好的写法// REVIEW：有更好的方法吗？if (document.all) &#123; doSomething();&#125;// 不好的写法：注释声明空格不正确// TODO： 我希望找到一种更快捷的方式doSomething();// 不好的写法：代码和注释应当保持同样的缩进 // REVIEW：有更好的方法吗？if (document.all) &#123; doSomething();&#125; 8.声明变量所有的变量在使用前应当事先定义。变量定义应当放在函数开头，使用一个var表达式每行一个变量。除了首行，所有行都应当多一层缩进以使变量名能够垂直方向对齐。变量定义时应当初始化，并赋值操作符应当保持一直的缩进。初始化的变量应当在未初始化变量之前。 1234567891011121314151617181920212223242526272829// 好的写法var count = 10, name = &#x27;Nicholas&#x27;, found = false, empty;// 不好的写法：不恰当的初始化赋值var count = 10, name = &#x27;Nicholas&#x27;, found= false, empty;// 不好的写法：错误缩进var count = 10,name = &#x27;Nicholas&#x27;,found = false,empty;// 不好的写法：多个定于写在一行var count = 10, name = &#x27;Nicholas&#x27;, found = false, empty;// 不好的写法：为初始化的变量放在最前边var empty, count = 10, name = &#x27;Nicholas&#x27;, found = false;// 不好的写法：多个var表达式var empty, count = 10;var name = &#x27;Nicholas&#x27;, found = false; 9.函数声明函数应当在使用前提前定义。一个不是作为方法的函数（也就是说没有作为一个对象的属性）应当使用函数定义的格式（不是函数表达式和Function构造格式）。函数名和开始圆括号之间不应当有空格。结束的圆括号和右边的花括号之间应该留一个空格。右侧的花括号应当同function关键字保持同一行。开始和结束括号之间不应该有空格。参数名之间应当在逗号之后保留一个空格。函数体应当保持一级缩进。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 好的写法function doSomething(arg1, arg2) &#123; return arg1 + arg2;&#125;// 不好的写法：第一行不恰当的空格function doSomething (arg1, arg2) &#123; return arg1 + arg2;&#125;// 不好的写法：函数表达式var doSomething = function(arg1, arg2) &#123; return arg1 + arg2;&#125;// 不好的写法：右侧花括号不对function doSomething(arg1, arg2)&#123; return arg1 + arg2;&#125;// 错误的写法：使用了Function构造器var doSomething = new Function(&#x27;arg1&#x27;, &#x27;arg2&#x27;, return arg1 + arg2);其他函数内部定义函数应当在var语句后立即定义。// 好的写法function outer() &#123; var count = 10, name = &#x27;Nicholas&#x27;, found = false, empty; function inner() &#123; // 代码 &#125; // 调用inner()的代码&#125;// 不好的写法：inner函数的定义先于变量function outer() &#123; function inner() &#123; // 代码 &#125; var count = 10, name = &#x27;Nicholas&#x27;, found = false, empty; // 调用inner()的代码&#125; 匿名函数可能作为方法赋值给对象，或者作为其他函数的参数。function关键字同开始括号之间不应有空格。 1234567891011121314151617181920212223242526272829303132// 好的写法object.method = function() &#123; // 代码&#125;;// 不好的写法：不正确的空格object.method = function () &#123; // 代码&#125;;立即被调用的函数应当在函数调用的外层用圆括号包裹。// 好的写法var value = (function() &#123; // 函数体 return &#123; message: &#x27;Hi&#x27; &#125;&#125;());// 不好的写法：函数调用外层没有用圆括号包裹var value = function() &#123; // 函数体 return &#123; message: &#x27;Hi&#x27; &#125;&#125;();// 不好的写法：圆括号的位置不当var value = (function() &#123; // 函数体 return &#123; message: &#x27;Hi&#x27; &#125;&#125;)(); 10.命名变量和函数在命名时应当小心。命名应仅限与数字字母字符，某些情况也可以使用下划线。最好不要在任何命名中使用美元（$）或反斜杠（\\）。 变量命名应当采用驼峰命名格式，首字母小写，每个单词首字母大写。变量名的第一个单词应是一个名词（而非动词），以避免同函数混淆。不要在变量命名中使用下划线。 123456789101112131415161718192021222324252627282930313233343536373839404142// 好的写法var accountNumber = &#x27;8401-1&#x27;;// 不好的写法：大些字母开头var AccountNumber = &#x27;8401-1&#x27;;// 不好的写法：使用下划线var account_number = &#x27;8401-1&#x27;;函数命名也应当采用驼峰命名格式。函数名的第一个单词应当是动词（而非名词）来避免同变量混淆。函数名中最好不要使用下划线。// 好的写法function doSomething() &#123; // 代码&#125;// 不好的写法：大些字母开头function DoSomething() &#123; // 代码&#125;// 不好的写法：名词开头function car() &#123; // 代码&#125;// 不好的写法：使用下划线function do_something() &#123; // 代码&#125;构造函数——通过new运算符创建新对象的函数——也应当以驼峰格式命名并且首字母大写。构造函数名称应一非动词开头，因为new代表这创建一个对象实例的操作。// 好的写法function MyObject() &#123; // 代码&#125;// 不好的写法：小字母开头function myObject() &#123; // 代码&#125;// 不好的写法：使用下划线function My_Object() &#123; // 代码&#125;// 不好的写法：动词开头function My_Object() &#123; // 代码&#125; 常量（值不会被改变的变量）的命名应当是所有字母大写，不同单词之间用单个下划线隔开。123456789101112131415// 好的写法var TOTAL_COUNT = 10;// 不好的写法：驼峰形式var totalCount = 10;// 不好的写法：混合形式var total_COUNT= 10;对象的属性同变量的同命名规则相同。对象的方法同函数的命名规则相同。如果属性或方法是私有的，应当在之前加一个下划线。// 好的写法var object = &#123; _count: 10, _getCount: function() &#123; return this._count; &#125;&#125;; 11.严格模式严格模式应当仅限在函数内部使用，千万不要在全局使用。 12345678910// 不好的写法：全局使用严格模式&#x27;use strict&#x27;;function doSomething() &#123; // 代码&#125;// 好的写法function doSomething() &#123; &#x27;use strict&#x27;; // 代码&#125; 如果你期望在多个函数中使用严格模式而不需要多次声明“usestrict”，可以使用立刻被调用的函数。 12345678910// 好的写法(function() &#123; &#x27;use strict&#x27;; function doSomething() &#123; // 代码 &#125; function doSomethingElse() &#123; // 代码 &#125;&#125;()); 12.赋值当给变量赋值时，如果右侧是含有比较语句的表达式，需要用括号包裹。 // 好的写法var flag = (i &lt; count);// 不好的写法：遗漏括号var flag = i &lt; count; 13.等号运算符使用===（严格相等）和！==（严格不相等）代替==（相等）和！=（不等）来避免弱类型转换错误。 1234// 好的写法var same =(a === b);// 不好的写法：使用==var same =(a == b); 14.三元操作符三元运算应当仅仅用在条件赋值语句中，而不要作为if语句的替代品。 1234// 好的方法var value = condition ? value1 : value2;// 不好的方法var condition ? doSomething() : doSomethingElse(); 15.语句 15.1 简单语句 每一行最多只包含一条语句。所有简单语句都应该以分号（;）结束。 12345// 好的写法count++;a = b;// 好的写法count++; a = b; 15.2 返回语句返回语句当返回一个值的时候不应该使用圆括号包裹，除非在某些情况下这么做可以让返回值更容易理解。例如： 123return;return collection.size();return (size &gt; 0 ? size : defaultSize); 15.3 复合语句复合语句是大括号括起来的语句列表。 括起来的语句应当较复合语句多缩进一个层级。开始的大括号应当在复合语句所在行的末尾；结束的大括号应当独占一行且同复合语句的开始保持同样的缩进。当语句是控制结构的一部分时，诸如if或者for语句，所有语句都需要用大括号括起来，也包括单个单词。zh这个约定使得我们更方便地添加语句而不用担心忘记加括号而引起bug。像if一样的语句开始的关键字，其后应该紧跟一个空格，起始大括号应当在空格之后。15.4 if 语句 if语句应当是下面的格式。 123456789101112131415if (condition) &#123; statments&#125;if (condition) &#123; statments&#125; else &#123; statments&#125;if (condition) &#123; statments&#125; else if (condition) &#123; statments&#125; else &#123; statments&#125; 绝不允许在if语句中省略花括号 123456789101112131415// 好的写法if (condition) &#123; doSomething();&#125;// 不好的写法：不且当的空格if(condition)&#123; doSomething();&#125;// 不好的写法：遗漏花括号if (condition) doSomething();// 不好的写法：所有代码在一行if (condition) &#123; doSomething(); &#125;// 不好的写法：所有代码在一行且没有花括号if (condition) doSomething(); 15.5 for 语句 for类型的语句应是下面的格式。 12345678910111213141516171819202122for (initialization; condition; update) &#123; statments&#125;for (variable in object) &#123; statments&#125;for语句的初始化不应当有变量声明。// 好的写法var i, len;for (i = 0, len = 10; i &lt; len; i++) &#123; // 代码&#125;// 不好的写法：初始化时候声明变量for (var i = 0, len = 10; i &lt; len; i++) &#123; // 代码&#125;// 不好的写法：初始化的时候声明变量for (var prop in object) &#123; // code&#125; 当使用for-in语句时，记得使用hasOwnProperty()进行双重检查来过滤出对象的成员。 15.6 while 语句 while类的语句应当是下面的格式。 123while (condition) &#123; statments&#125; 15.7 do 语句 do类的语句应当是下面格式。 123do &#123; statments&#125; while (condition); 15.8 switch 语句 switch类的语句应当是下面格式。 123456switch (expression) &#123; case expression: statments defaul: statments&#125; switch下的每一个case都应当保持一个缩进。除第一个之外包括default在内的每一个case都应当在之前保持一个空行。每一个语句（除了default）都应当以break、return、throw结尾，或者用一行注释表示跳过。 123456789101112// 好的写法switch (value) &#123; case 1: /* falls through */ case 2: doSomething(); break; case 3: return true; defaul: throw new Error(&#x27;This should not happen&#x27;);&#125; 如果一个switch语句不包含default情况，应应用一行注释代替。 1234567891011// 好的写法switch (value) &#123; case 1: /* falls through */ case 2: doSomething(); break; case 3: return true; // 没有default&#125; 15.9 ty 语句 try类语句应当格式如下。 123456789101112try &#123; statments&#125; catch (variable) &#123; statments&#125;try &#123; statments&#125; catch (variable) &#123; statments&#125; finally &#123; statments&#125; 16.留白在逻辑相关的代码之间添加空行可以提高代码的可读性。 两行空行仅限在如下情况中使用。 在不同的源码文件之间。在类和接口定义之间。单行空行仅限在如下情况中使用。 方法之间。方法中局部变量和第一行语句之间。多行或者单行注释之前。方法中逻辑代码块之间以提升代码的可读性。空格应在如下情况中使用。 关键词后跟括号的情况应当用空格隔开。参数列表中逗号之后应当保留一个空格。所有的除了点（.）之外的二元运算符，其操作数都应当用空格隔开。单目运算符的操作数之间不应该用空白隔开，诸如一元减号，递增（++），递减（–）。 for语句中的表达方式之间应当用空格号隔开。 17.需要避免的切勿使用像String一类的原始包装类型创建新的对象。避免使用eval（）。避免使用with语句。该语句在严格模式中不复存在，可能在未来的ECMAScript标准中也将去除。数字应当使用十进制整数，科学计数法表示整数，十六进制整数，或者十进制浮点小数，小数点前后应当至少保留一位数字。避免使用八进制直接量。 18.编程实践什么是松耦合很多设计模式就是为了解决紧耦合的问题，如果2个组件耦合太紧，则说明一个组件和另一个组件的直接相关，如果修改一个组件的逻辑那么另一个组件逻辑也需修改。比如一个名为error的css类名，有一天你觉得error不合适，想换warning那么不仅要修改css还要修改所有页面classsName的HTML，。当你能够做到修改个一个组件不需要更改其他组件时候，做到了松耦合。 将javascript从css中抽离12345//不好的写法.box&#123; width:expression&#123;document.body.offsetWidth+&quot;px&quot;&#125;&#125; 将css从javascript中抽离 12345678910111213141516171819//不好的写法element.style.color=&quot;red&quot;element.style.left=&quot;10px&quot;//好的写法css中加入.reveal&#123; color:red; left:10px; top:110px;&#125;element.className += &quot; reveal&quot;element.classList.add(&quot;reveal&quot;) 将javascript从html中抽离12345678910//不好的写法&lt;button onclick=&quot;doSomething()&quot; id=&quot;action-btn&quot;&gt;&lt;/button&gt;//好的写法function doSomething()&#123; //........&#125;var btn = ....btn.addEventListenter(&quot;click&quot;,doSomething,false); 19.事件处理20.避免空比较最后代码优化的建议 SOLID原则尽量保证SOLID原则的前提下，用最简易的代码满足需求（即不要考虑太多未来的可能性） 新需求需要修改现存代码的时候，尽可能保证SOLID原则需求不足以做出理想设计的时候， 允许存在违反SOLID的代码尽量保证自动化测试的代码覆盖率代码可读性高于一切， 尽量写自注释代码（即不需要额外注释，通过变量/方法命名就能读懂） ReSharper 转载自http://forsigner.com/2013/09/01/javascript-style-guide/","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://mariogogogo.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"手写一个New操作符","slug":"手写一个New操作符","date":"2017-12-12T16:00:00.000Z","updated":"2020-09-16T09:07:13.000Z","comments":true,"path":"2017/12/13/手写一个New操作符/","link":"","permalink":"http://mariogogogo.github.io/2017/12/13/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AANew%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"实现一个new","text":"实现一个new 它创建了一个全新的对象。 它会被执行 [[Prototype]]（也就是 proto）链接。 它使 this指向新创建的对象。。 通过 new创建的每个对象将最终被 [[Prototype]]链接到这个函数的 prototype对象上。 如果函数没有返回对象类型 Object(包含 Functoin,Array,Date,RegExg,Error)，那么 new表达式中的函数调用将返回该对象引用。 代码1234567891011121314function newF() &#123; // 创建一个新的对象 let obj = &#123;&#125;; // 取出第一个参数，该参数就是我们将会传入的构造函数，比如在调用new(P)的时候，Constructor就是P本身 // arguments会被shift去除第一个参数，剩余的就是构造器P的参数 let Constructor = [].shift.call(arguments); // 将obj的原型指向构造函数，此时obj可以访问构造函数原型中的属性 obj.__proto__ = Constructor.prototype; // 改变构造函数的this的指向，使其指向obj， 此时obj也可以访问构造函数中的属性了 let result = Constructor.apply(obj, arguments); // 确保 new 出来的是个对象 返回的值是什么就return什么 return typeof result === &#x27;object&#x27; ? result : obj &#125; 使用1234567function A(name,a,b)&#123; this.name = name; console.log(this.name) console.log(a+b) &#125; console.log(newF(A,&#x27;小米&#x27;,1,2)) 知识点如何绑定this, call、apply使用比如这句： [].shift.call(arguments)的意思是：[1,2,3,4] ====&gt; shift ==&gt; [2,3,4] 其中 Constructor就是1, arguments使用而到了这句 Constructor.apply(obj, arguments) 中 arguments就是[2,3,4]，意思是obj的this指向全部指向return新实例对象，并且把参数传入 原型链基础 手写系列 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"【置顶】Web前端开发规范手册","slug":"Web前端开发规范手册","date":"2017-12-11T16:00:00.000Z","updated":"2020-09-16T09:07:57.000Z","comments":true,"path":"2017/12/12/Web前端开发规范手册/","link":"","permalink":"http://mariogogogo.github.io/2017/12/12/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C/","excerpt":"为提高团队协作效率, 便于后台人员添加功能及前端后期优化维护, 输出高质量的文档, 特制订此文档. 本规范文档一经确认, 前端开发人员必须按本文档规范进行前台页面开发. 本文档如有不对或者不合适的地方请及时提出, 经讨论决定后可以更改此文档.","text":"为提高团队协作效率, 便于后台人员添加功能及前端后期优化维护, 输出高质量的文档, 特制订此文档. 本规范文档一经确认, 前端开发人员必须按本文档规范进行前台页面开发. 本文档如有不对或者不合适的地方请及时提出, 经讨论决定后可以更改此文档. 一、规范目的1.1 概述 为提高团队协作效率, 便于后台人员添加功能及前端后期优化维护, 输出高质量的文档, 特制订此文档. 本规范文档一经确认, 前端开发人员必须按本文档规范进行前台页面开发. 本文档如有不对或者不合适的地方请及时提出, 经讨论决定后可以更改此文档. 二、文件规范 2.1 文件命名规则 文件名称统一用小写的英文字母、数字和下划线的组合，其中不得包含汉字、空格和特殊字符；命名原则的指导思想一是使得你自己和工作组的每一个成员能够方便的理解每一个文件的意义，二是当我们在文件夹中使用“按名称排例”的命令时，同一种大类的文件能够排列在一起，以便我们查找、修改、替换、计算负载量等等操作。 a. HTML的命名原则引文件统一使用index.htm index.html index.asp文件名（小写）各子页命名的原则首先应该以栏目名的英语翻译取单一单词为名称。例如：关于我们 \\ aboutus信息反馈 \\ feedback产 品 \\ product如果栏目名称多而复杂并不好以英文单词命名，则统一使用该栏目名称拼音或拼音的首字母表示；每一个目录中应该包含一个缺省的html 文件，文件名统一用index.htm index.html index.asp； b. 图片的命名原则图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质例如：广告、标志、菜单、按钮等等。放置在页面顶部的广告、装饰图案等长方形的图片取名： banner标志性的图片取名为： logo在页面上位置不固定并且带有链接的小图片我们取名为 button在页面上某一个位置连续出现，性质相同的链接栏目的图片我们取名： menu装饰用的照片我们取名： pic不带链接表示标题的图片我们取名： title范例：banner_sohu.gif banner_sina.gif menu_aboutus.gif menu_job.gif title_news.gif logo_police.gif logo_national.gif pic_people.jpg鼠标感应效果图片命名规范为”图片名+_+on/off”。例如：menu1_on.gif menu1_off.gif c. javascript的命名原则例如：广告条的javascript文件名为 ad.js 弹出窗口的javascript文件名为 pop.js d. 动态语言文件命名原则以性质描述，描述可以有多个单词，用“”隔开，性质一般是该页面得概要。范例：register_form.asp register_post.asp topic_lock.asp 2.2 文件存放位置规范 _Root cn 存放中文HTML文件 en 存放英文HTML文件 flash 存放Flash文件 images 存放图片文件 imagestudio 存放PSD源文件 flashstudio 存放flash源文件 inc 存放include文件 library 存放DW库文件 media 存放多媒体文件 project 存放工程项目资料 temp 存放客户原始资料 js 存放JavaScript脚本 css 存放CSS文件 2.3 CSS 书写规范 基本原则： CSS样式可细分为3类：自定义样式、重新定义HTML样式、链接状态样式。 样式为设计师自定义的新 CSS 样式，影响被使用本样式的区域，用于完成网页中局部的样式设定。样式名 “.”+“相应样式效果描述的单词或缩写”例：“ .shadow ”文字样式样式名“.no”+“字号”+“行距”+“颜色缩写”例：“ .no12 ” 、“ .no12-24 ” 义HTML样式为设计师重新定义已有的HTML标签样式，影响全部的被设定标签样式，用于统一网页中某一标签的样式定义。样式名“HTML标签”例：hr { border: 1px dotted #333333 } 态样式为设计师对链接不同状态设定特殊样式，影响被使用本样式区域中的链接。该样式写法有2种： a.nav:link nav.a:link 第一种只能修饰标签中；第二种可以修饰所有包含有标签的其他标签。页面内的样式加载必须用链接方式 注意细则： 协作开发及分工: i会根据各个模块, 同时根据页面相似程序, 事先写好大体框架文件, 分配给前端人员实现内部结构&amp;表现&amp;行为; 共用css文件base.css由i书写, 协作开发过程中, 每个页面请务必都要引入, 此文件包含reset及头部底部样式, 此文件不可随意修改; class与id的使用: id是唯一的并是父级的, class是可以重复的并是子级的, 所以id仅使用在大的模块上, class可用在重复使用率高及子级中; id原则上都是由我分发框架文件时命名的, 为JavaScript预留钩子的除外; 为JavaScript预留钩子的命名, 请以 js_ 起始, 比如: js_hide, js_show; class与id命名: 大的框架命名比如header/footer/wrapper/left/right之类的在2中由i统一命名.其他样式名称由 小写英文 &amp; 数字 &amp; _ 来组合命名, 如i_comment, fontred, width200; 避免使用中文拼音, 尽量使用简易的单词组合; 总之, 命名要语义化, 简明化. 规避class与id命名(此条重要, 若有不明白请及时与i沟通):a, 通过从属写法规避, 示例见d;b, 取父级元素id/class命名部分命名, 示例见d;c, 重复使用率高的命名, 请以自己代号加下划线起始, 比如i_clear;d, a,b两条, 适用于在2中已建好框架的页面, 如, 要在2中已建好框架的页面代码中加入新的div元素,按a命名法则: …,样式写法: #mainnav .firstnav{…….}按b命名法则: …,样式写法: .main_firstnav{…….} css属性书写顺序, 建议遵循 布局定位属性–&gt;自身属性–&gt;文本属性–&gt;其他属性. 此条可根据自身习惯书写, 但尽量保证同类属性写在一起. 属性列举: 布局定位属性主要包括: margin、padding、float（包括clear）、position（相应的 top,right,bottom,left）、display、visibility、overflow等；自身属性主要包括: width &amp; height &amp; background &amp; border; 文本属性主要包括：font、color、text-align、text-decoration、text-indent等；其他属性包括: list-style(列表样式)、vertical-vlign、cursor、z-index(层叠顺序) 、zoom等.我所列出的这些属性只是最常用到的, 并不代表全部; 书写代码前, 考虑并提高样式重复使用率; 充分利用html自身属性及样式继承原理减少代码量, 比如:这儿是标题列表2010-09-15定义ul.list li{position:relative} ul.list li span{position:absolute; right:0}即可实现日期居右显示 样式表中中文字体名, 请务必转码成unicode码, 以避免编码错误时乱码; 背景图片请尽可能使用sprite技术, 减小http请求, 考虑到多人协作开发, sprite按模块制作; 使用table标签时(尽量避免使用table标签), 请不要用width/ height/cellspacing/cellpadding等table属性直接定义表现, 应尽可能的利用table自身私有属性分离结构与表现, 如thead,tr,th,td,tbody,tfoot,colgroup,scope; (cellspaing及cellpadding的css控制方法: table{border:0;margin:0;border-collapse:collapse;} table th, table td{padding:0;} , base.css文件中我会初始化表格样式) 杜绝使用 兼容ie8; 用png图片做图片时, 要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果, 请为ie6单独定义背景:background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=crop, src=’img/bg.png’); 避免兼容性属性的使用, 比如text-shadow || css3的相关属性; 减少使用影响性能的属性, 比如position:absolute || float ; 必须为大区块样式添加注释, 小区块适量注释; 代码缩进与格式: 建议单行书写, 可根据自身习惯, 后期优化i会统一处理; 命名规则： 头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签页：tab 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guild 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner(二)注释的写法:/ Footer /内容区/ End Footer /(三)id的命名:(1)页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center (2)导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary (3)功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright\\","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://mariogogogo.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"手写一个 compose 实现","slug":"手写一个compose的实现","date":"2017-11-13T16:00:00.000Z","updated":"2020-09-16T09:07:13.000Z","comments":true,"path":"2017/11/14/手写一个compose的实现/","link":"","permalink":"http://mariogogogo.github.io/2017/11/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAcompose%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"创建一个函数,通过把一个函数的输出作为输入发送给另一个函数的方式把两个函数组合起来","text":"创建一个函数,通过把一个函数的输出作为输入发送给另一个函数的方式把两个函数组合起来 实现比如我们要实现输入 jack，smith 我们就要打印出来，‘HELLO，JACK SMITH’ 。 1234var greeting = (firstName, lastName) =&gt; &quot;hello, &quot; + firstName + &quot; &quot; + lastName;var toUpper = str =&gt; str.toUpperCase();var fn = compose(toUpper, greeting);console.log(fn(&quot;jack&quot;, &quot;smith&quot;)); 这就是 compose 大致的使用，总结下来要注意的有以下几点 compose 的参数是函数，返回的也是一个函数 因为除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的 compsoe 函数可以接受任意的参数，所有的参数都是函数，且执行方向是自右向左的，初始函数一定放到参数的最右面 compose 的好处我简单提一下，如果还想再加一个处理函数，不需要修改 fn，只需要在执行一个 compose，比如我们再想加一个 trim，只需要这样做 123var trim = str =&gt; str.trim();var newFn = compose(trim, fn);console.log(newFn(&quot;jack&quot;, &quot;smith&quot;)); 维护和扩展都十分的方便。 简单实现例子分析完了，本着究其根本的原则，还是要探究与一下 compose 到底是如何实现的,javascript 函数式编程的两大类库，lodash.js 和 ramda.js 是如何实现的，其中 ramda.js 实现的过程非常函数式。 我的思路是:compose 返回一个函数,为了记录递归的执行情况，还要记录参数的长度 len,还要给返回的函数添加一个名字 f1。 123456var compose = function(...args) &#123; var len = args.length; return function f1() &#123; //.... &#125;;&#125;; 函数体里面要做的事情就是不断的执行args中的函数，将上一个函数的执行结果作为下一个执行函数的输入参数,需要一个游标count来记录 args 函数列表的执行情况 12345678910111213141516171819202122232425var diy_compose = function(...args) &#123; var len = args.length; var count = len - 1; var result; return function f1(...args1) &#123; console.log(args1); // [0,100], [result:&#x27;100&#x27;] result = args[count].apply(this, args1); //判断如果是最后一个则直接退出 if (count &lt;= 0) &#123; return result; &#125; else &#123; count--; //递归执行f1 return f1.call(null, result); &#125; &#125;;&#125;;const greeting = (x, y) =&gt; &quot;result : &quot; + (x + y);const toUpper = str =&gt; str.toUpperCase();let c = diy_compose(toUpper, greeting);console.log(c(0, 100)); //RESULT : 100 注意compose 函数首先回执行 b,并将 b 的返回值作为参数传递给 a,该函数调用的方向是从右往左(也就是先执行 b,再执行 a) lodash 实现lodash 的思路同上，不过是用迭代实现的，我就把它的源代码贴过来看一下 1234567891011121314151617181920212223242526var flow = function(funcs) &#123; //获取方法参数长度 var length = funcs.length; //记录长度值 var index = length; //递归减减 while (index--) &#123; //如果判断某一个不是方法则输出警告⚠️ if (typeof funcs[index] !== &quot;function&quot;) &#123; throw new TypeError(&quot;Expected a function&quot;); &#125; &#125; return function(...args) &#123; var index = 0; var result = length ? funcs[index].apply(this, args) : args[0]; while (++index &lt; length) &#123; result = funcs[index].call(this, result); &#125; return result; &#125;;&#125;;var flowRight = function(funcs) &#123; //方法参数反转..[fn2,fn1] ===&gt; [fn1,fn2] return flow(funcs.reverse());&#125;; 可以看出，lodash 的本来实现是从左到右的，但也提供了从右到左的 flowRight，还多了一层函数的校验，而且接收的是数组，不是参数序列,而且从这行var result = length ? funcs[index].apply(this, args) : args[0]可以看出允许数组为空，可以看出还是非常严谨的。我写的就缺少这种严谨的异常处理。 参考compose 的实现","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"手写个 bind 实现","slug":"手写一个bind的实现","date":"2017-11-12T16:00:00.000Z","updated":"2020-09-16T09:07:12.000Z","comments":true,"path":"2017/11/13/手写一个bind的实现/","link":"","permalink":"http://mariogogogo.github.io/2017/11/13/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAbind%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"bind 的介绍 bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 首先介绍下区别 第一个返回一个新函数的实现123456789101112131415function func(...arg) &#123; console.log(this.a); console.log(arg);&#125;Function.prototype.customeBind = function(thisArg) &#123; let self = this; return function() &#123; self.apply(thisArg); &#125;;&#125;;let newFunc = func.customeBind(&#123; a: 1 &#125;);newFunc(); //---&gt; this.a // 1 传参的模拟实现12345678910Function.prototype.customeBind = function(thisArg, ...list) &#123; let self = this; return function() &#123; self.apply(thisArg, [...list]); &#125;;&#125;;let newFunc2 = func.customeBind(&#123; a: 1 &#125;, 6, 5, 4, 3, 2, 1);newFunc2(); 原型继承模拟实现123456789101112131415161718192021Function.prototype.customeBind = function(thisArg, ...list) &#123; let self = this; //目标函数 //如果把返回函数当做构造函数 就是找不到目标函数上的方法 //解决:新函数继承目标函数的原型 let NewBind = function() &#123; self.apply(thisArg, [...list]); &#125;; //原型继承: 以某一个对象作为原型创建一个新的对象出来 NewBind.prototype = Object.create(self.prototype); //构造函数（即对象和数组文字）的情况下创建的对象将具有constructor指向该对象的基础对象构造函数类型的属性。 NewBind.prototype.constructor = self; //返回新函数 return NewBind;&#125;;let newFunc2 = func.customeBind(&#123; a: 2 &#125;, 6, 5, 4, 3, 2, 1);newFunc2();let f2 = new newFunc2();console.log(f2); 手写系列 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf 实现一个 bing","categories":[{"name":"手写系列","slug":"手写系列","permalink":"http://mariogogogo.github.io/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://mariogogogo.github.io/tags/JavaScript/"}]},{"title":"JAVASCRIPT 设计模式之寄生式继承","slug":"寄生式继承","date":"2017-10-31T07:13:48.000Z","updated":"2020-12-08T05:57:08.000Z","comments":true,"path":"2017/10/31/寄生式继承/","link":"","permalink":"http://mariogogogo.github.io/2017/10/31/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF/","excerpt":"寄生式继承","text":"寄生式继承 1234567891011121314151617181920212223242526272829function Car(color, price) &#123; var go = &#x27;我是私有的&#x27;; this.color = color; this.price = price; this.getGo = function () &#123; return go; &#125;;&#125;Car.prototype.getCar = function () &#123; console.log(&#x27;颜色&#x27; + this.color);&#125;;function cruze(color, price) &#123; Car.call(this, color, price);&#125;//寄生式继承inherit(Car, cruze);cruze.prototype.test = function () &#123; console.log(&#x27;我是TEST&#x27; + this.color);&#125;;function inherit(father, son) &#123; var _prototype = Object.create(father.prototype); //创建爹的副本 _prototype.construction = son; //更改自己的构造函数 son.prototype = _prototype; //再给自己&#125;//new一下拿别人的属性 call一下拿别人的属性方法var _cruze = new cruze(&#x27;white&#x27;, &#x27;red&#x27;);console.log(_cruze);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"webpack3.10.0使用","slug":"webpack3.10.0使用","date":"2017-10-25T16:00:00.000Z","updated":"2020-09-16T09:07:58.000Z","comments":true,"path":"2017/10/26/webpack3.10.0使用/","link":"","permalink":"http://mariogogogo.github.io/2017/10/26/webpack3.10.0%E4%BD%BF%E7%94%A8/","excerpt":"前端工程师必备技能","text":"前端工程师必备技能 初级入门 yarn add webpack@3.10.0 yarn add html-webpack-plugin@2.30.1 yarn add babel-core,babel-loader babel-preset-env yarn add less css-loader less-loader styke-loader extract-text-webpack-plugin yarn add url-loader file-loader file-laoder在文件大小低于限制时,可以返回一个DataURL 基础配置代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * @Author: mikey.zhaopeng * @Date: 2018-10-28 23:44:17 * @Last Modified by: 马里奥 * @Last Modified time: 2018-10-29 13:02:59 */const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/app.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), //解析目录 filename: &quot;js/app.js&quot; &#125;, module: &#123; rules: [ // react(jsx)语法的处理 &#123; test: /\\.js$/, exclude: /(node_modules)/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; presets: [&quot;env&quot;, &quot;react&quot;] //eev 根据环境打包 &#125; &#125; &#125;, // css文件的处理 &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; //所有入口css 提取出来 fallback: &quot;style-loader&quot;, //必须下style-loader use: &quot;css-loader&quot; &#125;) &#125;, // less文件的处理 &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;less-loader&quot;] &#125;) &#125;, // 图片的配置 &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]&#x27;, options: &#123; name: &#x27;./images&#x27;, &#125;, &#125;, ], &#125;, // 字体图标的配置 &#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: &#x27;url-loader?limit=8192&amp;name=font/[hash:8].[name].[ext]&#x27;, options: &#123; name: &#x27;./font&#x27;, &#125;, &#125;, ], &#125;, &#125;, plugins: [ //处理html文件 new HtmlWebpackPlugin(&#123; template: &quot;./src/index.html&quot; &#125;), // // 独立css文件 new ExtractTextPlugin(&quot;css/[name].css&quot;), // 提出公共模块 new webpack.optimize.CommonsChunkPlugin(&#123; name: &quot;common&quot;, filename: &quot;js/base.js&quot; &#125;) ], devServer: &#123; port: 8086, historyApiFallback: &#123; index: &quot;/dist/index.html&quot;, //404 或招不到则返回首页 favicon: &#x27;./favicon.ico&#x27; //必须在更目录放一张ico图片 &#125;, open: true, //自动打开浏览器 proxy: &#123; &quot;/manage&quot;: &#123; target: &quot;http://admintest.happymmall.com&quot;, //选择请求代理 changeOrigin: true &#125;, &quot;/user/logout.do&quot;: &#123; target: &quot;http://admintest.happymmall.com&quot;, changeOrigin: true &#125; &#125; &#125;&#125;; 图片配置中有一个错误的地方纠正会出现 http://xxx.xx.com/css/image/1.jpg; 正确的网址 应该是 http://xxx.xx.com/image/1.jpg; 为什么会多一个css可能css-loade解析时候没有配置输出路径 解决:12345678910111213141516171819202122232425// 图片的配置 &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &quot;url-loader?limit=819200&amp;name=images/[hash:8].[name].[ext]&quot;, options: &#123; name: &quot;./images&quot; &#125; &#125; ] &#125;, // 字体图标的配置 &#123; test: /\\.(eot|svg|ttf|woff|woff2|otf)$/, use: [ &#123; loader: &quot;url-loader?limit=819200&amp;name=fonts/[hash:8].[name].[ext]&quot;, options: &#123; name: &quot;./fonts&quot; &#125; &#125; ] &#125; 进阶","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://mariogogogo.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://mariogogogo.github.io/tags/webpack/"}]},{"title":"引用类型和值类型","slug":"引用类型和值类型","date":"2017-10-24T07:13:48.000Z","updated":"2020-09-16T09:07:16.000Z","comments":true,"path":"2017/10/24/引用类型和值类型/","link":"","permalink":"http://mariogogogo.github.io/2017/10/24/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"每种数据类型的内存分配","text":"每种数据类型的内存分配 值类型内存分配 123456function chainStore() &#123; var store1 = &quot;Nike China&quot;; var store2 = store1; store1 = &quot;Nike U.S.A.&quot;; alert(store2);&#125; 123456var str1; //这个时候不进行内存分配var str2 = &quot;传智播客&quot;; //分配内存var str3 = str2;console.log(str1);console.log(str2 == str3); //比较的是指针指向的内存空间中存储的值console.log(str2 === str3); //比较的是地址和地址中存储的值 把一个值类型（也可以叫基本类型）store2 传递给另一个变量（赋值）时，其实是分配了一块新的内存空间，因此改变 store1 的值对 store2 没有任何影响，因为它不像引用类型，变量的交换其实是交换了指像同一个内容的地址。 引用类型内存分配型 对象是引用类型，赋值只是生成一个内存保存地址而已var y = x;如果变量 x 表示一个对象.则通过赋值后,y 生成一个变量,变量包含一个地址,地址指向对象 x.所以从本质上而言,不会生成新的变量, x,y 指向内存中的同一位置当你通过 y 改变对象的值，这种变化也会反映到 x 上。 在上面的代码中，store2 只进行了一次赋值，理论上它的值已定，但后面通过改写 store1 的值，发现 store2 的值也发生了改变，这正是引用类型的特征，也是我们要注意的地方。 引用类型和值类型区别 内存分配机制不一样 引用类型—创建一个变量—内存中保存的是变量真实入口的地址 值类型：创建一个变量，内存创建一个区域 说白了就是引用类型会分配两个区域：一个保存地址，一个保存内容 变量赋值是否的区别 将一个值类型赋值给另一个变量，实际上新创建一个区域 引用类型，只是创建一个区域，保存另一个变量的入口地址 值类型赋值，会重新分配内存 引用类型赋值其实赋的是指针","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"数据类型判断的几种方式","slug":"数据类型判断的几种方式","date":"2017-10-23T07:13:48.000Z","updated":"2020-09-16T09:07:14.000Z","comments":true,"path":"2017/10/23/数据类型判断的几种方式/","link":"","permalink":"http://mariogogogo.github.io/2017/10/23/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"如何判断数据类型？？基础数据类型的判断几种方式","text":"如何判断数据类型？？基础数据类型的判断几种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var num = 1;var str = &quot;传智播客&quot;;var bool = false;var arr = [];var obj = &#123; name: &quot;传智播客&quot; &#125;;var date = new Date();var fn = function() &#123;&#125;;/****************************************************************************** 数据类型判断 - typeof *******************************************************************************/console.log(&quot;数据类型判断 - typeof&quot;);console.log(typeof undefined); //&#x27;undefined&#x27;console.log(typeof null); // well-known bugconsole.log(typeof true); //&#x27;boolean&#x27;console.log(typeof 123); //&#x27;number&#x27;console.log(typeof &quot;abc&quot;); //&#x27;string&#x27;console.log(typeof function() &#123;&#125;); //&#x27;function&#x27;var arr = [];console.log(typeof &#123;&#125;); //&#x27;object&#x27;console.log(typeof arr); //&#x27;object&#x27;console.log(typeof unknownVariable); //&#x27;undefined&#x27;// 在使用 typeof 运算符时采用引用类型存储值会出现一个问题，// 无论引用的是什么类型的对象，它都返回 &quot;object&quot;。/****************************************************************************** 数据类型判断 - toString.call 通用但很繁琐的方法： prototype *******************************************************************************/console.log(&quot;数据类型判断 - toString.call&quot;);console.log(toString.call(123)); //[object Number]console.log(toString.call(&quot;123&quot;)); //[object String]console.log(toString.call(undefined)); //[object Undefined]console.log(toString.call(true)); //[object Boolean]console.log(toString.call(&#123;&#125;)); //[object Object]console.log(toString.call([])); //[object Array]console.log(toString.call(function() &#123;&#125;)); //[object Function]console.log(Object.prototype.toString.call(str) === &quot;[object String]&quot;); //-------&gt; true;console.log(Object.prototype.toString.call(num) === &quot;[object Number]&quot;); //-------&gt; true;console.log(Object.prototype.toString.call(arr) === &quot;[object Array]&quot;); //-------&gt; true;console.log(Object.prototype.toString.call(date) === &quot;[object Date]&quot;); //-------&gt; true;console.log(Object.prototype.toString.call(fn) === &quot;[object Function]&quot;); //-------&gt; true;/****************************************************************************** 数据类型判断 - instanceof *******************************************************************************/// 判断已知对象类型实例化的方法： instanceofconsole.log(&quot;数据类型判断 - instanceof&quot;);console.log(arr instanceof Array); //---------------&gt; trueconsole.log(date instanceof Date); //---------------&gt; trueconsole.log(fn instanceof Function); //------------&gt; true// alert(f instanceof function) //------------&gt; false// 注意：instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。/****************************************************************************** 数据类型判断 - 根据对象的constructor判断： constructor *******************************************************************************/// 根据对象的constructor判断： constructorvar arr = [];console.log(&quot;数据类型判断 - constructor&quot;);console.log(arr.constructor === Array); //----------&gt; trueconsole.log(date.constructor === Date); //-----------&gt; trueconsole.log(fn.constructor === Function); //-------&gt; true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JAVASCRIPT设计模式之原型继承","slug":"Javascript设计模式之原型继承","date":"2017-09-22T07:13:48.000Z","updated":"2020-09-16T09:07:36.000Z","comments":true,"path":"2017/09/22/Javascript设计模式之原型继承/","link":"","permalink":"http://mariogogogo.github.io/2017/09/22/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/","excerpt":"涉及到多个对象，我们通过原型模式来实现对新对象的创建","text":"涉及到多个对象，我们通过原型模式来实现对新对象的创建 代码12345678910111213141516171819202122232425262728293031323334353637//涉及到多个对象，我们通过原型模式来实现对新对象的创建 function prototypeExtend() &#123; //缓存类 为了实例化返回对象临时创建 跟临时变量性质差不多 var F = function() &#123;&#125;, args = arguments, i = 0, len = args.length; for (; i &lt; len; i++) &#123; //遍历每一个对象的属性 for (var j in args[i]) &#123; //属性缓存在缓存类型中 F.prototype[j] = args[i][j]; &#125; &#125; //返回一个实例 return new F(); &#125; var penguin = prototypeExtend(&#123; speed: 20, swim: function() &#123; console.log(&quot;速度&quot; + this.speed); &#125; &#125;, &#123; run: function(speed) &#123; console.log(&#x27;跑步速度&#x27; + speed); &#125; &#125;, &#123; jump: function() &#123; console.log(&#x27;跳跃动作&#x27;); &#125; &#125;) penguin.swim(); penguin.run(10); penguin.jump();","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之原型模式","slug":"Javascript设计模式之原型模式","date":"2017-09-21T07:13:48.000Z","updated":"2020-09-16T09:07:36.000Z","comments":true,"path":"2017/09/21/Javascript设计模式之原型模式/","link":"","permalink":"http://mariogogogo.github.io/2017/09/21/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"项目经理要求：页面中有很多焦点图 每个焦点图的实现方式不一样，左右切换 上下切换","text":"项目经理要求：页面中有很多焦点图 每个焦点图的实现方式不一样，左右切换 上下切换 传统写法1234567891011121314151617181920212223242526272829var LoopImages = function(imgArr, container) &#123; this.imagesArray = imgArr; //轮播图数组 this.container = container; //轮播图容器 this.creatImage = function() &#123;&#125; //创建轮播图片 this.changeImage = function() &#123;&#125; //厂家切换下一张图片 &#125; //写一个上下切换的类 var SlidLoopImage = function(imgArr, container) &#123; LoopImages.call(this, imgArr, container); this.changeImage = function() &#123; console.log(&#x27;这里显示的上下切换效果&#x27;); &#125; &#125; //渐隐渐显得切换 var FadeLoopImage = function(imgArr, container, arrow) &#123; LoopImages.call(this, imgArr, container); //切换箭头的私有变量 this.arrow = arrow; this.changeImage = function() &#123; console.log(&#x27;这里显示的是渐隐渐显得切换&#x27;); &#125; &#125; //一个数组 一个容器 一个懒 var fadeImage = new FadeLoopImage( [&#x27;1.jpg&#x27;, &#x27;2.jpg&#x27;, &#x27;3,jpg&#x27;], &#x27;slider&#x27;, [&#x27;left.jpg&#x27;, &#x27;right.jpg&#x27;] ); fadeImage.changeImage(); 改进写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var LoopImages = function(imgArr, container) &#123; this.imagesArray = imgArr; //数组 this.container = container; //容器 &#125; LoopImages.prototype = &#123; creatImage: function() &#123; console.log(&#x27;这里存照片&#x27;); &#125;, changeImage: function() &#123; console.log(&#x27;这里显示切换下一张照片&#x27;); &#125; &#125; //上下切换类 var SlidLoopImage = function(imgArr, container) &#123; LoopImages.call(this, imgArr, container); &#125; SlidLoopImage.prototype = new LoopImages(); SlidLoopImage.prototype.changeImage = function() &#123; console.log(&#x27;这里重写继承切换下一张图片方法&#x27;); &#125; //左右切换类 var FadeLoopImage = function(imgArr, container, arrow) &#123; LoopImages.call(this, imgArr, container); this.arrow = arrow; &#125; FadeLoopImage.prototype = new LoopImages(); FadeLoopImage.prototype.changeImage = function() &#123; console.log(&#x27;这里显示的是重写左右切换方法&#x27;); &#125; //测试用例 console.log(fadeImage.container); fadeImage.changeImage(); //原型扩展 //原型对象是一个共享对象 父类的实例对象或者子类的继承；都是它的一个指向 //任何时候对基类伙子子类进行方法的扩展 LoopImages.prototype.getImageLength = function() &#123; return this.imagesArray.length; &#125; FadeLoopImage.prototype.getContainer = function() &#123; return this.container; &#125; console.log(fadeImage.getImageLength); //获取它的新方法 console.log(fadeImage.getContainer);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之建造者模式","slug":"Javascript设计模式之建造者模式","date":"2017-09-20T07:13:48.000Z","updated":"2020-09-16T09:07:35.000Z","comments":true,"path":"2017/09/20/Javascript设计模式之建造者模式/","link":"","permalink":"http://mariogogogo.github.io/2017/09/20/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"需求分析：发布简历 种类多目的为了创建对象，更关心创造这个对象的整个过程","text":"需求分析：发布简历 种类多目的为了创建对象，更关心创造这个对象的整个过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var Human = function(param) &#123; this.skill = param &amp;&amp; param.skill || &#x27;保密&#x27;; this.hobby = param &amp;&amp; param.hobby || &#x27;保密&#x27;; &#125;; Human.prototype = &#123; getSkill: function() &#123; return this.skill; &#125;, getHobby: function() &#123; return this.hobby; &#125; &#125;; //抽象出姓名解析类 //实例化一个姓名 var Name = function(name) &#123; var that = this; (function(name, that) &#123; that.wholeName = name; if (name.indexOf(&quot; &quot;) &gt; -1) &#123; that.FirstName = name.slice(0, name.indexOf(&quot; &quot;)); that.SecondName = name.slice(name.indexOf(&quot; &quot;)); &#125; &#125;)(name, that) &#125;; //抽象出期望职位类 var Work = function(work) &#123; var that = this; (function(work, that) &#123; switch (work) &#123; case &#x27;code&#x27;: that.work = &#x27;工程师&#x27;; that.workDescript = &#x27;每天喜欢编程&#x27;; break; case &#x27;UI&#x27;: that.work = &#x27;设计师&#x27;; that.workDescript = &#x27;每天喜欢设计&#x27;; break; case &#x27;teach&#x27;: that.work = &#x27;教师&#x27;; that.workDescript = &#x27;每天喜欢看书&#x27;; break; default: that.work = work; that.workDescript = &#x27;对不起，我们不清楚你的职业&#x27;; &#125; &#125;)(work, that) Work.prototype.changeWork = function(work) &#123; this.work = work; &#125; Work.prototype.changeDes = function(setence) &#123; this.workDescript = setence; &#125; &#125; /**** * 建造者 * * ***/ var Person = function(name, work) &#123; var _person = new Human(); _person.name = new Name(name); _person.work = new Work(work); return _person; &#125; var person = new Person(&quot;jack chan&quot;, &quot;code&quot;); console.log(person.skill);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之给我一张名片工厂模式","slug":"Javascript设计模式之给我一张名片工厂模式","date":"2017-09-19T07:13:48.000Z","updated":"2020-09-16T09:07:35.000Z","comments":true,"path":"2017/09/19/Javascript设计模式之给我一张名片工厂模式/","link":"","permalink":"http://mariogogogo.github.io/2017/09/19/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%99%E6%88%91%E4%B8%80%E5%BC%A0%E5%90%8D%E7%89%87%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"项目经理要求小白做一个需求投放各式各样的广告需求总在变如何应对？","text":"项目经理要求小白做一个需求投放各式各样的广告需求总在变如何应对？ 传统写法1234567891011121314151617181920212223242526272829303132var Java = function(content) &#123; this.content = content; //闭包执行 (function(content) &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = content; div.style.color = &quot;pink&quot;; document.getElementById(&#x27;container&#x27;).appendChild(div); &#125;)(content);&#125;var Php = function(content) &#123; this.content = content; //闭包执行 (function(content) &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = content; div.style.color = &quot;yellow&quot;; document.getElementById(&#x27;container&#x27;).appendChild(div); &#125;)(content); &#125; //工厂模式function JobFactory(type, content) &#123; switch (type) &#123; case &#x27;Java&#x27;: return new Java(content); break; case &#x27;Php&#x27;: return new Php(content); break; &#125;&#125; 改进写法12345678910111213141516171819202122232425262728293031323334353637383940414243var Factory = function(type, content) &#123; //运用安全模式 判断是否为new创建的对象 if (this instanceof Factory) &#123; var s = new this[type](content); return s; &#125; else &#123; return new Factory(type, content); &#125;&#125;Factory.prototype = &#123; Java: function(content) &#123; this.content = content; //闭包执行 (function(content) &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = content; div.style.color = &quot;skyblue&quot;; document.getElementById(&#x27;container&#x27;).appendChild(div); &#125;)(content); &#125;, Php: function(content) &#123; this.content = content; //闭包执行 (function(content) &#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = content; div.style.color = &quot;red&quot;; document.getElementById(&#x27;container&#x27;).appendChild(div); &#125;)(content); &#125;&#125;;var data = [&#123; type: &#x27;Java&#x27;, content: &quot;Java开发哪家强&quot;&#125;, &#123; type: &#x27;Php&#x27;, content: &quot;Php开发哪家强&quot;&#125;];for (var i = 0; i &lt; data.length; i++) &#123; Factory(data[i].type, data[i].content);&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之简单工厂模式","slug":"Javascript设计模式型之简单工厂模式","date":"2017-09-18T07:13:48.000Z","updated":"2020-09-16T09:07:33.000Z","comments":true,"path":"2017/09/18/Javascript设计模式型之简单工厂模式/","link":"","permalink":"http://mariogogogo.github.io/2017/09/18/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9E%8B%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"需求登陆模块用户输入框需求：有多种提示框，如确认框，警告框，输入框；","text":"需求登陆模块用户输入框需求：有多种提示框，如确认框，警告框，输入框； 传统写法123456789101112131415161718192021//传统的写法var LoginAlert = function(text) &#123; this.content = text;&#125;LoginAlert.prototype.show = function() &#123; //显示&#125;var userNameAlert = new LoginAlert(&#x27;用户名不能多于16个字母或者数字&#x27;)userNameAlert.show();var passwordAlert = new LoginAlert(&#x27;输入的密码不正确&#x27;);passwordAlert.show();//多一个按钮的提示框var LoginPrompt = function(text) &#123; this.content = text;&#125;LoginPrompt.prototype.show = function() &#123; //显示&#125;var userLoginPrompt = new LoginPrompt(&quot;今天的心气是&quot;);userLoginPrompt.show(); 改进写法1234567891011121314151617181920212223242526function creatPop(type, text) &#123; var num; var o = new Object(); o.content = text; o.show = function() &#123; //显示 //显示通用样式 alert(num + text); &#125;; if (type == &quot;alert&quot;) &#123; num = 1; //只显示一个按钮 &#125; if (type == &quot;prompt&quot;) &#123; //添加多一个输入框 &#125; if (type == &quot;confirm&quot;) &#123; //添加多一个输入框和一个按钮 &#125; return o; &#125; var userNameAlert = creatPop(&#x27;alert&#x27;, &quot;用户名只能6个字母或数字&quot;); userNameAlert.show(); var userNamePrompt= creatPop(&#x27;prompt&#x27;, &quot;用户名姓名&quot;); userNamePrompt.show();","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之找个检察长","slug":"Javascript设计模式之找个检察长","date":"2017-09-17T07:13:48.000Z","updated":"2020-09-16T09:07:37.000Z","comments":true,"path":"2017/09/17/Javascript设计模式之找个检察长/","link":"","permalink":"http://mariogogogo.github.io/2017/09/17/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%89%BE%E4%B8%AA%E6%A3%80%E5%AF%9F%E9%95%BF/","excerpt":"new的含义new的作用就是对当前对象的this的不断赋值，如果没有new，就会执行函数，这个函数在全局作用域执行，所以this指向对象自然是全局变量 window；book变量得不到Book这个类执行，所以undefined；","text":"new的含义new的作用就是对当前对象的this的不断赋值，如果没有new，就会执行函数，这个函数在全局作用域执行，所以this指向对象自然是全局变量 window；book变量得不到Book这个类执行，所以undefined； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//利用闭包来实现 var Book = (function() &#123; //静态私有变量 var bookNum = 0; //静态私有方法 外部不可访问 function checkBook(name) &#123; alert(name) &#125;; //创建类 function _book(id, name, price) &#123; var name, price; //特权方法 this.getName = function() &#123;&#125;; this.getPrice = function() &#123;&#125;; this.setName = function() &#123;&#125;; this.setPrice = function() &#123;&#125;; this.id = id; this.copy = function() &#123;&#125;; bookNum++; if (bookNum &gt; 100) &#123; throw new Error(&quot;出错了！&quot;) &#125; this.setName(name); this.setPrice(price) &#125; _book.prototype = &#123; isJsBook: false, display: function() &#123;&#125; &#125; return _book; &#125;)() var b = new Book(11,&quot;javascript&quot;,40); console.log(b.bookNum); //--&gt;undefined console.log(b.isJsBook); //--&gt;false console.log(b.id); //--&gt;11// console.log(b.checkBook(&quot;jack&quot;)); //--&gt; b.checkBook is not a function var Book0 = function(title, time, type)&#123; this.title = title; this.time = time; this.type = type; &#125; var book0 = Book0(112, &quot;css&quot;, 40); console.log(book0); //--&gt;undefined 没有new实例化 console.log(window.title); //--&gt;112 //去找检察长判定是否实例化 var Book1 = function(tit, time, type) &#123; if (this instanceof Book) &#123; this.tit = tit; this.time = time; this.type = type; &#125; else &#123; return new Book1(tit, time, type); &#125; &#125; var book1 = Book1(12, &quot;javascript&quot;, 40); console.log(book1); console.log(book1.tit); console.log(window.tit); //--&gt;undefined","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT设计模式之封装明星","slug":"Javascript设计模式之封装明星","date":"2017-09-16T07:13:48.000Z","updated":"2020-09-16T09:07:35.000Z","comments":true,"path":"2017/09/16/Javascript设计模式之封装明星/","link":"","permalink":"http://mariogogogo.github.io/2017/09/16/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B0%81%E8%A3%85%E6%98%8E%E6%98%9F/","excerpt":"面向对象是思想","text":"面向对象是思想 举个栗子1234567var Book = function(id, name, price)&#123; this.id =id; &#125; Book.prototype =&#123; display:function()&#123;&#125; &#125; 问题：通过this添加的属性和方法与通过prototype添加的属性和方法有什么区别？ 通过this添加时在当前对象上添加的，每创建一个对象。它都有一个原型prototype指向其继承的属性方法，这样通过prototype继承的方法并不是自身，this的属性和方法是自身拥有，每次通过类创建一个新对象指向自身属性和方法而通过prototype继承通过类创建属性和方法不会再次创建 constructor是什么？在prototype对象中会出现一个和函数创建this一样的一个constructor属性constructor属性指向就是拥有这个原型对象的函数或对象 代码12345678910111213141516171819202122232425262728293031323334353637var Book = function(id, name, price) &#123; //私有属性不可通过实例化点语法访问 var num = 1; function checkId() &#123;&#125;; this.getName = function() &#123;&#125;; this.getPrice = function() &#123;&#125;; this.setName = function () &#123;&#125;; this.setPrice = function () &#123;&#125;; //公有属性 this.id = id; //公有方法 this.copy = function() &#123;&#125;; this.setName(name); this.setPrice(price); &#125; //静态公有属性 Book.isChinese = true; //静态公有方法 Book.resetTime = function() &#123; console.log(&quot;new Time&quot;); &#125; //公有属性与方法 Book.prototype = &#123; isJsBook: false, display: function()&#123;&#125; &#125;; var b = new Book(11, &quot;javascript&quot;, 50); console.log(b.num); //--&gt; undefined console.log(b.isJsBook); //--&gt;false console.log(b.id); //--&gt;11 console.log(b.isChinese); //--&gt;undefined //类的静态公有属性通过类自身来访问 console.log(Book.isChinese); //--&gt;true console.log(Book.resetTime()); // --&gt;new Time","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT学习笔记之数组对象知识点总结","slug":"JAVASCRIPT学习笔记之数组对象知识点总结","date":"2017-09-14T08:13:48.000Z","updated":"2020-09-16T09:07:37.000Z","comments":true,"path":"2017/09/14/JAVASCRIPT学习笔记之数组对象知识点总结/","link":"","permalink":"http://mariogogogo.github.io/2017/09/14/JAVASCRIPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"数组对象是使用单独的变量名来存储一系列的值；数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值；数组中的每个元素都有自己的的ID索引，以便它可以很容易地被访问到……","text":"数组对象是使用单独的变量名来存储一系列的值；数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值；数组中的每个元素都有自己的的ID索引，以便它可以很容易地被访问到……JavaScript数组元素可以是不同的变量类型。数组元素可以是字符串，可以是对象元素，可以是函数，也可以说是另一个数组…… JavaScript Array对象属性有constructor（引用数组对象的构造函数），length（返回数组的长度），prototype(增加属性或方法扩展数组定义)。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;数组对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [1,3,1,4,0,null,&quot;&quot;,undefined]; var arr2 = [1,2,null]; console.log(arr.toString()); //--&gt;&quot;1,3,1,4,0,,,&quot; console.log(arr.valueOf());//--&gt;Array [ 1, 3, 1, 4, 0, null, &quot;&quot;, undefined ] console.log(arr.concat(arr2));//--&gt;Array [ 1, 3, 1, 4, 0, null, &quot;&quot;, undefined, 1, 2, 多于 1… ] console.log(arr.reverse())//--&gt;Array [ undefined, &quot;&quot;, null, 0, 4, 1, 3, 1 ] console.log(arr.splice(1,3));//--&gt;Array [ &quot;&quot;, null, 0 ] console.log(arr2.slice(1, 2));//--&gt;Array [ 2 ] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"DOM","slug":"DOM","permalink":"http://mariogogogo.github.io/tags/DOM/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Javascript设计模式学习之前要了解这些","slug":"Javascript设计模式学习之前要了解这些","date":"2017-09-14T07:13:48.000Z","updated":"2020-09-16T09:07:34.000Z","comments":true,"path":"2017/09/14/Javascript设计模式学习之前要了解这些/","link":"","permalink":"http://mariogogogo.github.io/2017/09/14/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%89%8D%E8%A6%81%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B/","excerpt":"","text":"我们刚进入公司都是小白，某天公司项目经理给让做一个表单验证 90%的你会做这样的传统的面相过程编程12345678910111213//传统面相过程 function checkName(argument) &#123; // body... &#125; function checkEmail(argument) &#123; // body... &#125; function checkPwd(argument) &#123; // body... &#125;缺点：设置了很多全局变量，不利于团队开发 因为这跟下面的变量名提前在function没有区别？ 1234var checkName = function()&#123; //验证姓名&#125; 如果团队中有人跟你用了同一个变量名定义了方法那你的方法就被覆盖了 我们一步一步优化：先看看用对象收编变量的方法试试 1234567var CheckObject = function () &#123;&#125;CheckObject.checkName = function() &#123; console.log(&#x27;检查姓名&#x27;);&#125;var a = CheckObject.checkName();console.log(a); 这样也有缺点：当别人想用你代码的时候比较麻烦，这个对象不能复制一份或者说这个对象new出来的新对象，新对象中没有继承这些新方法 1234// 被new之后方法 新建对象内部没有方法var b = new CheckObject();// console.log(b.checkName()); //index.js:18 Uncaught TypeError: b.checkName is not a function 类也可以所以我们应该添加this关键字 12345678910111213var CheckObject = function () &#123; this.checkName = function()&#123; console.log(&#x27;new检查姓名&#x27;); &#125; &#125; var a2 = new CheckObject();console.log(a2);//CheckObject &#123;checkName: ƒ&#125;// checkName: ƒ()// __proto__: Object console.log(a2.checkName()); 但这个还是有一点缺点：我们把所有方法都放在函数内部，通过this定义，所以每一次通过new关键词来创建新对象，this上的属性进行复制，然而有时候这样的方法创建造成的性能消耗是很奢侈的 123456789101112131415161718192021/********************************* *//*************检查 */ var CheckObject = function() &#123;&#125; CheckObject.prototype = &#123; checkName:function()&#123; console.log(&#x27;检查姓名new&#x27;); &#125;, checkAge : function() &#123; console.log(&#x27;检查年龄new&#x27;); &#125;, checkSex :function()&#123; console.log(&#x27;检查性别new&#x27;); &#125; &#125; var c = new CheckObject(); c.checkName(); c.checkAge(); c.checkSex(); 这样创建出来的对象实例所拥有的方法就只有一个了，因为他们都要在prototype原型依次寻找，找到都是同一个 方法还可以链式调用如果对a写三遍调用也太麻烦了所以我们用this做返回，因为this指向的就是当前对象 1234567891011121314151617181920var CheckObject = function () &#123; &#125; CheckObject.prototype = &#123; checkName: function () &#123; console.log(&#x27;检查姓名new&#x27;); console.log(this); return this //返回当前对象 &#125;, checkAge: function () &#123; console.log(&#x27;检查年龄new&#x27;); return this; &#125;, checkSex: function () &#123; console.log(&#x27;检查性别new&#x27;); return this; &#125;&#125;var d = new CheckObject();d.checkName().checkSex().checkSex(); 函数的祖先12345Function.prototype.addMethod = function(name,fn)&#123; this[name] = fn; return this;&#125; 最后举一个简单栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单验证需求&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 需求说明：给表单提交填写验证码校验方法 &lt;/div&gt; 用户名： &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;name&quot;&gt; 邮箱： &lt;input type=&quot;email&quot; value=&quot;&quot;&gt; 密码： &lt;input type=&quot;text&quot; value=&quot;&quot; maxlength=&quot;11&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot;&gt; &lt;script&gt; window.onload = function() &#123; var name = document.getElementsByTagName(&quot;input&quot;)[0]; var email = document.getElementsByTagName(&quot;input&quot;)[1]; var pwd = document.getElementsByTagName(&quot;input&quot;)[2]; var btn = document.getElementsByTagName(&quot;input&quot;)[3]; btn.onclick = function() &#123; //运行 var nameVal = name.value; console.log(nameVal); var emailVal = email.value; var pwdVal = pwd.value; method.checkName(nameVal).checkEmail(emailVal).checkPwd(pwdVal); &#125; &#125; //原型连上添加方法 避免全局污染 Function.prototype.addMethod = function(name, fn) &#123; // body... this[name] = fn; &#125; var method = new Function(); method.addMethod(&quot;checkName&quot;, function(str) &#123; if (!str) &#123; alert(&#x27;用户名不能为空&#x27;); &#125; else if (str.length &lt; 6) &#123; alert(&#x27;用户名长度大于6&#x27;); &#125; else &#123; return this; &#125; &#125;) method.addMethod(&quot;checkEmail&quot;, function(str) &#123; if (!str) &#123; alert(&#x27;这是验证邮箱&#x27;); &#125; else &#123; return this; &#125; &#125;) method.addMethod(&quot;checkPwd&quot;, function(str) &#123; if (!str) &#123; alert(&#x27;这是输入验证密码&#x27;); &#125; else if (str.length &lt; 6) &#123; alert(&#x27;这是大于6位验证密码&#x27;); &#125; else &#123; return this; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://mariogogogo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JAVASCRIPT学习笔记之DOM知识点总结","slug":"Javascript学习笔记之DOM知识点总结","date":"2017-09-13T07:13:48.000Z","updated":"2020-09-16T09:07:37.000Z","comments":true,"path":"2017/09/13/Javascript学习笔记之DOM知识点总结/","link":"","permalink":"http://mariogogogo.github.io/2017/09/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BDOM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"JavaScript的window对象对应着浏览器窗口本身，因此这个对象的属性和方法统称为BOM（浏览器对象模型），如window.open(),window.location等。","text":"JavaScript的window对象对应着浏览器窗口本身，因此这个对象的属性和方法统称为BOM（浏览器对象模型），如window.open(),window.location等。 JavaScript的document对象是指文档对象模型，主要是处理网页内容。DOM（Document Object Model）即文档对象模型，是针对 HTML 和 XML 文档的 API 。字母D指document（文档），字母O指object（对象），字母指Model（模型）。DOM 描绘了一个层次化的节点树。节点表示一个连接点，文档是由节点构成的集合，DOM的节点主要分为三类：元素节点、文本节点（不是文本内容）、属性节点。 获取节点的名称和类型nodeName属性用来获取节点的名称，文本节点返回#text,元素节点返回标签名称（此时等价于tagName）。语法：目标节点.nodeName nodeType属性用来获取节点的类型，元素节点：1，属性节点：2，文本节点：3。语法：目标节点.nodeTypenodeValue属性用来获取和设置节点的值。元素节点返回 null 。语法：目标节点.nodeValue 获取元素节点的方式document.getElementById 通过ID查找，返回唯一元素节点 document.getElementsByName 通过表单元素name属性查找，返回元素节点数组 document.getElementsByTagName 通过标签名称查找，返回元素节点数组以下三种方法属于HTML5 DOM，并非所有浏览器支持（如某些低版本IE就不支持），属于高级方法 document.getElementsByClassName 通过class属性的类名查找，返回元素节点数组 document.querySelector通过selector条件获取元素节点，只返回符合条件的第一个元素节点document.querySelectorAll通过selector条件获取元素节点，返回所有符合条件的元素节点数组，多条件使用逗号分隔，表示要查找的元素必须符合所有逗号分隔的条件，如果一个元素只符合逗号分隔的条件中的一个，则不会被返回 小结： getElementById和querySelector只返回一个元素节点，而getElementsByName、getElementsByTagName、getElementsByClassName、querySelectorAll返回的是元素节点(类)数组 节点指针childNodes属性用来获取元素节点的子节点，返回节点数组。语法：父节点.childNodes; children属性可以用来获取忽略了空白节点的有效节点（在某些浏览器上，空白符或换行符也是一个文本节点）。语法：父节点.children; firstChild属性可以用来获取元素的第一个子节点，等价于 childNodes[0]。语法：父节点.firstChild; lastChild属性可以用来获取元素的最后一个子节点，等价于 childNodes[childNodes.length-1]。语法：父节点.lastChild; previousSibling属性用来获取目标节点的前一个兄弟节点。语法：目标节点.previousSibling; nextSibling属性用来获取目标节点的后一个兄弟节点。语法：目标节点.nextSibling; parentNode属性用来获取已知节点的父节点。语法：子节点.parentNode; ownerDocument属性用来当前节点所在文档的根节点，等价于document。语法：目标节点.ownerDocument; 节点的操作createElement方法用来创建元素节点。语法：document.createElement(‘元素标签名称’); createAttribute方法用来创建属性节点。语法：document.createAttribute(‘属性名称’); createTextNode方法用来创建文本节点。语法：document.createTextNode(‘文本内容’); appendChild方法用来在目标节点的子节点的末尾添加一个子节点（可以是createElement创建的元素节点，也可以是createTextNode创建的文本节点）。语法：parent.appendChild(要插入的节点); insertBefore方法用来在目标元素的前面插入一个新元素节点，此时的指针在目标元素的父级上。语法：parent.insertBefore(newElement,targetElement); DOM中没有insertAfter这个方法，但是可以通过以下方法来模拟insertAfter;/* newElement : 要插入的新元素 targetElement : 目标元素*/ 12345678910111213141516function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild == targetElement)&#123; /* 如果目标元素是parent的最后一个子元素，则把新元素追加到parent元素上， 也就是在parent的子元素的末尾位置添加新元素 */ parent.appendChild(newElement); &#125;else&#123; /* 否则，就把新元素添加到目标元素和目标元素的下一个兄弟元素之间 */ parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; replaceChild方法用来替换一个元素节点，此时的指针在目标元素的父级上。语法：parent.replaceChild(replaceElement,targetElement); cloneChild方法用来克隆一个元素节点，传递一个布尔参数，参数为true时表示复制当前节点及其所有子节点，参数为false时表示支付至当前节点。语法：目标元素.cloneChild(true|false); removeChild方法用来删除一个指定节点。语法：removeChild(要删除的节点); getAttribute方法用来获取一个属性的值。语法：目标元素.getAttribute(元素属性名称); setAttribute方法用来设置一个属性的值，没有该属性则创建。语法：目标元素.setAttribute(元素属性名称,属性值); removeAttribute方法用来删除一个属性节点。语法：目标元素.removeAttribute(要删除的属性名称); DOM操作内容style属性用来获取和设置元素的行内样式。语法：element.style;style属性只能获取和设置行内样式，对于如font-size这种样式属性，应该去掉 - 并且将 - 后面的第一个字母大写，驼峰法来获取和设置 如：element.style.fontSize , element.style.backgroundColor getComputedStyle全局方法用来获取计算后的样式，第一个参数是元素节点，第二个参数是类型，如:hover,:active等伪类，默认情况下传 null ,某些IE版本使用currentStyle属性来获取 box.currentStyle。语法：window.getComputedStyle(元素，类型) className属性用来获取和设置元素的样式名称。语法：element.className自定义的 addClass() | hasClass() | removeClass() 方法 123456789101112131415161718192021//元素是否含有某样式function hasClass(element,className)&#123; return !!element.className.match(new RegExp(&#x27;(\\\\s|^)&#x27;+className+&#x27;(\\\\s|$)&#x27;));&#125;//向元素添加新样式function addClass(element,className)&#123; if(hasClass(element,className) == false)&#123; element.className += &#x27; &#x27;+className; &#125; &#125;//移除元素的指定样式function removeClass(element,className)&#123; var currentClass = element.className; if(hasClass(element,className))&#123; currentClass = currentClass.replace(new RegExp(&#x27;(\\\\s|^)&#x27;+className+&#x27;(\\\\s|$)&#x27;),&#x27; &#x27;); //去除空格 currentClass = currentClass.replace(/(^\\s*)|(\\s*$)/g,&#x27;&#x27;); element.className = currentClass; &#125;&#125; OM操作位置和大小clientWidth属性用来获取元素的实际宽度，该值受滚动条和内边距影响，外边距和border不会影响。语法：element.clientWidth; clientHeight属性用来获取元素的实际高度，该值受滚动条和内边距影响，外边距和border不会影响。语法：element.clientHeight; offsetWidth属性用来获取元素的实际宽度，该值受边框和内边距影响，外边距和滚动条不会影响。语法：element.offsetWidth; offsetHeight属性用来获取元素的实际高度，该值受边框和内边距影响，外边距和滚动条不会影响。语法：element.offsetHeight; offsetTop和offsetLeft属性用来获取元素相对于父级的位置。该值受外边距影响。语法：element.offsetTop || element.offsetLeft; scrollTop和scrollLeft属性用来获取滚动条被隐藏的区域大小，也可设置定位到该区域（比如返回顶部）。语法：element.scrollTop || element.scrollLeft || element.scrollTop = 0; 常用到的简洁快速的DOCUMENT属性和方法document.title 用来获取文档标题 document.domain 用来获取当前域名 document.URL 用来获取当前url路径 document.forms 获取表单集合 document.images 获取图片集合 document.body 获取body元素节点 document.compatMode 识别文档模式 本文标题：JavaScript学习笔记之Dom知识点总结 本文链接：https://smohan.net/blog/vhikuj","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"DOM","slug":"DOM","permalink":"http://mariogogogo.github.io/tags/DOM/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Nodejs搭建socket.io聊天室","slug":"Nodejs搭建socket.io聊天室","date":"2017-09-07T16:00:00.000Z","updated":"2020-09-16T09:07:41.000Z","comments":true,"path":"2017/09/08/Nodejs搭建socket.io聊天室/","link":"","permalink":"http://mariogogogo.github.io/2017/09/08/Nodejs%E6%90%AD%E5%BB%BAsocket.io%E8%81%8A%E5%A4%A9%E5%AE%A4/","excerpt":"下面是一条数据的旅程，这条数据我们叫他req。","text":"下面是一条数据的旅程，这条数据我们叫他req。 原理从http讲起HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。我们可以非常轻松的捕获浏览器上发生的事件（比如用户点击了盒子），这个事件可以轻松产生与服务器的数据交互（比如Ajax）。但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。 WebSocket协议 最新的HTML5协议，制定了WebSocket协议标准，允许客户端和服务器以全双工的方式进行通信。WebSocket的原理非常的简单：利用HTTP请求产生握手，握手之后，二者转用TCP协议进行交流（QQ的协议）。使用WebSocket协议，需要浏览器和服务器都支持才可以使用。 Socket.IO Node.js从诞生之日起，就支持WebSocket协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库Socket.IO。 Socket.IO是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持WebSocket协议的浏览器，提供了长轮询的透明模拟机制。Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。 服务器端的配置当server创建出来之后，语句12var io = require(&#x27;socket.io&#x27;)(server);能够实例化io对象，此时网址/socket.io/socket.io.js将被默认提供一个静态js文件服务。监听：123io.on(&quot;connection&quot;,function(socket)&#123;&#125;);socket对象有emit方法和on方法。emit方法用于发送一个自定义事件，on方法用于监听服务器发送的自定义事件。 客户端端的配置HTML页面必须运行在服务器上，不能为本地。HTML页面需要引用/socket.io/socket.io.js文件，然后执行io()函数，并得到socket对象。socket对象有emit方法和on方法。emit方法用于发送一个自定义事件，on方法用于监听服务器发送的自定义事件。 Express与Socket.IOExpress框架可以和Socket.IO搭配使用，但是不能像通常的Express程序那样，用app.listen进行监听了，而是采用一种固定的模式： 12345var express = require(&#x27;express&#x27;);var app = express();var http = require(&#x27;http&#x27;).Server(app);var io = require(&#x27;socket.io&#x27;)(http);http.listen(3000); 代码登陆页面12345678910&lt;body&gt; &lt;div&gt; &lt;form action=&quot;/check&quot; method=&quot;get&quot;&gt; 输入昵称： &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送消息&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930&lt;h1&gt;socket.io聊天室 欢迎主淫：&lt;span id=&quot;name&quot;&gt;&lt;%=name%&gt;&lt;/span&gt;&lt;/h1&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;div class=&quot;caozuo&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var socket = io(); $(&#x27;#m&#x27;).keydown(function(e) &#123; if (e.keyCode == 13) &#123; //点击发送按钮，提交输入的信息 socket.emit(&#x27;message&#x27;, &#123; &quot;msg&quot;: $(&#x27;#m&#x27;).val(), &quot;name&quot;: $(&quot;#name&quot;).html() &#125;); console.log($(&quot;#m&quot;).val()); $(this).val(&#x27;&#x27;); // return false; //接收到chat message时 &#125; &#125;) //监听服务端传回来的数据 socket.on(&#x27;message&#x27;, function(msg) &#123; //将chat message显示在页面 console.log(msg); $(&#x27;#messages&#x27;).prepend(&quot;&lt;li&gt;&lt;b&gt;&quot; + msg.name + &quot;:&lt;/b&gt;&quot; + msg.msg + &quot;&lt;/li&gt;&quot;); &#125;); &lt;/script&gt; 后台代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var express = require(&quot;express&quot;);var app = express();var http = require(&quot;http&quot;).Server(app);//创建一个io对象var io = require(&quot;socket.io&quot;)(http);//session保存用户名var session = require(&#x27;express-session&#x27;);//使用sessionapp.use(session(&#123; secret: &#x27;keyboard cat&#x27;, resave: false, saveUninitialized: true&#125;));app.set(&quot;view engine&quot;, &quot;ejs&quot;);//中间件 首页app.get(&quot;/&quot;, function(req, res, next) &#123; res.render(&quot;roomLogin&quot;);&#125;)var allUser = [];//确认登陆app.get(&quot;/check&quot;, function(req, res, next) &#123; console.log(req.query.name); var name = req.query.name; if (!name) &#123; res.send(&quot;必须填写用户名&quot;); return; &#125; if (allUser.indexOf(name) != -1) &#123; res.send(&quot;用户名已经被占用&quot;); return; &#125; allUser.push(name); //保存用户名缓存 req.session.name = name; res.redirect(&quot;/chat&quot;);&#125;);app.get(&quot;/chat&quot;, function(req, res, next) &#123; if (!req.session.name) &#123; res.redirect(&quot;/&quot;); return; &#125; res.render(&quot;chat&quot;, &#123; name: req.session.name &#125;);&#125;)io.on(&quot;connection&quot;, function(socket) &#123; socket.on(&quot;message&quot;, function(msg) &#123; console.log(&#x27;msg:&#x27; + msg); //把客户端传给我们的值再广播发送给别人就是聊天室 io.emit(&quot;message&quot;, msg); &#125;);&#125;);// var server = http.createServer(function(req, res) &#123;// if (req.url == &quot;/&quot;) &#123;// fs.readFile(&quot;./tellRoom.html&quot;, function(err, data) &#123;// res.end(data);// &#125;);// &#125;// &#125;);//监听链接事件// io.on(&quot;connection&quot;, function(socket) &#123;// // console.log(&#x27;一个客户端获得连接了&#x27;);// //接收数据// socket.on(&quot;question&quot;, function(msg) &#123;// console.log(&quot;本服务器得到提问&quot; + msg);// &#125;);// //发送数据 单对单// // socket.emit(&quot;ans&quot;, &quot;吃了&quot;);// //广播 一对多// io.emit(&quot;ans&quot;, &quot;吃了&quot;);// &#125;);http.listen(3000, &quot;127.0.0.1&quot;); 效果图：稍后上传。。。。。。懒 - -！！！","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"JavaScript 开发规范","slug":"JavaScript 开发规范","date":"2017-08-20T16:00:00.000Z","updated":"2020-09-16T09:07:33.000Z","comments":true,"path":"2017/08/21/JavaScript 开发规范/","link":"","permalink":"http://mariogogogo.github.io/2017/08/21/JavaScript%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"原文链接：http://foreverz.cn/2017/08/23/JS开发规范/ 从事前端开发也有一段时间了，一直在遵循着规范化开发，从 js 也逐渐转向了 ts ，在这个过程中也有了很多收获，在此把自己的开发心得写下来。 本文参考了JavaScript 开发规范，并做了补充和修改，同时删去了框架开发相关的内容(侵删)。 1. 命名规范ECMAScript 规范中标识符采用驼峰大小写格式，驼峰命名法由小(大)写字母开始，后续每个单词首字母都大写。根据首字母是否大写，分为两种方式： Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfoCamel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo标识符，则包括变量、函数名、类名、属性名和函数或类的参数，每个命名方法又略有不同，下面详细解释一下： 1.1 变量 命名方法：小驼峰式命名法。 命名规范：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数) 命名建议：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。 1234567// 好的命名方式let maxCount = 10;let tableTitle = &#x27;LoginTable&#x27;;// 不好的命名方式let setCount = 10;let getTitle = &#x27;LoginTable&#x27;; 1.2 常量 命名方法：名称全部大写。 命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词。 123const MAX_COUNT = 10;const URL = &#x27;http://www.foreverz.com&#x27;; 1.3 函数 命名方法：小驼峰式命名法。 命名规范：前缀应当为动词。 命名建议：可使用常见动词约定 动词 含义 返回值 can 判断是否可执行某个动作(权限) 函数返回一个布尔值。true：可执行；false：不可执行 has 判断是否含有某个值 函数返回一个布尔值。true：含有此值；false：不含有此值 is 判断是否为某个值 函数返回一个布尔值。true：为某个值；false：不为某个值 get 获取某个值 函数返回一个非布尔值 set 设置某个值 无返回值、返回是否设置成功或者返回链式对象 load 加载某些数据 无返回值或者返回是否加载完成的结果 render 渲染生成某些数据 无返回值或者返回是否渲染完成 12345678// 是否可阅读function canRead(): boolean &#123; return true;&#125;// 获取名称function getName(): string &#123; return this.name;&#125; 1.4 类 &amp; 构造函数 命名方法：大驼峰式命名法，首字母大写。 命名规范：前缀为名称。 1234567class Person &#123; public name: string; constructor(name) &#123; this.name = name; &#125;&#125;const person = new Person(&#x27;mevyn&#x27;); 1.5 类的成员 类的成员包含： 公共属性和方法：跟变量和函数的命名一样。 私有属性和方法：前缀为_(下划线)，后面跟公共属性和方法一样的命名方式。 12345678910111213141516class Person &#123; private _name: string; constructor() &#123; &#125; // 公共方法 getName() &#123; return this._name; &#125; // 公共方法 setName(name) &#123; this._name = name; &#125;&#125;const person = new Person();person.setName(&#x27;mervyn&#x27;);person.getName(); // -&gt;mervyn 2. 注释规范js 支持三种不同类型的注释：行内注释、单行注释和多行注释： 2.1 行内注释 说明：行内注释以两个斜线开始，以行尾结束。 语法：code // 这是行内注释 使用方式：//(双斜线)与代码之间保留一个空格，并且//(双斜线)与注释文字之间保留一个空格。 命名建议： 1234567// 用来显示一个解释的评论// -&gt; 用来显示表达式的结果，// &gt;用来显示 console 的输出结果，function test() &#123; // 测试函数 console.log(&#x27;Hello World!&#x27;); // &gt;Hello World! return 3 + 2; // -&gt;5&#125; 2.2 单行注释 说明：单行注释以两个斜线开始，以行尾结束。 语法：// 这是单行注释 使用方式：单独一行：//(双斜线)与注释文字之间保留一个空格。 eg： // 调用了一个函数；1)单独在一行setTitle();2.3 多行注释 说明：以 / 开头， / 结尾 语法：/ 注释说明 / 使用方法：若开始/和结束/都在一行，推荐采用单行注释。若至少三行注释时，第一行为/，最后行为/，其他行以开始，并且注释文字与保留一个空格。 123456/** 代码执行到这里后会调用setTitle()函数* setTitle()：设置title的值*/setTitle(); 2.4 函数(方法)注释 说明：函数(方法)注释也是多行注释的一种，但是包含了特殊的注释要求，参照JSDoc 123456/*** 函数说明* @关键字*/常用注释关键字：(只列出一部分，并不是全部) 注释名 语法 含义 示例@param @param 参数名 {参数类型} 描述信息 描述参数的信息 @param name {String} 传入名称@return @return {返回类型} 描述信息 描述返回值的信息 @return {Boolean} true:可执行;false:不可执行@author @author 作者信息 [附属信息：如邮箱、日期] 描述此函数作者的信息 @author 张三 2015/07/21@version @version XX.XX.XX 描述此函数的版本号 @version 1.0.3@example @example 示例代码 演示函数的使用 @example setTitle(‘测试’)/** 合并Grid的行 @param grid {Ext.Grid.Panel} 需要合并的Grid @param cols {Array} 需要合并列的Index(序号)数组；从0开始计数，序号也包含。 @param isAllSome {Boolean} ：是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样 @return void @author polk6 2015/07/21 @example | 年龄 | 姓名 | | 年龄 | 姓名 | —————– mergeCells(grid,[0]) —————– | 18 | 张三 | =&gt; | | 张三 | —————– - 18 ——— | 18 | 王五 | | | 王五 | / 1234function mergeCells(grid: Ext.Grid.Panel, cols: Number[], isAllSome: boolean = false) &#123; // Do Something&#125; 这里只是详细讲解了 标识符命名规范 和 代码注释规范，还有很多其它的规范没来得及填充，可以参考一下Airbnb JavaScript Style Guide 参考书籍和文章：HTML/CSS/JS编码规范 JavaScript高级程序设计（第3版） JavaScript 开发规范","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://mariogogogo.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"面向过程-日历（三）","slug":"面向过程-日历（三）","date":"2017-08-17T16:00:00.000Z","updated":"2020-09-16T09:07:08.000Z","comments":true,"path":"2017/08/18/面向过程-日历（三）/","link":"","permalink":"http://mariogogogo.github.io/2017/08/18/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E6%97%A5%E5%8E%86%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"注意实现功能： 查找当前日期并实现之后10天可点击，其余天数不可点击 点击左右按钮切换月份 点击符合规则的日期把日期及价格显示在对应输入框中 判断当最后一行没有日期显示时候对应高度与上一行显示日期的高度一致 效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334window.onload = function() &#123; var aInput = document.getElementsByTagName(&#x27;input&#x27;); var oDiv = document.getElementById(&#x27;div1&#x27;); var oNowTime = document.getElementById(&#x27;nowTime&#x27;); var oNextTime = document.getElementById(&#x27;nextTime&#x27;); //获取span var aNowSpan = oNowTime.getElementsByTagName(&quot;span&quot;); var aNextSpan = oNextTime.getElementsByTagName(&quot;span&quot;); //获取所以td var aTd = oDiv.getElementsByTagName(&quot;td&quot;); var bBtn = true; aInput[2].onclick = function() &#123; var oDate = new Date(); if(bBtn) &#123; oDiv.style.display = &quot;block&quot;; //判断是否下一年 if(oDate.getMonth() + 1 == 12) &#123; //传位置 年 月 true代表这个月还是下一个月 showDate(oNowTime, oDate.getFullYear(), oDate.getMonth() + 1, true); showDate(oNextTime, oDate.getFullYear() + 1, 1); &#125; else &#123; showDate(oNowTime, oDate.getFullYear(), oDate.getMonth() + 1, true); showDate(oNextTime, oDate.getFullYear(), oDate.getMonth() + 2); &#125; //调用查找日期方法找到当前日期所对应的td showColor(oDate.getDate()); showBtn(); showClick(); hideLastTr(); &#125; else &#123; oDiv.style.display = &quot;none&quot;; &#125; bBtn = !bBtn; &#125;; function showDate(obj, year, month, bBtn) &#123; var oDate = new Date(); //设置开关防止重新生成 if(!obj.bBtn) &#123; //生成周表格table table有个特别在ie下用HTML是不兼容的 obj.oTitle = document.createElement(&#x27;div&#x27;); obj.oTitle.className = &#x27;title&#x27;; obj.appendChild(obj.oTitle); var oTable = document.createElement(&#x27;table&#x27;); var oThead = document.createElement(&#x27;thead&#x27;); var oTr = document.createElement(&#x27;tr&#x27;); var arr = [&#x27;周日&#x27;, &#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;, &#x27;周五&#x27;, &#x27;周六&#x27;]; for(var i = 0; i &lt; 7; i++) &#123; var oTh = document.createElement(&#x27;th&#x27;); oTh.innerHTML = arr[i]; if(i == 0 || i == 6) &#123; oTh.className = &quot;red&quot;; &#125; oTr.appendChild(oTh); &#125; oThead.appendChild(oTr); oTable.appendChild(oThead); //生成日期 生成5个行 7个列 每一行七个列 var oTbody = document.createElement(&#x27;tBody&#x27;); for(var i = 0; i &lt; 6; i++) &#123; var oTr = document.createElement(&quot;tr&quot;); for(var j = 0; j &lt; 7; j++) &#123; var oTd = document.createElement(&quot;td&quot;); oTr.appendChild(oTd); &#125; oTbody.appendChild(oTr); &#125; oTable.appendChild(oTbody); obj.appendChild(oTable); obj.bBtn = true; &#125; //根据bbtn判断左边右边的年份换一种写法 if(bBtn) &#123; obj.oTitle.innerHTML = &#x27;&lt;div class=&quot;l&quot;&gt;&lt;span&gt;&#x27; + (month - 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;c&quot;&gt;&lt;span&gt;&#x27; + year + &#x27;&lt;/span&gt;年&lt;span&gt;&#x27; + month + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;; &#125; else &#123; obj.oTitle.innerHTML = &#x27;&lt;div class=&quot;r&quot;&gt;&lt;span&gt;&#x27; + (month + 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;c&quot;&gt;&lt;span&gt;&#x27; + year + &#x27;&lt;/span&gt;年&lt;span&gt;&#x27; + month + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;; &#125; //生成每一个月的天数 每次点击月份清空 var aTd = obj.getElementsByTagName(&#x27;td&#x27;); for(var i = 0; i &lt; aTd.length; i++) &#123; aTd[i].innerHTML = &#x27;&#x27;; &#125; //判断月份的天数 if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &#123; dayNum = 31; &#125; else if(month == 4 || month == 6 || month == 9 || month == 11) &#123; dayNum = 30; &#125; else if(month == 2 &amp;&amp; isLeapYear(year)) &#123; dayNum = 29; &#125; else &#123; dayNum = 28; &#125; oDate.setFullYear(year); oDate.setMonth(month - 1); oDate.setDate(1); console.log(oDate.getDay()); //根据1号 对应的 getDay（）是周几？ switch(oDate.getDay()) &#123; case 0: //周日 第一个td开始遍历 for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i].innerHTML = i + 1; &#125; break; case 1: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 1].innerHTML = i + 1; &#125; break; case 2: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 2].innerHTML = i + 1; &#125; break; case 3: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 3].innerHTML = i + 1; &#125; break; case 4: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 4].innerHTML = i + 1; &#125; break; case 5: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 5].innerHTML = i + 1; &#125; break; case 6: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 6].innerHTML = i + 1; &#125; break; &#125; //ajax请求 ajax(&#x27;data.js?&#x27; + Math.random(), function(str) &#123; var j = eval(&#x27;(&#x27; + str + &#x27;)&#x27;); console.log(j) var now = 0; for(var i = 0; i &lt; aTd.length; i++) &#123; if(aTd[i].innerHTML == 1) &#123; now = i; &#125; &#125; if(j.code) &#123; //如果这个月的天数小于数组长度则长度最多为日期天数 for(var i = 0; i &lt; j.list.length; i++) &#123; if(j.list[i]) &#123; var oP = document.createElement(&#x27;p&#x27;); oP.innerHTML = j.list[i] + &#x27;元&#x27;; aTd[i + now].appendChild(oP); &#125; &#125; &#125; &#125;); //判断如果左边是1月 则 按钮应该是12月份 if(month == 1 &amp;&amp; bBtn) &#123; obj.oTitle.getElementsByTagName(&#x27;span&#x27;)[0].innerHTML = 12; &#125; else if(month == 12 &amp;&amp; !bBtn) &#123; obj.oTitle.getElementsByTagName(&#x27;span&#x27;)[0].innerHTML = 1; &#125; &#125;; //判断是否是闰年 function isLeapYear(year) &#123; if(year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return true; &#125; else &#123; if(year % 400 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;; function showColor(date) &#123; var result = [] var oDate = new Date(); var bBtn = true; var reg = new RegExp(&#x27;&#x27; + date + &#x27;(&lt;p&gt;)*&#x27;); var index = 0; for(var i = 0, len = aTd.length; i &lt; len; i++) &#123; if(aTd[i].innerHTML != &quot;&quot;) &#123; result.push(aTd[i]); &#125; &#125; //判断当前日期 if(aNowSpan[1].innerHTML == oDate.getFullYear() &amp;&amp; aNowSpan[2].innerHTML == oDate.getMonth() + 1) &#123; for(var i = 0; i &lt; result.length; i++) &#123; if(reg.test(result[i].innerHTML) &amp;&amp; bBtn) &#123; result[i].className = &quot;red&quot;; index = i; bBtn = false; &#125; &#125; //找到当天日期是td第几个然后从今天开始往后几个都可以选择 for(len = index + 11; index + 1 &lt; len; index++) &#123; result[index + 1].className = &quot;blue&quot;; &#125; &#125; else &#123; //清空每个td的颜色变灰色 for(var i = 0; i &lt; result.length; i++) &#123; result[i].className = &quot;&quot;; &#125; &#125; &#125; function showBtn() &#123; //获取左右2边的月份及年 var leftMonth = parseInt(aNowSpan[0].innerHTML); var leftYear = parseInt(aNowSpan[1].innerHTML); var rightMonth = parseInt(aNextSpan[0].innerHTML); var rightYear = parseInt(aNextSpan[1].innerHTML); aNowSpan[0].parentNode.onclick = function() &#123; if(leftMonth == 12) &#123; showDate(oNowTime, leftYear - 1, leftMonth, true); showDate(oNextTime, leftYear, 1); &#125; else &#123; showDate(oNowTime, leftYear, leftMonth, true); showDate(oNextTime, leftYear, leftMonth + 1); &#125; showBtn(); showColor(new Date().getDate()); &#125; aNextSpan[0].parentNode.onclick = function() &#123; if(rightMonth == 1) &#123; showDate(oNowTime, rightYear, 12, true); showDate(oNextTime, rightYear + 1, rightMonth); &#125; else &#123; showDate(oNowTime, rightYear, rightMonth - 1, true); showDate(oNextTime, rightYear, rightMonth); &#125; showBtn(); showColor(new Date().getDate()); &#125; &#125; //点击事件显示日期在输入框 function showClick() &#123; var re = /(\\d+)((&lt;p&gt;)*)/; var oDate = new Date(); for(var i = 0; i &lt; aTd.length; i++) &#123; aTd[i].index = i; aTd[i].onclick = function() &#123; //判断可以点击的日期 if(this.className == &quot;red&quot; || this.className == &quot;blue&quot;) &#123; //判断左边日期还是右边日期 if(this.index &lt; aTd.length / 2) &#123; this.innerHTML.replace(re, function($0, $1) &#123; aInput[0].value = oDate.getFullYear() + &#x27;-&#x27; + (oDate.getMonth() + 1) + &#x27;-&#x27; + $1; &#125;); &#125; else &#123; if((oDate.getMonth() + 2) == 1) &#123; this.innerHTML.replace(re, function($0, $1) &#123; aInput[0].value = oDate.getFullYear() + 1 + &#x27;-&#x27; + (oDate.getMonth() + 2) + &#x27;-&#x27; + $1; &#125;); &#125; else &#123; this.innerHTML.replace(re, function($0, $1) &#123; aInput[0].value = oDate.getFullYear() + &#x27;-&#x27; + (oDate.getMonth() + 2) + &#x27;-&#x27; + $1; &#125;); &#125; &#125; //判断表格内是否有价格显示 if(this.getElementsByTagName(&#x27;p&#x27;)[0]) &#123; aInput[1].value = this.getElementsByTagName(&#x27;p&#x27;)[0].innerHTML; &#125; else &#123; aInput[1].value = &#x27;&#x27;; &#125; oDiv.style.display = &#x27;none&#x27;; bBtn = true; &#125; &#125; &#125; &#125; //隐藏多余的td表格框 function hideLastTr() &#123; var bBtn = true; var bBtn2 = true; for(var i = 35; i &lt; 42; i++) &#123; if(aTd[i].innerHTML != &#x27;&#x27;) &#123; bBtn = false; &#125; &#125; if(bBtn) &#123; for(var i = 35; i &lt; 42; i++) &#123;// aTd[i].style.display = &#x27;none&#x27;; aTd[i].style.height = &#x27;42px&#x27;; &#125; &#125; else &#123; for(var i = 35; i &lt; 42; i++) &#123; aTd[i].style.height = &#x27;&#x27;; &#125; &#125; for(var i = 77; i &lt; 84; i++) &#123; if(aTd[i].innerHTML != &#x27;&#x27;) &#123; bBtn2 = false; &#125; &#125; if(bBtn2) &#123; for(var i = 77; i &lt; 84; i++) &#123; aTd[i].style.height = &#x27;42px&#x27;; &#125; &#125; else &#123; for(var i = 77; i &lt; 84; i++) &#123; aTd[i].style.height = &#x27;&#x27;; &#125; &#125; &#125;&#125;","categories":[{"name":"练习Demo","slug":"练习Demo","permalink":"http://mariogogogo.github.io/categories/%E7%BB%83%E4%B9%A0Demo/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"Demo","slug":"Demo","permalink":"http://mariogogogo.github.io/tags/Demo/"}]},{"title":"面向过程-日历（一）","slug":"面向过程-日历（一）","date":"2017-08-16T16:00:00.000Z","updated":"2020-09-16T09:07:09.000Z","comments":true,"path":"2017/08/17/面向过程-日历（一）/","link":"","permalink":"http://mariogogogo.github.io/2017/08/17/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E6%97%A5%E5%8E%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"思路：首先获取元素节点元素—&gt;根据点击事件隐藏显示元素—&gt;建立showdate方法（判断12月 则右边年份+1，月份1 ）—&gt;还要设置btn开关 防止多次重建—&gt;根据元素清空 for循环列 行、把 th tr thead加入table—&gt;根据判断每一次点击进入月份必须先清空一次td判断月份大小及闰年—&gt; switch循环加入日期 布局是这样紫的 HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;确定&quot; /&gt;&lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;nowTime&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;l&quot;&gt;&lt;span&gt;3&lt;/span&gt;月&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;span&gt;2000&lt;/span&gt;年&lt;span&gt;3&lt;/span&gt;月&lt;/div&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;周一&lt;/th&gt; &lt;th&gt;周二&lt;/th&gt; &lt;th&gt;周三&lt;/th&gt; &lt;th&gt;周四&lt;/th&gt; &lt;th&gt;周五&lt;/th&gt; &lt;th class=&quot;red&quot;&gt;周六&lt;/th&gt; &lt;th class=&quot;red&quot;&gt;周日&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; 1 &lt;p&gt;200元&lt;/p&gt; &lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=&quot;nextTime&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;r&quot;&gt;&lt;span&gt;3&lt;/span&gt;月&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;span&gt;2000&lt;/span&gt;年&lt;span&gt;3&lt;/span&gt;月&lt;/div&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;周一&lt;/th&gt; &lt;th&gt;周二&lt;/th&gt; &lt;th&gt;周三&lt;/th&gt; &lt;th&gt;周四&lt;/th&gt; &lt;th&gt;周五&lt;/th&gt; &lt;th class=&quot;red&quot;&gt;周六&lt;/th&gt; &lt;th class=&quot;red&quot;&gt;周日&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; 1 &lt;p&gt;200元&lt;/p&gt; &lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516*&#123; margin:0; padding:0; font-size:12px;&#125;#div1&#123; margin:20px; position:absolute; top:25px; left:10px; display:block;&#125;#nowTime&#123; width:330px; float:left;&#125;#nextTime &#123; width:330px; float:left; margin:0 0 0 10px;&#125;.title&#123; width:100%; height:30px; background:red; color:#FFFFFF; position:relative;&#125;.title .c&#123; text-align:center; line-height:30px;&#125;.title .l&#123; position:absolute; top:6px; left:5px;&#125;.title .r&#123; position:absolute; top:6px; right:5px;&#125;table&#123; width:100%; background:#dee3e9; color:#9ea7ac;&#125;table tr&#123; background:#f9fafc;&#125;table th&#123; width:46px; padding:5px;&#125;table td&#123; padding:5px; text-align:center;&#125;.red&#123; color:#FF0000;&#125;.blue&#123; color:#0000FF;&#125;table td p&#123; color:#FF0000;&#125;input&#123; margin:20px;&#125;","categories":[{"name":"练习Demo","slug":"练习Demo","permalink":"http://mariogogogo.github.io/categories/%E7%BB%83%E4%B9%A0Demo/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"Demo","slug":"Demo","permalink":"http://mariogogogo.github.io/tags/Demo/"}]},{"title":"面向过程-日历（二）","slug":"面向过程-日历（二）","date":"2017-08-16T16:00:00.000Z","updated":"2020-09-16T09:07:08.000Z","comments":true,"path":"2017/08/17/面向过程-日历（二）/","link":"","permalink":"http://mariogogogo.github.io/2017/08/17/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E6%97%A5%E5%8E%86%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"现在用面向过程方式 点击按钮显示或隐藏日历 设置日期对象 通过showDate方法传对应日期过去 showDate方法动态生成table日历表格 根据日期判断闰年 根据月份判断天数遍历从每月1号对应周几开始遍历第几个td开始** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151window.onload = function() &#123; var aInput = document.getElementsByTagName(&#x27;input&#x27;); var oDiv = document.getElementById(&#x27;div1&#x27;); var oNowTime = document.getElementById(&#x27;nowTime&#x27;); var oNextTime = document.getElementById(&#x27;nextTime&#x27;); var bBtn = true; aInput[2].onclick = function() &#123; var oDate = new Date(); if(bBtn) &#123; oDiv.style.display = &quot;block&quot;; //判断是否下一年 if(oDate.getMonth() + 1 == 12) &#123; //传位置 年 月 true代表这个月还是下一个月 showDate(oNowTime, oDate.getFullYear(), oDate.getMonth() + 1, true); showDate(oNextTime, oDate.getFullYear() + 1, 1); &#125; else &#123; showDate(oNowTime, oDate.getFullYear(), oDate.getMonth() + 1, true); showDate(oNextTime, oDate.getFullYear(), oDate.getMonth() + 2); &#125; &#125; else &#123; oDiv.style.display = &quot;none&quot;; &#125; bBtn = !bBtn; &#125;; function showDate(obj, year, month, bBtn) &#123; var oDate = new Date(); //设置开关防止重新生成 if(!obj.bBtn) &#123; //生成周表格table table有个特别在ie下用HTML是不兼容的 obj.oTitle = document.createElement(&#x27;div&#x27;); obj.oTitle.className = &#x27;title&#x27;; obj.appendChild(obj.oTitle); var oTable = document.createElement(&#x27;table&#x27;); var oThead = document.createElement(&#x27;thead&#x27;); var oTr = document.createElement(&#x27;tr&#x27;); var arr = [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;, &#x27;周五&#x27;, &#x27;周六&#x27;, &#x27;周日&#x27;]; for(var i = 0; i &lt; 7; i++) &#123; var oTh = document.createElement(&#x27;th&#x27;); oTh.innerHTML = arr[i]; if(i == 5 || i == 6) &#123; oTh.className = &quot;red&quot;; &#125; oTr.appendChild(oTh); &#125; oThead.appendChild(oTr); oTable.appendChild(oThead); //生成日期 生成6个行 7个列 每一行七个列 var oTbody = document.createElement(&#x27;tBody&#x27;); for(var i = 0; i &lt; 6; i++) &#123; var oTr = document.createElement(&quot;tr&quot;); for(var j = 0; j &lt; 7; j++) &#123; var oTd = document.createElement(&quot;td&quot;); oTr.appendChild(oTd); &#125; oTbody.appendChild(oTr); &#125; oTable.appendChild(oTbody); obj.appendChild(oTable); obj.bBtn = true; &#125; // obj.oTitle.innerHTML = (bBtn ? &#x27;&lt;div class=&quot;l&quot;&gt;&lt;span&gt;&#x27; + (month - 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27; : &#x27;&lt;div class=&quot;r&quot;&gt;&lt;span&gt;&#x27; + (month + 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;) + &#x27;&lt;div class=&quot;c&quot;&gt;&lt;span&gt;&#x27; + year + &#x27;&lt;/span&gt;年&lt;span&gt;&#x27; + month + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;; //换一种写法 if(bBtn) &#123; obj.oTitle.innerHTML = &#x27;&lt;div class=&quot;l&quot;&gt;&lt;span&gt;&#x27; + (month - 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;c&quot;&gt;&lt;span&gt;&#x27; + year + &#x27;&lt;/span&gt;年&lt;span&gt;&#x27; + month + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;; &#125; else &#123; obj.oTitle.innerHTML = &#x27;&lt;div class=&quot;r&quot;&gt;&lt;span&gt;&#x27; + (month + 1) + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;c&quot;&gt;&lt;span&gt;&#x27; + year + &#x27;&lt;/span&gt;年&lt;span&gt;&#x27; + month + &#x27;&lt;/span&gt;月&lt;/div&gt;&#x27;; &#125; //生成每一个月的天数 每次点击月份清空 var aTd = obj.getElementsByTagName(&#x27;td&#x27;); for(var i = 0; i &lt; aTd.length; i++) &#123; aTd[i].innerHTML = &#x27;&#x27;; &#125; //判断月份的天数 if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &#123; dayNum = 31; &#125; else if(month == 4 || month == 6 || month == 9 || month == 11) &#123; dayNum = 30; &#125; else if(month == 2 &amp;&amp; isLeapYear(year)) &#123; dayNum = 29; &#125; else &#123; dayNum = 28; &#125; oDate.setFullYear(year); oDate.setMonth(month - 1); oDate.setDate(1); console.log(oDate.getDay()); //根据1号 对应的 getDay（）是周几？ switch(oDate.getDay()) &#123; case 0: //周日 第七个td开始遍历 for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 6].innerHTML = i + 1; &#125; break; case 1: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i].innerHTML = i + 1; &#125; break; case 2: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 1].innerHTML = i + 1; &#125; break; case 3: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 2].innerHTML = i + 1; &#125; break; case 4: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 3].innerHTML = i + 1; &#125; break; case 5: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 4].innerHTML = i + 1; &#125; break; case 6: for(var i = 0; i &lt; dayNum; i++) &#123; aTd[i + 5].innerHTML = i + 1; &#125; break; &#125; //判断是否是闰年 function isLeapYear(year) &#123; if(year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return true; &#125; else &#123; if(year % 400 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"练习Demo","slug":"练习Demo","permalink":"http://mariogogogo.github.io/categories/%E7%BB%83%E4%B9%A0Demo/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"Demo","slug":"Demo","permalink":"http://mariogogogo.github.io/tags/Demo/"}]},{"title":"组件系列_弹窗","slug":"组件系列_弹窗","date":"2017-08-15T16:00:00.000Z","updated":"2020-09-16T09:07:17.000Z","comments":true,"path":"2017/08/16/组件系列_弹窗/","link":"","permalink":"http://mariogogogo.github.io/2017/08/16/%E7%BB%84%E4%BB%B6%E7%B3%BB%E5%88%97_%E5%BC%B9%E7%AA%97/","excerpt":"我们在前端开发的过程中（其它开发也一样），总是会遇到这样一种情况：以前做的一个项目，里面有个组件，比如对话弹窗、登陆窗等等。","text":"我们在前端开发的过程中（其它开发也一样），总是会遇到这样一种情况：以前做的一个项目，里面有个组件，比如对话弹窗、登陆窗等等。一般我们写了之后就很少去管它了，但是像这样的一些组件，在不同的项目开发过程总是很多时候需要复用起来的。虽然现在网上很多js库都封装了这样的一些组件，如果你为了图快、方便的话，那么直接使用这些库也是可以的，但从这两个方面来说，我觉得有必要我们把我们写过的这些组件分离出来从而以后复用：1、如果你用第三方库的话，我们都知道，有很多第三方库并不是刚好封装了你要的那个组件而已，比如你需要一个登陆组件，那么可能第三方库确实封装了这个组件，但同时也封装了很多其它组件，所以你如果用第三方库的话，那么你就会为了一个小组件引入一些庞大的js文件和css文件以及图片！这样的库引入多了的话，那么后期你不仅需要更多地维护各个库的冲突等等问题，而且你的网站因此也会响应越来越慢，影响用户体验！2、如果你自己把你写过的组件单独分离出来复用的话，首先来说，你自己写过的，那么你用起来也会比较熟悉，对不？而且，这样的工作你做多了以后，提高你基本功的同时，你还会发现你现在就是在写一个“第三方库”了，虽然有很多瑕疵，但是原理差不多的！ 效果图html1234567891011121314&lt;div class=&quot;sc-box sc-login-box&quot;&gt; &lt;div class=&quot;sc-login&quot; id=&quot;sc-login&quot;&gt; &lt;h2 class=&quot;text-ellipsis sc-login__title&quot;&gt;登陆&lt;/h2&gt; &lt;div class=&quot;sc-login__input&quot;&gt; &lt;label&gt;&lt;span class=&quot;label&quot;&gt;账号：&lt;/span&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请填写账号&quot;/&gt;&lt;/label&gt; &lt;label&gt;&lt;span class=&quot;label&quot;&gt;密码：&lt;/span&gt;&lt;input class=&quot;input&quot; type=&quot;password&quot; placeholder=&quot;请填写密码&quot;/&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;sc-login__btn&quot;&gt; &lt;a class=&quot;login_cancel btn&quot; href=&quot;javascript:void(0);&quot; title=&quot;#&quot;&gt;取消&lt;/a&gt; &lt;a class=&quot;login_ensure btn&quot; href=&quot;javascript:void(0);&quot; title=&quot;#&quot;&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script type=&quot;text/javascript&quot;&gt; /** * * 向外暴露一个接口Login，为了减少命名冲突，相关操作在其实例属性或者方法上执行 * **/ function Login()&#123; this.init.apply(this,arguments); &#125;; Login.prototype = &#123; /*** *id参数用于获取login弹窗 *config用于设置相关回调参数等 */ init:function(id,config)&#123; var login_dom = (typeof id === &#x27;string&#x27;)?document.getElementById(id):id; if(!login_dom)&#123; return; &#125;; //登陆框隐藏操作 function hide()&#123; login_dom.style.display = &#x27;none&#x27;; &#125;; //点击取消按钮操作 login_dom.querySelector(&#x27;.login_cancel&#x27;).onclick = function()&#123; hide(); if(config.cancel)&#123; config.cancel(); &#125;; &#125;; //点击确定按钮操作 login_dom.querySelector(&#x27;.login_ensure&#x27;).onclick = function()&#123; hide(); if(config.ensure)&#123; config.ensure(); &#125;; &#125;; &#125; &#125;; //注：实际使用过程中，根据需要写在window.onload或jquery的$回调函数里面调用 setTimeout(function()&#123; //调用 new Login(&#x27;sc-login&#x27;,&#123; cancel:function()&#123; //点击取消按钮脚本 goes here console.log(&#x27;取消&#x27;); &#125;, ensure:function()&#123; //点击确定按钮脚本 goes here console.log(&#x27;确定&#x27;); &#125; &#125;); &#125;,0);&lt;/script&gt;","categories":[{"name":"组件","slug":"组件","permalink":"http://mariogogogo.github.io/categories/%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"组件","slug":"组件","permalink":"http://mariogogogo.github.io/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"三栏布局的五种写法","slug":"三栏布局的五种写法","date":"2017-08-04T16:00:00.000Z","updated":"2020-09-16T09:07:11.000Z","comments":true,"path":"2017/08/05/三栏布局的五种写法/","link":"","permalink":"http://mariogogogo.github.io/2017/08/05/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%94%E7%A7%8D%E5%86%99%E6%B3%95/","excerpt":"已知高度 左右距离固定 中间自适应三栏布局在html很常见，基础知识回顾","text":"已知高度 左右距离固定 中间自适应三栏布局在html很常见，基础知识回顾 双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间middle多了一个子容器存在，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度。 最常见的圣杯布局实现方法关键点 圣杯布局的关键点是通过 margin-left 与 left 属性将左右两列放置到准确的位置 圣杯布局的关键点父元素需要设置 padding 圣杯布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的 最常见的双飞翼布局实现方法关键点 双飞翼布局的关键点是通过 margin-left 属性将左右两列放置到准确的位置，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度 双飞翼布局的关键点父元素不需要设置 padding 双飞翼布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的 其他布局方法-12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; &#125; .layout &#123; margin: 10px 0px; &#125; .layout article div &#123; min-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 其他布局方法-1234567891011121314151617181920212223242526272829&lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; .layout.float .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 其他布局方法-123456789101112131415161718192021222324252627282930313233343536&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left-mid-right &#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-mid-right&gt;div &#123; display: table-cell; &#125; .layout.table .left &#123; width: 300px; background: red; &#125; .layout.table .right &#123; width: 300px; background: blue; &#125; .layout.table .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flexbox布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; 其他布局方法-1234567891011121314151617181920212223242526272829303132333435&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox &#123; margin-top: 130px; &#125; .layout.flexbox .left-mid-right &#123; display: flex; &#125; .layout.flexbox .left &#123; width: 300px; background: red; &#125; .layout.flexbox .right &#123; width: 300px; background: blue; &#125; .layout.flexbox .mid &#123; flex: 1; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;flexbox布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; 其他布局方法-123456789101112131415161718192021222324252627282930313233343536&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left-mid-right&gt;div &#123; position: absolute; &#125; .layout.absolute .left &#123; left: 0; width: 300px; background: red; &#125; .layout.absolute .right &#123; right: 0; width: 300px; background: blue; &#125; .layout.absolute .mid &#123; left: 300px; right: 300px; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;绝对定位&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 其他布局方法-1234567891011121314151617181920212223242526272829303132&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left-mid-right &#123; display: grid; width: 100%; height: 100px; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left &#123; background: red; &#125; .layout.grid .right &#123; background: blue; &#125; .layout.grid .mid &#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-mid-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;h1&gt;网格布局&lt;/h1&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;p&gt;这是三栏布局&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt;","categories":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"HTML","slug":"HTML","permalink":"http://mariogogogo.github.io/tags/HTML/"}]},{"title":"Node.js 的本质","slug":"Node.js 的本质","date":"2017-08-02T16:00:00.000Z","updated":"2020-09-16T09:07:40.000Z","comments":true,"path":"2017/08/03/Node.js 的本质/","link":"","permalink":"http://mariogogogo.github.io/2017/08/03/Node.js%20%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"下面是一条数据的旅程，这条数据我们叫他req。","text":"下面是一条数据的旅程，这条数据我们叫他req。req在浏览器很无聊，通过网络跑到了Node.js服务器，它的目的是想见到国王server.js（你编写的代码），req想和server.js要一个html文件，可它进入服务器时，迎接它的是个大臣，大臣告诉他，server.js正在接待另一个req，请他等0.1毫秒。终于req见到了国王，国王的会议室挺漂亮的，下面是会议室的大体样子： 123server.on(“request”,function(req,res)&#123;&#125;) req和server.js要一个hello.html的网页文件，这时候它看到会议室外面还有几个req在等待，server.js国王把任务交给了 fs大臣，然后马上就去接待另一个req了，req心里想国王的效率好高啊，难道这就是传说中的永不阻塞的 I/O 吗，这时候fs大臣帮它把hello.html文件送上了返程的列车res。 123server.on(“request”,function(req,res)&#123; fs.createReadStream(“hello.html”).pipe(res);&#125;) req回到浏览器后，感慨Node.js 国家办事效率，它在日记中写下： 通过集权的编码方式，让代码更加好管理、更好维护，避免多线程带来的死锁等后遗症。通过非阻塞异步 I/O 的调用，把耗时的工作交给底下人去办，而不是等待I/O完成后再进行下一步的工作，而是通过事件模式，监听工作进度，这段时间里，Node.js还可以不 间断的处理其他请求。等到I/O处理完毕后，会接收到一个事件。Node.js是什么？ Node提供一种简单的构建可伸缩网络程序的方法。在 Java 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。 Node更改了连接到服务器的方式。每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程。它绝不会死锁，因为它根本不允许使用锁，它不会直接阻塞 I/O 调用。它的服务器能支持数万个并发连接。 Node.js背后真正的优势 Node.js 有很多优势，在我看来除了高性能外，它统一了前后端语言和数据 (json)，这才是它最大优势。paypal公司全面转至Node.js技术，主要原因是Node.js提高了开发效率，同时也节省了成本。 难学吗？ 只要会JavaScript基本知识即可，javascript的运行环境通常是浏览器，Node.js给了javascript在服务器端运行环境，这个环境下，还配备了一套API，包括I/O、网络等功能。 转自：http://www.html-js.cn/details/VkK2RAlG-.html","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"mongodb的二种写入方式","slug":"mongodb的二种写入方式","date":"2017-07-26T16:00:00.000Z","updated":"2020-09-16T09:07:40.000Z","comments":true,"path":"2017/07/27/mongodb的二种写入方式/","link":"","permalink":"http://mariogogogo.github.io/2017/07/27/mongodb%E7%9A%84%E4%BA%8C%E7%A7%8D%E5%86%99%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"MongoDB 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 MongoDB 工作在收集和文件的概念。","text":"MongoDB 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 MongoDB 工作在收集和文件的概念。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"},{"name":"测试","slug":"测试","permalink":"http://mariogogogo.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"nodeJs模块formidable实现多文件上传","slug":"nodeJs模块formidable实现多图上传","date":"2017-07-09T16:00:00.000Z","updated":"2020-09-16T09:07:42.000Z","comments":true,"path":"2017/07/10/nodeJs模块formidable实现多图上传/","link":"","permalink":"http://mariogogogo.github.io/2017/07/10/nodeJs%E6%A8%A1%E5%9D%97formidable%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0/","excerpt":"在进行node web开发时，我们可能经常遇到上传文件的问题，这一块如果我们没有经验，可能会遇到很多坑，下面我将跟大家分享一下，实现文件上传的一些方式。","text":"在进行node web开发时，我们可能经常遇到上传文件的问题，这一块如果我们没有经验，可能会遇到很多坑，下面我将跟大家分享一下，实现文件上传的一些方式。 通过一段时间的查阅资料、摸索，我发现实现上传的方式有：1.express中间件multer模块（此效率最高，在express3.x原生支持，到了express4.x独立成一个模块了），2.connect-multiparty模块（但现在官方不推荐），3.使用multiparty模块实现（此方法比较普遍），4.使用formidable插件实现（插件呢，就是简单易懂）; 首先知道enctype这个属性管理的是表单的MIME编码。共有三个值可选： application/x-www-form-urlencoded multipart/form-data text/plain 其中application/x-www-form-urlencoded是默认值，作用是设置表单传输的编码。例如我们在AJAX中见过xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form- urlencoded”);如果不写会报错的，但是在html的form表单里是可以不写enctype=application/x-www-form-urlencoded,因为默认的HTML表单就是这种传输编码类型的。 而multipart/form-data是用来制定传输数据的特殊类型的，主要就是我们上传的非文本的内容，比如图片或是是mp3等等。 text/plain是纯文本传输的意思，在发邮件的时候要设置这种编码类型，否则会出现接收时编码混乱的问题。网络上经常拿text/plain和 text/html做比较，其实这两个很好区分，前者用来传输纯文本文件，后者则是传递html代码的编码类型，在发送头文件时才用得上。①和③都不能用于上传文件，只有multipart/form-data才能完整的传递文件数据。 == formidable上传插件，也是在github上同类功能人气比较高的。== 优点： 1. 速度快（~500M/s）,没有non-buffering multipart解析 2.自动写入到上传文件磁盘 3.占用内存低 4.优雅的错误处理 5.非常高的测试覆盖率 直接上代码12345678&lt;h1&gt;&#123;&#123;title&#125;&#125;&#125;多张&lt;/h1&gt; &lt;p&gt;Welcome to &#123;&#123;title&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;image&#125;&#125;&lt;/p&gt; &lt;img src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot; id=&quot;file_upload&quot; multiple&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$(document).ready(function() &#123; var btn = $(&quot;#submit&quot;); btn.on(&#x27;click&#x27;, function() &#123; uploadByForm(); &#125;); &#125;); /** * ajax 上传。 */ function uploadByForm() &#123; var xhr = new XMLHttpRequest(); //第一步 //定义表单变量 var file = document.getElementById(&#x27;file_upload&#x27;).files; //console.log(file.length); //新建一个FormData对象 var formData = new FormData(); //++++++++++ //追加文件数据 for (i = 0; i &lt; file.length; i++) &#123; formData.append(&quot;file[&quot; + i + &quot;]&quot;, file[i]); //++++++++++ &#125; console.log(formData); //formData.append(&quot;file&quot;, file[0]); //++++++++++ //post方式 xhr.open(&#x27;POST&#x27;, &#x27;/api/upload/data&#x27;); //第二步骤 //发送请求 xhr.send(formData); //第三步骤 //ajax返回 xhr.onreadystatechange = function() &#123; //第四步 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var data = JSON.parse(xhr.response); console.log(data) console.log(data.filesUrl); if(data.sucess != &quot;0&quot;) &#123; alert(&quot;上传成功！！，其中&quot;+data.error+&quot;个失败&quot;); &#125; else&#123; alert(&quot;上传失败！！&quot; + data.filesUrl); &#125; &#125; //设置超时时间 xhr.timeout = 100000; xhr.ontimeout = function(event) &#123; alert(&#x27;请求超时！&#x27;); &#125; &#125; &#125; function render(obj) &#123; //对象转数组 var html = &quot;&quot;; for (var i = 0; i &lt; obj.length; i++) &#123; html += &quot;&lt;li&gt; &lt;img src=&#x27;../&quot;+obj[i]+&quot;&#x27;&gt;&lt;/li&gt;&quot;; &#125; $(&quot;.box&quot;).append(html); &#125; 后端代码处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768router.post(&quot;/upload/data&quot;, function(req, res) &#123; var form = new formidable.IncomingForm(); //创建上传表单 form.encoding = &#x27;utf-8&#x27;; //设置编辑 form.uploadDir = &#x27;tmp/&#x27;; //设置上传目录 form.keepExtensions = true; //保留后缀 form.maxFieldsSize = 1 * 1024 * 1024; //文件大小; //将多个参数组合成一个 path /** /Users/lovewcc/Documents/暴力熊团队/nodeTest/uploads */ var targetDir = path.join(__dirname, &#x27;../uploads&#x27;); console.log(targetDir); //文件路径是否存在 不存在则创建 fs.access(targetDir, function(err) &#123; if (err) &#123; fs.mkdirSync(targetDir); &#125; _fileParse(); //调用多图上传方法 &#125;) function _fileParse() &#123; form.parse(req, function(err, fields, files) &#123; var obj = &#123;&#125;; var filesUrl = []; //数组 var errCount = 0; //错误长度 var keys = Object.keys(files); console.log(keys); keys.forEach(function(key) &#123; console.log(files[key].path); var filePath = files[key].path; var fileExt = filePath.substring(filePath.lastIndexOf(&#x27;.&#x27;)); //图片大小 if (files[key].size &gt; form.maxFieldsSize) &#123; errCount += 1; //图片类型 &#125; else if ((&#x27;.jpg.png&#x27;).indexOf(fileExt.toLowerCase()) === -1) &#123; errCount += 1; &#125; else &#123; //以当前时间戳对上传文件进行重命名 var fileName = new Date().getTime() + fileExt; console.log(fileName); var targetFile = path.join(targetDir, fileName); console.log(targetFile); //移动文件 异步经常有问题 改成同步Sync fs.renameSync(files[key].path, targetFile); filesUrl.push(&#x27;uploads/&#x27; + fileName); &#125; &#125;); res.json(&#123; success: keys.length - errCount, error: errCount, filesUrl: filesUrl &#125;); &#125;); &#125;&#125;)//删除临时文件夹var emptyDir = function(fileUrl) &#123; var files = fs.readdirSync(fileUrl); //读取该文件夹 files.forEach(function(file) &#123; var stats = fs.statSync(fileUrl + &#x27;/&#x27; + file); if (stats.isDirectory()) &#123; emptyDir(fileUrl + &#x27;/&#x27; + file); &#125; else &#123; fs.unlinkSync(fileUrl + &#x27;/&#x27; + file); console.log(&quot;删除文件&quot; + fileUrl + &#x27;/&#x27; + file + &quot;成功&quot;); &#125; &#125;);&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"Mac下安装MongoDB 及使用教程","slug":"Mac下安装MongoDB 及使用教程","date":"2017-07-08T16:00:00.000Z","updated":"2020-09-16T09:07:40.000Z","comments":true,"path":"2017/07/09/Mac下安装MongoDB 及使用教程/","link":"","permalink":"http://mariogogogo.github.io/2017/07/09/Mac%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB%20%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"MongoDB 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 MongoDB 工作在收集和文件的概念。","text":"MongoDB 是一个跨平台的，面向文档的数据库，提供高性能，高可用性和可扩展性方便。 MongoDB 工作在收集和文件的概念。 什么是NoSql？ NoSql，全称是 Not Only Sql,指的是非关系型的数据库。下一代数据库主要解决几个要点：非关系型的、分布式的、开源的、水平可扩展的。原始的目的是为了大规模web应用，这场运动开始于2009年初，通常特性应用如：模式自由、支持简易复制、简单的API、最终的一致性（非ACID）、大容量数据等。NoSQL被我们用得最多的当数key-value存储，当然还有其他的文档型的、列存储、图型数据库、xml数据库等。 为什么要使用MongoDB JSON风格文件的形式，面向文档存储：数据存储 对任何属性可索引 复制和高可用性 自动分片 丰富的查询 快速就地更新 MongoDB的专业技术支持 首先安装HomeBrew /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 下载nodejs,一路next 安装完成后，在终端输入 node -v 有显示版本号就代表安装成功，其他异常情况本文不作介绍； 下载Mongodb后，将Mongodb-3.2.5.tar.gz 复制到 /usr/local 路径下解压得到mongodb这个文件夹，（下图中的是我自己改了名字删掉了版本号） *默认情况下在Finder中是看不到 /usr 这个目录的（终端用得溜的请略过），可以打开Finder后按shift + command +G 输入 /usr/local后回车便能看到这个隐藏的目录了 上图中展示的就是我的本机的目录结构了，在/usr/local/mongodb/bin下就是mongodb的执行文件了 然后在根目录下新建 data 文件夹，里面再建一个db文件夹，就是上图中那个 usr文件夹上面的 那个data文件夹 ，里面是用来存放数据库的， 终端切换到/usr/local/mongodb/bin目录下，","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"},{"name":"测试","slug":"测试","permalink":"http://mariogogogo.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"nodeJs模块formidable实现单文件上传","slug":"nodeJs模块formidable实现单图上传","date":"2017-07-08T16:00:00.000Z","updated":"2020-09-16T09:07:42.000Z","comments":true,"path":"2017/07/09/nodeJs模块formidable实现单图上传/","link":"","permalink":"http://mariogogogo.github.io/2017/07/09/nodeJs%E6%A8%A1%E5%9D%97formidable%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%9B%BE%E4%B8%8A%E4%BC%A0/","excerpt":"在进行node web开发时，我们可能经常遇到上传文件的问题，这一块如果我们没有经验，可能会遇到很多坑，下面我将跟大家分享一下，实现文件上传的一些方式。","text":"在进行node web开发时，我们可能经常遇到上传文件的问题，这一块如果我们没有经验，可能会遇到很多坑，下面我将跟大家分享一下，实现文件上传的一些方式。 通过一段时间的查阅资料、摸索，我发现实现上传的方式有：1.express中间件multer模块（此效率最高，在express3.x原生支持，到了express4.x独立成一个模块了），2.connect-multiparty模块（但现在官方不推荐），3.使用multiparty模块实现（此方法比较普遍），4.使用formidable插件实现（插件呢，就是简单易懂）; 首先知道enctype这个属性管理的是表单的MIME编码。共有三个值可选： application/x-www-form-urlencoded multipart/form-data text/plain 其中application/x-www-form-urlencoded是默认值，作用是设置表单传输的编码。例如我们在AJAX中见过xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form- urlencoded”);如果不写会报错的，但是在html的form表单里是可以不写enctype=application/x-www-form-urlencoded,因为默认的HTML表单就是这种传输编码类型的。 而multipart/form-data是用来制定传输数据的特殊类型的，主要就是我们上传的非文本的内容，比如图片或是是mp3等等。 text/plain是纯文本传输的意思，在发邮件的时候要设置这种编码类型，否则会出现接收时编码混乱的问题。网络上经常拿text/plain和 text/html做比较，其实这两个很好区分，前者用来传输纯文本文件，后者则是传递html代码的编码类型，在发送头文件时才用得上。①和③都不能用于上传文件，只有multipart/form-data才能完整的传递文件数据。 == formidable上传插件，也是在github上同类功能人气比较高的。== 优点： 1. 速度快（~500M/s）,没有non-buffering multipart解析 2.自动写入到上传文件磁盘 3.占用内存低 4.优雅的错误处理 5.非常高的测试覆盖率 直接上代码1234 &lt;form role=&quot;form&quot; id=&quot;myForm&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; style=&quot;opacity: 0&quot; &gt;&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot; style=&quot;position: absolute; left: 50%; top: 50%;margin-left:-60px;margin-top:10px;height: 40px;width:100px;cursor:pointer&quot; name=&quot;fulAvatar&quot; id=&quot;file_upload&quot; value=&quot;&quot; class=&quot;form-control&quot; placeholder=&quot;图片地址&quot; onchange=&quot;uploadByForm();&quot;&gt;&lt;/form&gt; 后端代码处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103var express = require(&#x27;express&#x27;);var router = express.Router();var formidable = require(&#x27;formidable&#x27;);var fs = require(&quot;fs&quot;);var path = require(&#x27;path&#x27;);/** * 图片上传 * @type &#123;[type]&#125; */router.get(&#x27;/upload&#x27;, function(req, res, next) &#123; res.render(&quot;form&quot;, &#123; title: &#x27;EXpress&#x27; &#125;);&#125;);//设置头像router.post(&quot;/upload/post&quot;, function(req, res) &#123; var form = new formidable.IncomingForm(); //创建上传表单 form.encoding = &#x27;utf-8&#x27;; //设置编辑 form.uploadDir = &#x27;tmp/&#x27;; //form.uploadDir = path.join(__dirname, &#x27;tmp&#x27;); //文件保存的临时目录为当前项目下的tmp文件夹 form.maxFieldsSize = 1 * 1024 * 1024; //用户头像大小限制为最大1M form.keepExtensions = true; //使用文件的原扩展名 form.parse(req, function(err, fields, files) &#123; // console.log(files); console.log(files.logo.path); // var filePath = &#x27;&#x27;; // if(file.logo)&#123; // filePath = file.logo.path; // &#125;else&#123; // for(var key in file)&#123; // if( file[key].path &amp;&amp; filePath===&#x27;&#x27; )&#123; // filePath = file[key].path; // break; // &#125; // &#125; // &#125; //文件移动的目录文件夹，不存在时创建目标文件夹 // var tagetDir = path.join(__dirname, &#x27;uploads&#x27;); // console.log(tagetDir); // if (!fs.existsSync(targetDir)) &#123; // fs.mkdir(targetDir); // &#125;; //文件类型判断 var filePath = files.logo.path; var extName = filePath.substring(filePath.lastIndexOf(&#x27;.&#x27;)); if ((&#x27;.jpg.png&#x27;).indexOf(extName.toLowerCase()) === -1) &#123; res.code = 2; res.locals.error = &#x27;只支持png和jpg格式图片&#x27;; emptyDir(form.uploadDir);//删除临时文件夹 res.json(&#123; &#x27;err&#x27;: res.locals.error, &quot;code&quot;: res.code &#125;); return; &#125; if (files.logo.size &gt; form.maxFieldsSize) &#123; res.code = 1; res.locals.error = &#x27;图片大小超过1M&#x27;; emptyDir(form.uploadDir);//删除临时文件夹 res.json(&#123; &#x27;err&#x27;: res.locals.error, &quot;code&quot;: res.code &#125;); return; &#125; //根据内容符合则转移文件内容 var avatarName = Math.random() + &#x27;.&#x27; + extName; //图片老地址写入地址； var oldPath = form.uploadDir + avatarName; //图片新地址写入地址； var newPath = &#x27;uploads/&#x27; + avatarName; var showUrl = __dirname + &#x27;/&#x27; + newPath; fs.rename(files.logo.path, newPath, function(err) &#123; if (err) &#123; console.info(err); res.json(&#123; code: 3, message: &#x27;操作失败&#x27; &#125;); &#125; else &#123; // 上传成功，返回文件的相对路径 //删除tmp中所以临时文件 var rootFile = form.uploadDir;//要删除的文件夹 url //删除所有的文件(将所有文件夹置空) emptyDir(form.uploadDir); res.json(&#123; &quot;code&quot;: 0, &quot;newPath&quot;: showUrl, &quot;imgurl&quot;: newPath &#125;); &#125; &#125;); &#125;);&#125;)var emptyDir = function(fileUrl)&#123; var files = fs.readdirSync(fileUrl);//读取该文件夹 files.forEach(function(file)&#123; var stats = fs.statSync(fileUrl+&#x27;/&#x27;+file); if(stats.isDirectory())&#123; emptyDir(fileUrl+&#x27;/&#x27;+file); &#125;else&#123; fs.unlinkSync(fileUrl+&#x27;/&#x27;+file); console.log(&quot;删除文件&quot;+fileUrl+&#x27;/&#x27;+file+&quot;成功&quot;); &#125; &#125;); &#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"nodejs知多少","slug":"nodejs知多少","date":"2017-07-03T16:00:00.000Z","updated":"2020-09-16T09:07:43.000Z","comments":true,"path":"2017/07/04/nodejs知多少/","link":"","permalink":"http://mariogogogo.github.io/2017/07/04/nodejs%E7%9F%A5%E5%A4%9A%E5%B0%91/","excerpt":"经常遇到的问题总结","text":"经常遇到的问题总结 require 用来加载代码，而 exports 和 module.exports 则用来导出代码。很多新手可能会迷惑于 exports 和 module.exports 的区别，为了更好的理解 exports 和 module.exports 的关系，我们先来巩固下 js 的基础。 我们只需知道三点就知道 exports 和 module.exports 的区别了： module.exports 初始值为一个空对象 {} exports 是指向的 module.exports 的引用 require() 返回的是 module.exports 而不是 exports 我们经常看到这样的写法： 12exports = module.exports = &#123;...&#125; 等价于 123module.exports = &#123;...&#125;exports = module.exports 原理很简单：module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports。 package.json 对于 Node.js 应用来说是一个不可或缺的文件，它存储了该 Node.js 应用的名字、版本、描述、作者、入口文件、脚本、版权等等信息。npm 官网有 package.json 每个字段的详细介绍： 12npm i express --save --save-exact (安装 express，同时将 &quot;express&quot;: &quot;4.14.0&quot; 写入 dependencies ) 在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 supervisor 可以解决这个繁琐的问题，全局安装 supervisor： 12npm install -g supervisor 运行 supervisor –harmony index 启动程序，如下所示： supervisor 会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"NodeJs之博客（四）","slug":"NodeJs之博客（四）","date":"2017-07-02T16:00:00.000Z","updated":"2020-09-16T09:07:43.000Z","comments":true,"path":"2017/07/03/NodeJs之博客（四）/","link":"","permalink":"http://mariogogogo.github.io/2017/07/03/NodeJs%E4%B9%8B%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"用户注册及登录","text":"用户注册及登录 login.js12345678910111213141516171819202122232425$(function() &#123; $(&quot;#btn&quot;).on(&quot;click&quot;, function() &#123; //通过ajax提交请求 $.ajax(&#123; type: &#x27;post&#x27;, url: &#x27;/api/user/adminlogin&#x27;, data: &#123; username: $(&quot;#userName&quot;).val(), password: $(&quot;#password&quot;).val() &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; if (!result.code) &#123; window.location.reload(); &#125; else &#123; console.log(result.message); &#125; &#125; &#125;); &#125;);&#125;); 注册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var express = require(&#x27;express&#x27;);var User = require(&#x27;../models/user&#x27;);var router = express.Router();var Content = require(&#x27;../models/content&#x27;);/** * 增加用户注册路由 * 统一返回格式 */var responseDate;router.use(function(rep, res, next) &#123; responseDate = &#123; code: 0, message: &#x27;&#x27; &#125;; next();&#125;);//注册router.post(&#x27;/user/register&#x27;, function(req, res, next) &#123; var username = req.body.username; var password = req.body.password; var repassword = req.body.repassword; if (username === &quot;&quot;) &#123; responseDate.code = 1; responseDate.message = &quot;用户名不能为空！&quot;; res.json(responseDate); return; &#125; if (password === &quot;&quot;) &#123; responseDate.code = 2; responseDate.message = &quot;密码不能为空！&quot;; res.json(responseDate); return; &#125; if (password != repassword) &#123; responseDate.code = 3; responseDate.message = &quot;二次输入的密码不一致&quot;; res.json(responseDate); return; &#125; User.findOne(&#123; username: username &#125;).then(function(userInfo) &#123; if (userInfo) &#123; responseDate.code = 4; responseDate.message = &#x27;该用户名已注册！&#x27;; res.json(responseDate); return; &#125;; //创建新对象 var user = new User(&#123; username: username, password: password &#125;); //保存数据库 return user.save(); &#125;).then(function(newUserInfo) &#123; responseDate.message = &quot;注册成功！&quot;; //当注册成功之后直接登录界面 传值给前台页面 responseDate.newUserInfo = &#123; _id: newUserInfo._id, username: newUserInfo.username &#125;; //保存至cookie发送到浏览器 req.cookies.set(&#x27;userInfo&#x27;, JSON.stringify(&#123; _id: newUserInfo._id, username: newUserInfo.username &#125;)); res.json(responseDate); // console.log(newUserInfo); &#125;);&#125;); 登录1234567891011121314151617181920212223242526272829303132333435363738394041424344router.post(&#x27;/user/login&#x27;, function(req, res, next) &#123; //获取前台传过来的值 var username = req.body.username; var password = req.body.password; if (username === &quot;&quot;) &#123; responseDate.code = 1; responseDate.message = &quot;用户名不能为空！&quot;; res.json(responseDate); return; &#125; if (password === &quot;&quot;) &#123; responseDate.code = 2; responseDate.message = &quot;密码不能为空！&quot;; res.json(responseDate); return; &#125; User.findOne(&#123; username: username, password: password &#125;).then(function(userInfo) &#123; if (!userInfo) &#123; responseDate.code = 3; responseDate.message = &quot;用户名或密码错误！&quot;; res.json(responseDate); return; &#125; responseDate.message = &quot;登录成功！&quot;; //传值给前台页面 responseDate.userInfo = &#123; _id: userInfo._id, username: userInfo.username &#125;; //保存至cookie发送到浏览器 req.cookies.set(&#x27;userInfo&#x27;, JSON.stringify(&#123; _id: userInfo._id, username: userInfo.username &#125;)); res.json(responseDate); return; &#125;);&#125;); 退出1234567router.post(&#x27;/user/logout&#x27;, function(req, res, next) &#123; //清空cookie req.cookies.set(&quot;userInfo&quot;, &quot;&quot;); res.json(responseDate); return;&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"邮箱拖拽及删除","slug":"邮箱拖拽及删除","date":"2017-07-02T16:00:00.000Z","updated":"2020-09-16T09:07:16.000Z","comments":true,"path":"2017/07/03/邮箱拖拽及删除/","link":"","permalink":"http://mariogogogo.github.io/2017/07/03/%E9%82%AE%E7%AE%B1%E6%8B%96%E6%8B%BD%E5%8F%8A%E5%88%A0%E9%99%A4/","excerpt":"练习邮箱拖拽，及元素删除","text":"练习邮箱拖拽，及元素删除注意点; jq move 是在$(doucment) 火狐下阻止浏览器默认事件 需要ev.preventDefault();ev.stopPropagation(); 点击单选框的时候 如果鼠标down事件存在 则要阻止冒泡ev.stopPropagation(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131$(document).ready(function() &#123; var html = list.map(function(item) &#123; return `&lt;li data-id=$&#123;item.id&#125;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;div&gt; &lt;span&gt;$&#123;item.caption&#125;&lt;/span&gt; &lt;span&gt;$&#123;item.time&#125;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;$&#123;item.desc&#125;&lt;/p&gt; &lt;/li&gt;` &#125;).join(&quot; &quot;); var oUl = $(&quot;.emailListUl&quot;); oUl.html(html); //获取选中 var checkedlen = $(&quot;.emailListUl li input&quot;); //全选按钮 或者 全不选 var checkboxAll = $(&quot;.emailHead input&quot;); checkboxAll.on(&quot;click&quot;, function() &#123; var arrs = whoSelected(); console.log(arrs) $(&quot;.emailListUl li input&quot;).prop(&quot;checked&quot;, $(this).is(&#x27;:checked&#x27;)); if ($(this).is(&#x27;:checked&#x27;)) &#123; $(&quot;.emailListUl li&quot;).css(&quot;background&quot;, &quot;#f2f6f9&quot;); &#125; else &#123; $(&quot;.emailListUl li&quot;).css(&quot;background&quot;, &quot;&quot;); &#125; &#125;) //选中的input的个数 及下标 $(&quot;.emailListUl li input&quot;).on(&#x27;click&#x27;, function() &#123; if (!($(this).is(&#x27;:checked&#x27;))) &#123; $(&quot;.emailHead input&quot;).prop(&quot;checked&quot;, false); $(this).parent().css(&quot;background&quot;, &quot;&quot;); &#125; else &#123; $(this).parent().css(&quot;background&quot;, &quot;#f2f6f9&quot;); &#125; var arr = whoSelected(); if (arr.length == checkedlen.length) &#123; $(&quot;.emailHead input&quot;).prop(&quot;checked&quot;, true); &#125; $(this).parent().mousedown(function(ev) &#123; /* Act on the event */ //消灭冒泡 ev.stopPropagation(); &#125;); &#125;); // 用来获选中的input function whoSelected() &#123; var arr = []; checkedlen.each(function() &#123; if ($(this).is(&quot;:checked&quot;)) &#123; arr.push($(this)); &#125; &#125;); return arr; &#125; //删除 var delet = $(&quot;#delet&quot;); delet.on(&#x27;click&#x27;, function() &#123; htmldelete(); &#125;); function htmldelete() &#123; //点击并返回选择的个数； var selectArr = whoSelected(); console.log(selectArr) for (var i = 0; i &lt; selectArr.length; i++) &#123; selectArr[i].parent().remove(); // 删除被选中input的父级li for (var j = 0; j &lt; list.length; j++) &#123; if (list[j].id == selectArr[i]) &#123; //这里应该是后端返回ajax传送数据请求数据库删除 list.splice(i, 1); console.log(list); console.log(&#x27;删除成功&#x27;) &#125; &#125;; &#125;; &#125; //在某一点上limousedown会出现 tip var tip = $(&quot;#hint3&quot;); var lis = oUl.find(&quot;li&quot;); var beenDel = $(&quot;.beenDel&quot;); //删除 lis.mousedown(function(ev) &#123; var selectArr = whoSelected(); console.log(selectArr.length); if ($(this).find(&quot;input&quot;).is(&quot;:checked&quot;)) &#123; tip.show(); tip.css(&quot;left&quot;, ev.clientX + 4 + &quot;px&quot;); tip.css(&quot;top&quot;, ev.clientY + 4 + &quot;px&quot;); tip.html(&#x27;选中&#x27; + selectArr.length + &#x27;封邮件&#x27;); &#125; else &#123; return; &#125; //碰撞 默认没有碰到 var isCollision = false; //获取选中了几个 $(document).mousemove(function(ev) &#123; /* Act on the event */ tip.css(&quot;left&quot;, ev.clientX + &quot;px&quot;); tip.css(&quot;top&quot;, ev.clientY + &quot;px&quot;); ev.preventDefault(); //取消默认行为 if (collision($(&quot;#hint3&quot;), $(&quot;.beenDel&quot;))) &#123; isCollision = true; &#125; &#125;); $(document).mouseup(function() &#123; /* Act on the event */ tip.hide(); if (isCollision) &#123; //删除节点 htmldelete(); &#125; document.mouseover = document.mouseup = null; &#125;); &#125;)&#125;); 拖拽封装jquery转jsdom元素需要$(“id”)[0];1234567891011121314151617181920212223242526function getRect(obj)&#123; return obj[0].getBoundingClientRect(); &#125;function collision(obj1,obj2)&#123; var obj1Rect = getRect(obj1); var obj2Rect = getRect(obj2); //如果obj1碰上了哦obj2返回true，否则放回false var obj1Left = obj1Rect.left; var obj1Right = obj1Rect.right; var obj1Top = obj1Rect.top; var obj1Bottom = obj1Rect.bottom; var obj2Left = obj2Rect.left; var obj2Right = obj2Rect.right; var obj2Top = obj2Rect.top; var obj2Bottom = obj2Rect.bottom; if( obj1Right &lt; obj2Left || obj1Left &gt; obj2Right || obj1Bottom &lt; obj2Top || obj1Top &gt; obj2Bottom )&#123; return false; &#125;else&#123; return true; &#125;&#125;","categories":[{"name":"练习Demo","slug":"练习Demo","permalink":"http://mariogogogo.github.io/categories/%E7%BB%83%E4%B9%A0Demo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mariogogogo.github.io/tags/javascript/"},{"name":"练习","slug":"练习","permalink":"http://mariogogogo.github.io/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"NodeJs之短信发送","slug":"Node发送短信验证码","date":"2017-06-29T16:00:00.000Z","updated":"2020-09-16T09:07:41.000Z","comments":true,"path":"2017/06/30/Node发送短信验证码/","link":"","permalink":"http://mariogogogo.github.io/2017/06/30/Node%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"我们在平常的开发中经常会遇到在注册的时候要发送手机短信验证码，或者是在一些安全性校验的时候要发送手机短信验证码， 于是找了很多短信验证码平台，但是支持nodejs的平台很少，今天就介绍一个少有的支持node的短信验证平台","text":"我们在平常的开发中经常会遇到在注册的时候要发送手机短信验证码，或者是在一些安全性校验的时候要发送手机短信验证码， 于是找了很多短信验证码平台，但是支持nodejs的平台很少，今天就介绍一个少有的支持node的短信验证平台 前台js部分123456789101112$.ajax(&#123; type: &quot;POST&quot;, url: &quot;yunpian/sms&quot;, data: &#123; mobile: $(&quot;#mobile&quot;).val() &#125;, success: function(res) &#123; console.log(res); &#125;, error: function(res) &#123; console.log(res); &#125;&#125;); 后台js部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 修改为您的apikey.可在官网（https://www.yunpian.com)登录后获取var express = require(&quot;express&quot;);var router = express.Router();var request = require(&quot;request&quot;);// 修改为您要发送的手机号码，多个号码用逗号隔开// var mobile = &#x27;13083950500&#x27;;// 修改为您要发送的短信内容// var text = &#x27;【h5web开发者】您的验证码是666666。如非本人操作，请忽略本短信&#x27;;// 指定发送模板的内容var tpl_value = &#123; &#x27;#code#&#x27;: &#x27;1234&#x27;, &#x27;#company#&#x27;: &#x27;yunpian&#x27; &#125;;// 智能匹配模板发送https地址var sms_host = &#x27;sms.yunpian.com&#x27;;// 统一返回格式var responseData;router.use(function(req, res, next) &#123; responseData = &#123; code: 0, message: &#x27;&#x27; &#125;; next();&#125;);router.post(&quot;/sms&quot;, function(req, res,next) &#123; let apikey = &#x27;319c56f98891*******42a52836**0&#x27;; let mobile = req.body.mobile; let random = Math.ceil(Math.random()*1000000); let text = &#x27;【h5web开发者】您的验证码是$&#123;random&#125;。如非本人操作，请忽略本短信&#x27;; console.log(&quot;通过post&quot;); let options = &#123; hostname: sms_host, port: 443, url: &#x27;https://sms.yunpian.com/v2/sms/single_send.json&#x27;, method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27; &#125;, form:&#123; apikey:apikey, mobile:mobile, text:text, &#125; &#125; request(options,function(error,response,body)&#123; console.log(&quot;response&quot;+response); console.log(&quot;body&quot;+body); if (!error &amp;&amp; response.statusCode == 200) &#123; res.send(&#123; status:true, message:body, checkCode:random &#125;) &#125;else if (!error &amp;&amp; response.statusCode != 200) &#123; res.send(&#123; status:false, message:body &#125;) &#125;else&#123; res.send(&#123; status:false, message:error &#125;) &#125; &#125;)&#125;)module.exports = router;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"NodeJs之邮件发送","slug":"Node发送邮件","date":"2017-06-29T16:00:00.000Z","updated":"2020-09-16T09:07:41.000Z","comments":true,"path":"2017/06/30/Node发送邮件/","link":"","permalink":"http://mariogogogo.github.io/2017/06/30/Node%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","excerpt":"使用Nodejs收发电子邮件也非常简单，Nodemailer包就可以帮助快速实现发邮件的功能。","text":"使用Nodejs收发电子邮件也非常简单，Nodemailer包就可以帮助快速实现发邮件的功能。 前言 电子邮件，是互联网应用最广泛使用的服务之一，通过电子邮件系统，我们可以与世界上任何一个角落的网络用户进行联系。 前台js部分12node email.js 后台js部分安装==nodemailer==模块12npm install nodemailer安装==smtpTransport==模块 12npm install nodemailer-smtp-transport 123456789101112131415161718192021222324252627282930313233343536373839404142var nodemailer = require(&quot;nodemailer&quot;);var smtpTransport = require(&#x27;nodemailer-smtp-transport&#x27;);/*邮件发送*/// 开启一个 SMTP 连接池app.get(&#x27;/sendmail&#x27;, function(req, res) &#123; //依赖的两个模块 var nodemailer = require(&quot;nodemailer&quot;); var smtpTransport = require(&#x27;nodemailer-smtp-transport&#x27;); var to = &#x27;admin@xxx.com&#x27;; //发送地址 // var to=&#x27;admin@xxx.com,editor@xxx.com&#x27;; //发送给多个人，英文逗号隔开 var subject = &#x27;邮件标题&#x27;; //发送的标题 var html = &#x27;&lt;div&gt;邮件内容&lt;/div&gt;&#x27;; //发送的内容 var transport = nodemailer.createTransport(smtpTransport(&#123; host: &#x27;smtp.exmail.qq.com&#x27;, port: 465, secure: true, auth: &#123; user: &#x27;admin@xxx.com&#x27;, //你真实的邮箱 pass: &#x27;yyyy&#x27; //真实的密码 &#125; &#125;)); var mailOptions = &#123; from: &#x27;xxx &lt;no_reply@xxx.com&gt;&#x27;, to: to, subject: subject, html: html &#125;; transport.sendMail(mailOptions, function(error, info) &#123; if (error) &#123; res.send(error); &#125; else &#123; res.send(info.response); &#125; &#125;);&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"NodeJs之博客（三）","slug":"NodeJs之博客（三）","date":"2017-06-28T16:00:00.000Z","updated":"2020-09-16T09:07:42.000Z","comments":true,"path":"2017/06/29/NodeJs之博客（三）/","link":"","permalink":"http://mariogogogo.github.io/2017/06/29/NodeJs%E4%B9%8B%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"增加==cookie==与数据库==mongodb==","text":"增加==cookie==与数据库==mongodb== 启动数据库 app.js1234567891011121314151617181920212223242526272829303132333435363738394041/**更多数据*///加载cookies模块var Cookies = require(&#x27;cookies&#x27;);//加载数据库user表数据var User = require(&#x27;./models/User&#x27;);//设置cookieapp.use( function(req, res, next) &#123; req.cookies = new Cookies(req, res); //解析登录用户的cookie信息 req.userInfo = &#123;&#125;; if (req.cookies.get(&#x27;userInfo&#x27;)) &#123; try &#123; req.userInfo = JSON.parse(req.cookies.get(&#x27;userInfo&#x27;)); //获取当前登录用户的类型，是否是管理员 User.findById(req.userInfo._id).then(function(userInfo) &#123; req.userInfo.isAdmin = Boolean(userInfo.isAdmin); next(); &#125;) &#125;catch(e)&#123; next(); &#125; &#125; else &#123; next(); &#125;&#125; );。。。。。。//连接数据库mongoose.connect(&#x27;mongodb://localhost:27018/blog&#x27;, function(err) &#123; if (err) &#123; console.log(&#x27;数据库连接失败&#x27;); &#125; else &#123; console.log(&#x27;数据库连接成功&#x27;); app.listen(8081); &#125;&#125;); users.js12345678910111213141516var mongoose = require(&#x27;mongoose&#x27;);//用户的表结构module.exports = new mongoose.Schema(&#123; //用户名 username: String, //密码 password: String, //是否是管理员 isAdmin: &#123; type: Boolean, default: false &#125;&#125;); 创建用户登录及注册的数据库表实际操作过程中不是操作表结构而是操作模型类所以还要创建一个模型类数据==model== 12345var mongoose = require(&#x27;mongoose&#x27;);var usersSchema = require(&#x27;../schemas/users&#x27;);//moudlue下创建一个模型module.exports = mongoose.model(&#x27;User&#x27;, usersSchema);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"NodeJs之博客（二）","slug":"NodeJs之博客（二）","date":"2017-06-27T16:00:00.000Z","updated":"2020-09-16T09:07:42.000Z","comments":true,"path":"2017/06/28/NodeJs之博客（二）/","link":"","permalink":"http://mariogogogo.github.io/2017/06/28/NodeJs%E4%B9%8B%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"增加第三方模块","text":"增加第三方模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Created by 毅 on 2016/7/30. * 应用程序的启动（入口）文件 *///加载express模块var express = require(&#x27;express&#x27;);//加载模板处理模块var swig = require(&#x27;swig&#x27;);//加载数据库模块var mongoose = require(&#x27;mongoose&#x27;);//加载body-parser，用来处理post提交过来的数据var bodyParser = require(&#x27;body-parser&#x27;);//加载cookies模块var Cookies = require(&#x27;cookies&#x27;);//创建app应用 =&gt; NodeJS Http.createServer();var app = express();//设置静态文件托管 处理 js css//当用户访问的url以/public开始，那么直接返回对应__dirname + &#x27;/public&#x27;下的文件app.use( &#x27;/public&#x27;, express.static( __dirname + &#x27;/public&#x27;) );//配置应用模板//定义当前应用所使用的模板引擎//第一个参数：模板引擎的名称，同时也是模板文件的后缀，第二个参数表示用于解析处理模板内容的方法app.engine(&#x27;html&#x27;, swig.renderFile);//设置模板文件存放的目录，第一个参数必须是views，第二个参数是目录app.set(&#x27;views&#x27;, &#x27;./views&#x27;);//注册所使用的模板引擎，第一个参数必须是 view engine，第二个参数和app.engine这个方法中定义的模板引擎的名称（第一个参数）是一致的app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);//在开发过程中，需要取消模板缓存swig.setDefaults(&#123;cache: false&#125;);//bodyparser设置 去除缓存app.use( bodyParser.urlencoded(&#123;extended: true&#125;) );/** 根据不同的功能划分模块* */app.use(&#x27;/admin&#x27;, require(&#x27;./routers/admin&#x27;));app.use(&#x27;/api&#x27;, require(&#x27;./routers/api&#x27;));app.use(&#x27;/&#x27;, require(&#x27;./routers/main&#x27;));//监听http请求app.listen(8081);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"NodeJs之博客（一）","slug":"NodeJs之博客（一）","date":"2017-06-26T16:00:00.000Z","updated":"2020-09-16T09:07:43.000Z","comments":true,"path":"2017/06/27/NodeJs之博客（一）/","link":"","permalink":"http://mariogogogo.github.io/2017/06/27/NodeJs%E4%B9%8B%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"做一个博客项目学习下","text":"做一个博客项目学习下 什么是ＮodeJs JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。 每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。 NodeJs有什么用处 当时在公司学习node的时候一听说可以直接运行Js文件就觉得很给力，但在接触新知识时首先关心的是有什么用处，以及能带来什么价值． NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。 如他所愿，NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。 因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。 NodeJS生态圈正欣欣向荣。 NodeJs特点模块 编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。 requirerequire函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。 exportsexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。 module通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。 1234567891011121314151617181920212223/** * 应用程序的启动（入口）文件 *///加载express模块var express = require(&#x27;express&#x27;);//加载模板处理模块var swig = require(&#x27;swig&#x27;);//加载数据库模块var mongoose = require(&#x27;mongoose&#x27;);//加载body-parser，用来处理post提交过来的数据var bodyParser = require(&#x27;body-parser&#x27;);//创建app应用 =&gt; NodeJS Http.createServer();var app = express();app.get(&quot;/&quot;,function(req,res,next)&#123; res.send(&quot;&lt;h2&gt;欢迎来的我的博客&lt;/h2&gt;&quot;)&#125;)//监听http请求app.listen(8081);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"发送短信验证，后按钮倒计时，防止刷新倒计时失效","slug":"发送短信验证，后按钮倒计时，防止刷新倒计时失效","date":"2017-06-25T16:00:00.000Z","updated":"2020-09-16T09:07:02.000Z","comments":true,"path":"2017/06/26/发送短信验证，后按钮倒计时，防止刷新倒计时失效/","link":"","permalink":"http://mariogogogo.github.io/2017/06/26/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%90%8E%E6%8C%89%E9%92%AE%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%88%B7%E6%96%B0%E5%80%92%E8%AE%A1%E6%97%B6%E5%A4%B1%E6%95%88/","excerpt":"在开发“发送短信验证”功能时候，要解决一个问题，防止恶意或频繁发送短信验证码问题。一般原理是“当点击发送按钮时，发送ajax请求到服务器发送短信验证码，成功则把发送按钮设置为不可点击，并且调用定时器，按钮显示倒计时”。如果就这样不对倒计时存储做处理，那么当刷新页面，会出现倒计时失效，按钮可点击。提供以下解决方案： 利用cookie存储倒计时 利用HTML5的localStorage 存储倒计时","text":"在开发“发送短信验证”功能时候，要解决一个问题，防止恶意或频繁发送短信验证码问题。一般原理是“当点击发送按钮时，发送ajax请求到服务器发送短信验证码，成功则把发送按钮设置为不可点击，并且调用定时器，按钮显示倒计时”。如果就这样不对倒计时存储做处理，那么当刷新页面，会出现倒计时失效，按钮可点击。提供以下解决方案： 利用cookie存储倒计时 利用HTML5的localStorage 存储倒计时 代码：123456789101112131415161718192021222324252627282930313233343536373839404142$(function() &#123; /*防刷新：检测是否存在cookie*/ if ($.cookie(&quot;captcha&quot;)) &#123; var count = $.cookie(&quot;captcha&quot;); var btn = $(&#x27;#getting&#x27;); btn.val(count + &#x27;秒后可重新获取&#x27;).attr(&#x27;disabled&#x27;, true).css(&#x27;cursor&#x27;, &#x27;not-allowed&#x27;); var resend = setInterval(function() &#123; count--; if (count &gt; 0) &#123; btn.val(count + &#x27;秒后可重新获取&#x27;).attr(&#x27;disabled&#x27;, true).css(&#x27;cursor&#x27;, &#x27;not-allowed&#x27;); $.cookie(&quot;captcha&quot;, count, &#123; path: &#x27;/&#x27;, expires: (1 / 86400) * count &#125;); &#125; else &#123; clearInterval(resend); btn.val(&quot;获取验证码&quot;).removeClass(&#x27;disabled&#x27;).removeAttr(&#x27;disabled style&#x27;); &#125; &#125;, 1000); &#125; /*点击改变按钮状态，已经简略掉ajax发送短信验证的代码*/ // 我们来试试这个效果的 $(&#x27;#getting&#x27;).click(function() &#123; var count = 10; var resend = setInterval(function() &#123; count--; if (count &gt; 0) &#123; $(this).val(count + &quot;秒后可重新获取&quot;); $.cookie(&quot;captcha&quot;, count, &#123; path: &#x27;/&#x27;, expires: (1 / 86400) * count &#125;); &#125; else &#123; clearInterval(resend); $(this).val(&quot;获取验证码&quot;).removeAttr(&#x27;disabled&#x27;); &#125; &#125;, 1000); $(this).attr(&#x27;disabled&#x27;, true).css(&#x27;cursor&#x27;, &#x27;not-allowed&#x27;); &#125;);&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://mariogogogo.github.io/tags/Jquery/"}]},{"title":"10 个常见的 Node.js 面试题","slug":"10个常见的Node.js面试题","date":"2017-06-18T16:00:00.000Z","updated":"2021-02-18T06:09:04.000Z","comments":true,"path":"2017/06/19/10个常见的Node.js面试题/","link":"","permalink":"http://mariogogogo.github.io/2017/06/19/10%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84Node.js%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"如果你希望找一份有关 Node.js 的工作，但又不知道从哪里入手评测自己对 node.js 的掌握程度。 本文就为你罗列了 10 个常见的 Node.js 面试题，分别考察了 Node.js 编程相关的几个主要方面。 在进入正文之前，需要提前声明两点： 这些问题只是Node.js知识体系的一个局部，并不能完全考察被面试者的实际开发能力。 对现实世界开发中遇到的问题，需要的是随机应变与团队合作，所以你可以尝试结对编程。 Node.js 面试题列表 什么是错误优先的回调函数？ 如何避免回调地狱？ 如何用Node来监听80端口？ 什么是事件循环？ 哪些工具可以用来保证一致的编程风格？ 运算错误与程序员错误的区别？ 使用NPM有哪些好处？ 什么是stub？举个使用场景？ 什么是测试金字塔？对于HTTP API，如何利用测试金字塔？ 你最喜欢的HTTP框架，并说明原因？ 现在，我们依次来解答这些问题吧。 什么是错误优先的回调函数？ 错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。例如： fs.readFile(filePath, function(err, data) {if (err) {//handle the error}// use the data object}); 解析：这个题目的主要作用在于检查被面试者对于 Node 中异步操作的一些基本知识的掌握。如何避免回调地狱 你可以有如下几个方法： 模块化：将回调函数分割为独立的函数 使用Promises 使用yield来计算生成器或Promise 解析：这个问题有很多种答案，取决你使用的场景，例如 ES6, ES7，或者一些控制流库。如何用 Node 监听 80 端口 这题有陷阱！在类 Unix 系统中你不应该尝试去监听 80 端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 目前，如果你一定要让你的应用监听 80 端口的话，你可以有通过在 Node 应用的前方再增加一层反向代理 （例如 nginx）来实现，如下图所示。否则，建议你直接监听大于 1024 的端口。 Reverse Proxy 方向代理指的是以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。 关于反向代理的更多内容，建议你阅读这篇文章。 关于如何利用 nginx 来为 node 配置方向代理的实践，可以参考这篇博文。 解释：这个问题用于检查被面试者是否有实际运行 Node 应用的经验。什么是事件循环 Node 采用的是单线程的处理机制（所有的 I/O 请求都采用非阻塞的工作方式），至少从 Node.js 开发者的角度是这样的。 而在底层，Node.js 借助 libuv 来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node 可以借助 livuv 来来实现多线程。下图表示了 Node 和 libuv 的关系。 Libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环， 以异步的方式将任务的执行结果返回给 V8 引擎。可以简单用下面这张图来表示。 （图片来源于网络） 每一个 I/O 都需要一个回调函数——一旦执行完便推到事件循环上用于执行。 如果你需要更多详细的解释，可以参考这个视频。 你也可以参考这篇文章。 解释：这用于检查 Node.js 的底层知识，例如什么是 libuv，它的作用是什么。哪些工具可以用来保证一致性的代码风格 你可以选择如下的工具： JSLint JSHint ESLint JSCS - 推荐 在团队开发中，这些工具对于编写代码非常的有帮助，能够帮助团队开发者强制执行规定的风格指南， 还能够通过静态分析捕获常见的错误。 解析：用于检查被面试者是否有大型项目开发经验。运算错误与程序员错误的区别 运算错误并不是 bug，这是和系统相关的问题，例如请求超时或者硬件故障。而程序员错误就是所谓的 bug。 解析：这个题目和 Node 关系并不大，用于考察面试者的基础知识。使用 NPM 有哪些好处？ 通过 NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于 Node 应用开发而言，你可以通过 package.json 文件来管理项目信息，配置脚本， 以及指明项目依赖的具体版本。 关于 NPM 的更多信息，你可以参考官方文档。 解析：它能考察面试者使用 npm 命令的基础知识和 Node.js 开发的实际经验。什么是 Stub？举个使用场景 Stub 是用于模拟一个组件或模块的函数或程序。在测试用例中， 简单的说，你可以用 Stub 去模拟一个方法，从而避免调用真实的方法， 使用 Stub 你还可以返回虚构的结果。你可以配合断言使用 Stub。 举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时： var fs = require(‘fs’); var readFileStub = sinon.stub(fs, ‘readFile’, function (path, cb) {return cb(null, ‘filecontent’);}); expect(readFileStub).to.be.called;readFileStub.restore(); 在单元测试中：Stub是完全模拟一个外部依赖，而Mock常用来判断测试通过还是失败。 有关 Node.js 的单元测试小结，你可以参考这个链接。 解析：用于测试被面试者是否有测试的经验。如果被面试者知道什么是 Stub， 那么可以继续问他是如何做单元测试的。什么是测试金字塔？ 测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。 当我们谈到 HTTP API 时，我们可能会涉及到： 有很多针对模型的底层单元测试 但你需要测试模型间如何交互时，需要减少集成测试 解析：本文主要考察被面试者的在测试方面的经验。你最喜欢的 HTTP 框架以及原因 这题没有唯一的答案。本题主要考察被面试者对于他所使用的 Node 框架的理解程度， 考察他是否能够给出选择该框架的理由，优缺点等。常用的 HTTP 框架你可以参考这个网站。","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://mariogogogo.github.io/tags/NodeJs/"}]},{"title":"jQuery页面加载后居中显示消息框的方法","slug":"jQuery页面加载后居中显示消息框的方法","date":"2017-06-18T16:00:00.000Z","updated":"2020-09-16T09:07:38.000Z","comments":true,"path":"2017/06/19/jQuery页面加载后居中显示消息框的方法/","link":"","permalink":"http://mariogogogo.github.io/2017/06/19/jQuery%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%90%8E%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%E6%B6%88%E6%81%AF%E6%A1%86%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"效果图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$(document).ready(function() &#123;$(&#x27;.btn&#x27;).click(function() &#123; $(&#x27;.mask&#x27;).css(&#123; &#x27;display&#x27;: &#x27;block&#x27; &#125;); center($(&#x27;.mess&#x27;)); check($(this).parent(), $(&#x27;.btn1&#x27;), $(&#x27;.btn2&#x27;));&#125;);// 居中function center(obj) &#123; var screenWidth = $(window).width(), screenHeight = $(window).height(); //当前浏览器窗口的 宽高 var scrolltop = $(document).scrollTop(); //获取当前窗口距离页面顶部高度 var objLeft = (screenWidth - obj.width()) / 2; var objTop = (screenHeight - obj.height()) / 2 + scrolltop; console.log(scrolltop); obj.css(&#123; left: objLeft + &#x27;px&#x27;, top: objTop + &#x27;px&#x27;, &#x27;display&#x27;: &#x27;block&#x27; &#125;); //当窗口大小发生改变浏览器窗口大小改变时 $(window).resize(function() &#123; screenWidth = $(window).width(); screenHeight = $(window).height(); scrolltop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; objTop = (screenHeight - obj.height()) / 2 + scrolltop; obj.css(&#123; left: objLeft + &#x27;px&#x27;, top: objTop + &#x27;px&#x27;, &#x27;display&#x27;: &#x27;block&#x27; &#125;); &#125;); //当浏览器有滚动条时的操作、 $(window).scroll(function() &#123; screenWidth = $(window).width(); screenHeight = $(window).height(); scrolltop = $(document).scrollTop(); objLeft = (screenWidth - obj.width()) / 2; objTop = (screenHeight - obj.height()) / 2 + scrolltop; obj.css(&#123; left: objLeft + &#x27;px&#x27;, top: objTop + &#x27;px&#x27;, &#x27;display&#x27;: &#x27;block&#x27; &#125;); &#125;);&#125;//确定取消的操作function check(obj, obj1, obj2) &#123; obj1.click(function() &#123; obj.remove(); closed($(&#x27;.mask&#x27;), $(&#x27;.mess&#x27;)); &#125;); obj2.click(function() &#123; closed($(&#x27;.mask&#x27;), $(&#x27;.mess&#x27;)); &#125;);&#125;// 隐藏 的操作function closed(obj1, obj2) &#123; obj1.hide(); obj2.hide();&#125;&#125;); 12345678910&lt;body style=&quot;height:2000px&quot;&gt;&lt;h2&gt;jQuery页面加载后居中显示消息框的方法&lt;/h2&gt;&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;单击弹出消息框&quot; /&gt;&lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;&lt;div class=&quot;mess&quot;&gt; &lt;p&gt;确定要删除吗？&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;确定&quot; class=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;取消&quot; class=&quot;btn2&quot; /&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223.mask &#123;position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: #000;opacity: 0.5;filter: alpha(opacity=50);display: none;z-index: 99;&#125;.mess &#123;position: absolute;display: none;width: 250px;height: 100px;border: 1px solid #ccc;background: #ececec;text-align: center;z-index: 101;&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://mariogogogo.github.io/tags/Jquery/"}]},{"title":"跨域之百度搜索框","slug":"跨域之百度搜索框","date":"2017-06-15T16:00:00.000Z","updated":"2020-09-16T09:07:06.000Z","comments":true,"path":"2017/06/16/跨域之百度搜索框/","link":"","permalink":"http://mariogogogo.github.io/2017/06/16/%E8%B7%A8%E5%9F%9F%E4%B9%8B%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%A1%86/","excerpt":"","text":"跨域的问题 域：域名 跨域请求（访问）：一个域名下的文件请求另外一个域名下的资源，就产生了跨域 跨域的解决:Jsonp : json padding 标签src的作用 ： 加载（包含指定的外部文件）可以跨域包含被包含的资源可以是任何类型的文件(可以是txt,php等)他只关注被包含的文件的内容是否是合法的JS原理定义函数包含外部文件，在被包含的文件中执行调用定义好的函数参数的（数据）的实现问题：包含就调用，通过动态创建实现按需调用问题：包含动态文件时可以通过一个接口实现按需生成调用函数名称 效果图： 代码：1234567891011121314151617181920212223242526272829303132function serch(data) &#123;var oul = $(&quot;#ul1&quot;);var html = &quot;&quot;;if (data.s.length) &#123; oul.show(); for (var i = 0; i &lt; data.s.length; i++) &#123; if (i &lt; 6) &#123; html += &#x27;&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.baidu.com/s?wd=&#x27; + data.s[i] + &#x27;&quot;&gt;&#x27; + data.s[i] + &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;; &#125; &#125; oul.append(html);&#125; else &#123; oul.hide();&#125;&#125;;$(function() &#123;var oq = $(&quot;#q&quot;);var oul = $(&quot;#ul1&quot;);oq.on(&quot;keyup&quot;, function() &#123; oul.empty(); if (this.value != &quot;&quot;) &#123; var oScript = document.createElement(&quot;script&quot;); oScript.src = &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot; + $(this).val() + &quot;&amp;cb=serch&quot;; document.body.appendChild(oScript); &#125; else &#123; oul.hide(); &#125;&#125;)&#125;) 123&lt;input type=&quot;text&quot; name=&quot;q&quot; id=&quot;q&quot; value=&quot;&quot;&gt;&lt;ul id=&quot;ul1&quot;&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425262728#q &#123; width: 300px; height: 30px; padding: 5px; border: 1px solid #f90; font-size: 16px; &#125; #ul1 &#123; border: 1px solid #f90; width: 310px; margin: 0; padding: 0; display: none; &#125; li a &#123; line-height: 30px; padding: 5px; text-decoration: none; color: black; display: block; &#125; li a:hover &#123; background: #f90; color: white; &#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"ES6（六）","slug":"ES6（六）","date":"2017-05-23T16:00:00.000Z","updated":"2020-09-16T09:07:19.000Z","comments":true,"path":"2017/05/24/ES6（六）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/24/ES6%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"class的的继承 1234#canvas &#123; border: 1px solid black; &#125; 12&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113var num = 1.897;console.log(~~num); //1，去除小数点后面的数字//下面是简单的解释：// Math.random()函数返回的是0到1之间的随机数。（不包括0和1本身），用该函数乘以你设定的max值减去min值所得的差，即是按照自己指定的倍数放大这个random值。\\// 接着为了从min值开始，必须在Math.random()*(max - min)之后加上min值本身。（max值表示最大值，min值表示最小值）var arrs = [1, 10];console.log(Math.max(...arrs));//class继承/** * class 的继承等相关知识 */// extends、 static、 superconst canvas = document.querySelector(&#x27;#canvas&#x27;);const ctx = canvas.getContext(&#x27;2d&#x27;);const w = canvas.width = 600;const h = canvas.height = 400;class Ball &#123; constructor(x, y, r) &#123; this.x = x; this.y = y; this.r = r; this.color = `rgb($&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;)`; return this; &#125;; //渲染方法 render(ctx) &#123; ctx.save(); ctx.translate(this.x, this.y); //小球坐标 ctx.fillStyle = this.color; //指定颜色 ctx.beginPath(); //起始路径 ctx.arc(0, 0, this.r, 0, 2 * Math.PI); //绘制路径 ctx.fill(); //填充颜色 ctx.restore(); //恢复绘图环境 return this; &#125;; // 思忒可 关键字 生成静态方法 挂载到类当中的方法 static rpFn(arr) &#123; // Ball.rpFn([1, 10]) let max = Math.max(...arr), //扩展运算符 min = Math.min(...arr); //随机数参数 return Math.random() * (max - min) + min; &#125;;&#125;// const ball1 = new Ball(100, 100, 30).render(ctx);//创建一个新类 extend函数 去继承 ball类class SuperBall extends Ball &#123; constructor(x, y, r) &#123; // Ball.call(this, x, y, r); // this.color = &#x27;red&#x27;; super(x, y, r); //super 之前使用 this 将指定undefined //子类继承父类 在构造函数中当成一个函数去使用 调用 //继承属性 及 方法 this.vy = SuperBall.rpFn([2, 4]); this.g = SuperBall.rpFn([0.2, 0.4]); //重力加速度 this.a = 0; return this; &#125;; move(ctx) &#123; // super(); // 非构造函数中报错 只能在构造函数当使用，并且调用了super就相当于使用了父类的方法 this.y += this.vy; //y轴坐标 this.vy += this.g; //============重力减速反弹方法============= let current = this.vy * -0.75; if (this.y + this.r &gt;= ctx.canvas.height) &#123; this.y = ctx.canvas.height - this.r; if (Math.abs(current - this.a) &lt; 0.05) return false; //============重力减速反弹方法============= this.a = this.vy *= -0.75; &#125;; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); super.render(ctx); //现在的super是对象 而不是函数 指向父类的原型对象， 自动绑定子类的this return true; &#125;&#125;;// const ball1 = new SuperBall(100, 100, 30).render(ctx);let ball, timer;canvas.onclick = function(e) &#123; let x = e.offsetX, y = e.offsetY; let r = ~~Ball.rpFn([15, 55]); //~~清除小数 //每次点击之前清除之前的小球 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ball = new SuperBall(x, y, r).render(ctx); ballMove(); //调用反弹运动&#125;function ballMove() &#123; timer = window.requestAnimationFrame(ballMove); if (!ball.move(ctx)) &#123; window.cancelAnimationFrame(timer); &#125;&#125; 知识点：重力减速 ，extends、 static、 super的继承的三个方法","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"ES6（五）","slug":"ES6（五）","date":"2017-05-22T16:00:00.000Z","updated":"2020-09-16T09:07:19.000Z","comments":true,"path":"2017/05/23/ES6（五）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/23/ES6%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"class的基本使用","text":"class的基本使用 JS语言的传统方法是通过构造函数，定义并生成新对象，是一种基于原型的面向对象系统。这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的人感到困惑。所以，在ES6中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。12345678910111213// 传统的构造函数模式 const Miaov = function(a, b) &#123; this.a = a; this.b = b; return this; &#125; Miaov.prototype = &#123; constructor: Miaov, print: function() &#123; console.log(this.a + &quot;, &quot; + this.b); &#125; &#125; var str = new Miaov(&quot;hello&quot;, &quot;js&quot;).print(); 1234567891011121314151617181920212223242526class Miaov &#123;//构造函数参数 指定构造函数是什么？不需要function es6语法constructor(a, b) &#123; this.a = a; this.b = b; return this;&#125;//定义类的方法直接方法名不需要function//不需要加分号分割//不需要prototype的方法上加方法print() &#123;console.log(this.a + &quot;&quot; + this.b);&#125;&#125;//实例化一个对象const miaov = new Miaov(&quot;hello&quot;, &quot;word&quot;).print();console.log(typeof Miaov); //functionconsole.log(Miaov.prototype);//定义在类中的方法 都不是可以被枚举的console.log(Object.keys(Miaov.prototype));class P &#123;&#125;;var p = new P();//constructior默认添加console.log(p);p(); //直接调用会报错","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"Javascript自定义事件","slug":"Javascript自定义事件","date":"2017-05-17T07:13:48.000Z","updated":"2020-09-16T09:07:38.000Z","comments":true,"path":"2017/05/17/Javascript自定义事件/","link":"","permalink":"http://mariogogogo.github.io/2017/05/17/Javascript%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/","excerpt":"自定义事件 : 主要是跟函数有关系,就是让函数能够具备事件的某些特性","text":"自定义事件 : 主要是跟函数有关系,就是让函数能够具备事件的某些特性 123&lt;div id=&quot;div1&quot;&gt;div&lt;/div&gt;&lt;span id=&quot;span1&quot;&gt;span&lt;/span&gt; 12345678910111213//自定义事件初级版window.addEventListener(&#x27;show&#x27;, function() &#123; alert(1);&#125;, false);window.addEventListener(&#x27;show&#x27;, function() &#123; alert(2);&#125;, false);window.addEventListener(&#x27;show&#x27;, function() &#123; alert(3);&#125;, false);show(); //主动触发自定义事件 //=====================================// 1234567891011121314151617181920212223242526272829303132333435363738394041424344window.onload = function() &#123; var oDiv = document.getElementById(&quot;div1&quot;); var oSpan = document.getElementById(&quot;span1&quot;); //小米对div封装的方法 bindEvent(oDiv, &quot;click&quot;, function() &#123; alert(1) &#125;); //华为对div封装的方法 bindEvent(oDiv, &quot;click&quot;, function() &#123; alert(2) &#125;); //小木对span封装的方法 bindEvent(oSpan, &quot;show&quot;, function() &#123; alert(3) &#125;); //苹果对span封装的方法 bindEvent(oSpan, &quot;show&quot;, function() &#123; alert(4) &#125;); //调用小木 和苹果的方法 fireEvent(oSpan, &quot;show&quot;);&#125;;function bindEvent(obj, events, fn) &#123; //找到obj所对应的事件 obj.listeners = obj.listeners || &#123;&#125;; obj.listeners[events] = obj.listeners[events] || []; obj.listeners[events].push(fn); console.log(obj.listeners[events]); if (obj.addEventListener) &#123; obj.addEventListener(events, fn, false); &#125; else &#123; obj.attachEvent(&#x27;on&#x27; + events, fn); &#125;&#125;;function fireEvent(obj, events) &#123; for (var i = 0; i &lt; obj.listeners[events].length; i++) &#123; obj.listeners[events][i](); &#125;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"},{"name":"事件","slug":"事件","permalink":"http://mariogogogo.github.io/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"面向对象基础（一）","slug":"面向对象基础（一）","date":"2017-05-12T07:13:48.000Z","updated":"2020-09-16T09:07:08.000Z","comments":true,"path":"2017/05/12/面向对象基础（一）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"基本方法类似css中的style属性面向对象方法css中的class属性","text":"基本方法类似css中的style属性面向对象方法css中的class属性 New的意义12345678910111213141516171819202122//当new去调用一个函数 : 这个时候函数中的this就是创建出来的对象,而且函数的的返回值直接就是this啦(隐式返回)//new后面调用的函数 : 叫做构造函数function CreatePerson(name)&#123; this.name = name; &#125;CreatePerson.prototype.showName = function()&#123; alert( this.name );&#125;;var p1 = new CreatePerson(&#x27;小明&#x27;);//p1.showName();var p2 = new CreatePerson(&#x27;小强&#x27;);//p2.showName();alert( p1.showName == p2.showName ); //truevar arr = new Array();var date = new Date(); 构造函数123456789function 构造函数()&#123; this.属性&#125;构造函数.原型.方法 = function()&#123;&#125;;var 对象1 = new 构造函数();对象1.方法(); 栗子： 先变型:尽量不要出现函数嵌套函数可以有全局变量把onload中不是赋值的语句放到单独函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*window.onload = function()&#123; var oParent = document.getElementById(&#x27;div1&#x27;); var aInput = oParent.getElementsByTagName(&#x27;input&#x27;); var aDiv = oParent.getElementsByTagName(&#x27;div&#x27;); for(var i=0;i&lt;aInput.length;i++)&#123; aInput[i].index = i; aInput[i].onclick = function()&#123; for(var i=0;i&lt;aInput.length;i++)&#123; aInput[i].className = &#x27;&#x27;; aDiv[i].style.display = &#x27;none&#x27;; &#125; this.className = &#x27;active&#x27;; aDiv[this.index].style.display = &#x27;block&#x27;; &#125;; &#125; &#125;;*///先变型://尽量不要出现函数嵌套函数//可以有全局变量//把onload中不是赋值的语句放到单独函数中var oParent = null;var aInput = null;var aDiv = null;window.onload = function()&#123; oParent = document.getElementById(&#x27;div1&#x27;); aInput = oParent.getElementsByTagName(&#x27;input&#x27;); aDiv = oParent.getElementsByTagName(&#x27;div&#x27;); init(); &#125;;function init()&#123; for(var i=0;i&lt;aInput.length;i++)&#123; aInput[i].index = i; aInput[i].onclick = change; &#125;&#125;function change()&#123; for(var i=0;i&lt;aInput.length;i++)&#123; aInput[i].className = &#x27;&#x27;; aDiv[i].style.display = &#x27;none&#x27;; &#125; this.className = &#x27;active&#x27;; aDiv[this.index].style.display = &#x27;block&#x27;;&#125; this指向复习++改this指向问题 : 事件或者是定时器,尽量让面向对象中的this指向对象++1234567891011121314151617oDiv.onclick = function()&#123; this : oDiv&#125;;oDiv.onclick = show;function show()&#123; this : oDiv&#125;oDiv.onclick = function()&#123; show();&#125;;function show()&#123; this : window&#125; 转化12345678910111213141516171819202122232425262728293031323334353637383940/*var arr = [4,7,1,3];arr.sort(); // 1 3 4 7var arr2 = [4,7,1,3];arr2.push(5);arr2.sort(); // 1 3 4 5 7*/window.onload = function()&#123; var t1 = new Tab(&#x27;div1&#x27;); t1.init();&#125;;function Tab(id)&#123; this.oParent = document.getElementById(id); this.aInput = this.oParent.getElementsByTagName(&#x27;input&#x27;); this.aDiv = this.oParent.getElementsByTagName(&#x27;div&#x27;); this.iNow = 0;&#125;Tab.prototype.init = function()&#123; var This = this; for(var i=0;i&lt;this.aInput.length;i++)&#123; this.aInput[i].index = i; this.aInput[i].onclick = function()&#123; This.change(this); &#125;; &#125;&#125;;Tab.prototype.change = function(obj)&#123; for(var i=0;i&lt;this.aInput.length;i++)&#123; this.aInput[i].className = &#x27;&#x27;; this.aDiv[i].style.display = &#x27;none&#x27;; &#125; obj.className = &#x27;active&#x27;; this.aDiv[obj.index].style.display = &#x27;block&#x27;;&#125;;","categories":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://mariogogogo.github.io/tags/OOP/"}]},{"title":"ES6（四）","slug":"ES6（四）","date":"2017-05-11T16:00:00.000Z","updated":"2020-09-16T09:07:19.000Z","comments":true,"path":"2017/05/12/ES6（四）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/12/ES6%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"map 储存 字典结构数据 键值对形式存储","text":"map 储存 字典结构数据 键值对形式存储 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt;var data1 = &#123;a: 1&#125;var data2 = &#123;b: 2&#125;;var obj = &#123;&#125;;obj[data1] = 1;obj[data2] = 2;console.log(obj);//obj转成字符串比较console.log(data1.toString() == data2.toString()); //true//========================================//创建mapconst map = new Map([[&quot;a&quot;, 1],[&quot;b&quot;, 2]])console.log(map);//map 方法map.set(&quot;miaov&quot;, 100)console.log(map);//重复添加key 会替换掉之前的值map.set(&quot;miaov&quot;, 200)console.log(map);//map。get方法console.log(map.get(&quot;miaov&quot;)); //200 否则undefined；// delete方法console.log(map.delete(&quot;a&quot;));// has(key)方法console.log(map.has(&quot;a&quot;));console.log(map.keys());console.log(map.values());map.forEach(function(key, value, map) &#123;console.log(key + &quot;:&quot; + value);&#125;)//map注意事项map.set(NaN, 10).set(NaN, 10);//NaN 是同一个键map.set(&#123;&#125;, &quot;x&quot;).set(&#123;&#125;, &quot;y&quot;);//由于内存地址不同，map认为是二个不同的键值。不用担心原来的属性重名；&lt;/script&gt;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"ES6（三）","slug":"ES6（三）","date":"2017-05-10T16:00:00.000Z","updated":"2020-09-16T09:07:19.000Z","comments":true,"path":"2017/05/11/ES6（三）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/11/ES6%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"set数据结构集合","text":"set数据结构集合1234567891011121314151617181920212223242526272829&lt;script&gt;//如何创建setconst s = new Set([1, 2, 3, [1, 2, 3], &#123; a: 1&#125;])console.log(s);//set属性console.log(s.size); //5//set方法s.add(&quot;2&quot;).add(&quot;3&quot;);console.log(s);//set删除s.delete(&quot;3&quot;);console.log(s);//set clear//console.log(s.clear());//返回键值对遍历器console.log(s.entries())s.forEach(function(value, key, set) &#123; console.log(value + &quot;miaov&quot;)&#125;);//未改变数据结构console.log(s) //============= //当重新添加一个重复数据s.add(1);console.log(s);//利用set 方法 解决数组去重&lt;/script&gt;","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"ES6（二）","slug":"ES6（二）","date":"2017-05-09T16:00:00.000Z","updated":"2020-09-16T09:07:18.000Z","comments":true,"path":"2017/05/10/ES6（二）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/10/ES6%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"基本概念：本质上就是一种==匹配模式==，只要等号==两边的模式相同==，那么左边的变量就可以被赋予对应的值。结构赋值主要分为：数组的解构赋值对象的结构赋值 基本类型的解构赋值 1234567let a = 1;let b = 2;let c = 3;let [a, b, c] = [1, 2, 3];console.log(a, b, c); 1 数组的解构赋值 123456789101112131415let [a, [[b], c]] = [1, [[2], 3]];console.log(a, b, c); // 1, 2, 3 let [, , c] = [1, 2, 3]; console.log(c); // 3let [x] = []; console.log(x); // let x; undefinedlet [y = 1] = []; console.log(y); // 1 2 对象的解构赋值 12345678let &#123;a, b&#125; = &#123;b: &#x27;bbb&#x27;, a: &#x27;aaa&#x27;&#125;;console.log(a, b);let &#123;a: b&#125; = &#123;a: 1&#125;;console.log(b); // 1console.log(a); // a is not defind 3 基本类型的解构赋值 1234567let [a, b, c, d] = &#x27;1234&#x27;; console.log(a, b, c, d); // 1,2,3,4let &#123;length: len&#125; = &#x27;miaov&#x27;;console.log(len); //4","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"ES6（一）","slug":"ES6（一）","date":"2017-05-09T07:13:48.000Z","updated":"2020-09-16T09:07:20.000Z","comments":true,"path":"2017/05/09/ES6（一）/","link":"","permalink":"http://mariogogogo.github.io/2017/05/09/ES6%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"基本语法let是块级作用域，函数内部使用let定义后，对函数外部无影响。1234567// 错误写法 变量提升不可以console.log(b);let b = 3;// 错误写法 变量不可重复赋值let a = 4;let a = 5console.log(a) 123456&lt;button type=&quot;1&quot;&gt;1&lt;/button&gt;&lt;button type=&quot;2&quot;&gt;2&lt;/button&gt;&lt;button type=&quot;3&quot;&gt;3&lt;/button&gt;&lt;button type=&quot;4&quot;&gt;4&lt;/button&gt;&lt;button type=&quot;5&quot;&gt;5&lt;/button&gt; 12345678910111213141516171819202122232425262728var btns = document.querySelectorAll(&quot;button&quot;); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; console.log(i) //永远等于i=5 &#125; &#125; //改变 for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].index = i; btns[i].onclick = function() &#123; console.log(this.index) &#125; &#125; //改变 for (var i = 0; i &lt; btns.length; i++) &#123; (function(i) &#123; btns[i].onclick = function() &#123; console.log(i) &#125; &#125;)(i); &#125; //改变 for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; console.log(i) //let创建出作用域块 &#125; &#125; const定义的变量不可以修改，而且必须初始化。1234567//在循环语句之内是一个父作用域，在循环体中是一个子作用域//例子：for (let i = 0; i &lt; 3; i++) &#123;let i = 10;console.log(i);&#125;console.log(i)123456789101112//const声明属性的时候必须赋值var a;let b;const c; //报错//改变常量的数据const a = 10;a = &#123;&#125;; //浏览器会报错 改变数据const a = &#123;obj: 10&#125;;a.obj = 20; //不会报错 只是修改对象数据 没有改变obj的引用","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"ES6新特性一览","slug":"ES6新特性一览","date":"2017-05-07T16:00:00.000Z","updated":"2020-09-16T09:07:20.000Z","comments":true,"path":"2017/05/08/ES6新特性一览/","link":"","permalink":"http://mariogogogo.github.io/2017/05/08/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/","excerpt":"","text":"","categories":[{"name":"Web","slug":"Web","permalink":"http://mariogogogo.github.io/categories/Web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://mariogogogo.github.io/tags/ES6/"}]},{"title":"用JS获取小数点后两位数字方法","slug":"用JS获取小数点后两位数字方法","date":"2017-05-07T07:13:48.000Z","updated":"2020-09-16T09:07:16.000Z","comments":true,"path":"2017/05/07/用JS获取小数点后两位数字方法/","link":"","permalink":"http://mariogogogo.github.io/2017/05/07/%E7%94%A8JS%E8%8E%B7%E5%8F%96%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E4%B8%A4%E4%BD%8D%E6%95%B0%E5%AD%97%E6%96%B9%E6%B3%95/","excerpt":"上周老师留下的一个小问题？用Javascript取小数点后两位，例取成3.1415926,如何做3.15？","text":"上周老师留下的一个小问题？用Javascript取小数点后两位，例取成3.1415926,如何做3.15？截取： [我就怎么干的………] 123456function get() &#123; var s = 22.127456 + &quot;&quot;; var str = s.substring(0,s.indexOf(&quot;.&quot;) + 3); alert(str); &#125; 正则表达式效果不错 123456789&lt;script type=&quot;text/javascript&quot;&gt; onload = function()&#123; var a = &quot;23.456322&quot;; var aNew; var re = /([0-9]+/.[0-9]&#123;2&#125;)[0-9]*/; aNew = a.replace(re,&quot;$1&quot;); alert(aNew); &#125; &lt;script&gt; 他就比较聪明了….. 1234&lt;script&gt; var num=22.127456; alert( Math.round(num*100)/100); &lt;script&gt; 会用新鲜东西的朋友……. 但是需要 IE5.5+才支持。 1234&lt;script&gt; var num=22.127456; alert( num.toFixed(2)); &lt;script&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"自定义滚动条","slug":"自定义滚动条","date":"2017-03-31T16:00:00.000Z","updated":"2020-09-16T09:07:17.000Z","comments":true,"path":"2017/04/01/自定义滚动条/","link":"","permalink":"http://mariogogogo.github.io/2017/04/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/","excerpt":"困扰的问题之一 clientHeight和offsetHeight的值由什么决定？假如我们有以下的DIV，主要显示的文字为”This is the main body of DIV”","text":"困扰的问题之一 clientHeight和offsetHeight的值由什么决定？假如我们有以下的DIV，主要显示的文字为”This is the main body of DIV”首先了解一下如下图所示， clientHeight的值由DIV内容的实际高度和CSS中的padding值决定， offsetHeight的值由DIV内容的实际高度，CSS中的padding值， scrollbar的高度和DIV的border值决定；至于CSS中的margin值，则不会影响clientHeight和offsetHeight的值。 效果图： 分析图 代码1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; *&#123; margin:0; padding:0; &#125; body&#123; overflow:hidden; &#125; #box&#123; float:right; top:0; right:0px; width:20px; height: 500px; background:#ccc; position:relative; &#125; #drag&#123; position: absolute; top:0; left:0; width:20px; height: 20px; background:green; &#125; #content&#123; position:absolute; left: 0; width: 400px; height: 500px; border: 1px solid black; overflow: hidden; &#125; #text&#123; position:absolute; top: 0; &#125;&lt;/style&gt; 1234567891011121314151617&lt;body&gt; &lt;!--滚动条--&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;drag&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- //内容主容器--&gt; &lt;div id=&quot;content&quot;&gt; &lt;!--内容容器--&gt; &lt;div id=&quot;text&quot; style=&quot;background:#ccc;width: 120px; &quot;&gt;Although many people talk about the super performance of quantum computing, such as one second to complete the current supercomputer computing tasks for several years, but so far did not create a true sense of the quantum computer, one of the very important reason is that, The state of particles used in quantum computation is not stable, and any electromagnetic or physical interference can easily disrupt its work. The state of the Mayola fermion is very stable, which makes it a perfect choice for making quantum computers. Six months ago in the laboratory of Shanghai Jiaotong University, Jia Jinfeng successfully captured it.Speaking of the scene, Jia Jinfeng said: &quot;In fact, I started to hear the Mayolana fermions, I think this thing may not be done 20 years out.Using a special material preparation method, Jia Jinfeng&#x27;s research team has grown topological insulators on the superconductors with thickness of 5 nanometers. The topological superconductor materials are prepared and finally the Mayolana fermions are found at the interface of the topological superconductors. The mysterious particles were captured 80 years, but also let Jia Jinfeng more firm with its confidence in the manufacture of quantum computers.Speaking of the future of the plan, Jia Jinfeng said: &quot;I hope to within a few years to do the topological quantum bit!&quot; (Before) the world has not, so if we cut into this from the point, we are the same with the world The starting line, for our country, this is able to catch up with the footsteps of quantum computing, a starting point. &lt;div&gt; &lt;/div&gt; &lt;/body&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;script type=&quot;text/javascript&quot;&gt;window.onload=function()&#123; var oBox=document.getElementById(&#x27;box&#x27;); var oDrag=document.getElementById(&#x27;drag&#x27;); var content=document.getElementById(&#x27;content&#x27;);//内容主容器 var oText = document.getElementById(&#x27;text&#x27;); var conHeight=content.clientHeight var textHeight = oText.clientHeight oDrag.onmousedown=function (ev)&#123; //阻止默认事件 var e=ev||window.event; if (e.preventDefault) &#123; e.preventDefault(); &#125; else&#123; e.returnValue=false; &#125;; //e.clientY鼠标当前坐标 var downY=e.clientY-oDrag.offsetTop; //滑块滚动最大距离 var maxTop = oBox.clientHeight-oDrag.clientHeight document.onmousemove=function (ev)&#123; var e=ev||window.event; var top=e.clientY-downY; if (top&lt;=0) &#123; top=0; &#125;; if (top&gt;=maxTop) &#123; top=maxTop; &#125;; var scale=top/maxTop; var contentY=scale*(conHeight-textHeight); oDrag.style.top=top+&#x27;px&#x27;; oText.style.top=contentY+&#x27;px&#x27;; &#125; document.onmouseup=function ()&#123; document.onmousemove=document.onmousemove=null; &#125; &#125; var str=window.navigator.userAgent.toLowerCase(); //火狐浏览器 if (str.indexOf(&#x27;firefox&#x27;)!=-1)&#123; document.addEventListener(&#x27;DOMMouseScroll&#x27;,function (e)&#123; e.preventDefault();//阻止窗口默认的滚动事件 if (e.detail&lt;0) &#123; //向上滚动 div向下滚动 var scrollHei=oText.offsetTop+25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(textHeight-conHeight)) &#123; scrollHei=-(textHeight-conHeight); &#125;; var scale=scrollHei/(textHeight-conHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); oText.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125; if (e.detail&gt;0) &#123; //向下滚动 div向上滚动 var scrollHei=oText.offsetTop-25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(textHeight-conHeight)) &#123; scrollHei=-(textHeight-conHeight); &#125;; var scale=scrollHei/(textHeight-content.clientHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); oText.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; &#125;,false); &#125; else&#123;//非火狐浏览器 console.log(&quot;非火狐浏览器&quot;) document.onmousewheel=function (ev)&#123; var e=ev||window.event; if (e.preventDefault) &#123; e.preventDefault(); &#125; else&#123; e.returnValue=false; &#125;; if (e.wheelDelta&gt;0) &#123; //向上滚动 此时div向下移动 var scrollHei=oText.offsetTop+25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(textHeight-conHeight)) &#123; scrollHei=-(textHeight-conHeight); &#125;; var scale=scrollHei/(textHeight-conHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); oText.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; if (e.wheelDelta&lt;0) &#123; //向下 console.log(&quot;下&quot;) var scrollHei=oText.offsetTop-25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(textHeight-conHeight)) &#123; scrollHei=-(textHeight-conHeight); &#125;; var scale=scrollHei/(textHeight-conHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); oText.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; &#125; &#125;&#125;&lt;/script&gt; 全屏模式下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;script type=&quot;text/javascript&quot;&gt;window.onload=function()&#123; var oBox=document.getElementById(&#x27;box&#x27;); var oDrag=document.getElementById(&#x27;drag&#x27;); var content=document.getElementById(&#x27;content&#x27;); var viewHeight=document.documentElement.clientHeight; var conHeight=content.clientHeight oBox.style.height=viewHeight+&#x27;px&#x27;; oDrag.style.height=viewHeight/conHeight*viewHeight+&#x27;px&#x27;; window.onresize = function()&#123; viewHeight=document.documentElement.clientHeight; oBox.style.height=viewHeight+&#x27;px&#x27;; oDrag.style.height=viewHeight/conHeight*viewHeight+&#x27;px&#x27;; oDrag.style.top=-content.offsetTop/(content.clientHeight-viewHeight)*(oBox.clientHeight-oDrag.clientHeight)+&#x27;px&#x27;; &#125; oDrag.onmousedown=function (ev)&#123; //阻止默认事件 var e=ev||window.event; if (e.preventDefault) &#123; e.preventDefault(); &#125; else&#123; e.returnValue=false; &#125;; //e.clientY鼠标当前坐标 var downY=e.clientY-oDrag.offsetTop; document.onmousemove=function (ev)&#123; var e=ev||window.event; var top=e.clientY-downY; if (top&lt;=0) &#123; top=0; &#125;; if (top&gt;=oBox.clientHeight-oDrag.clientHeight) &#123; top=oBox.clientHeight-oDrag.clientHeight; &#125;; var scale=top/(oBox.clientHeight-oDrag.clientHeight); var contentY=scale*(content.clientHeight-viewHeight); oDrag.style.top=top+&#x27;px&#x27;; content.style.top=-contentY+&#x27;px&#x27;; &#125; document.onmouseup=function ()&#123; document.onmousemove=null; &#125; &#125; var str=window.navigator.userAgent.toLowerCase(); //火狐浏览器 if (str.indexOf(&#x27;firefox&#x27;)!=-1)&#123; document.addEventListener(&#x27;DOMMouseScroll&#x27;,function (e)&#123; e.preventDefault();//阻止窗口默认的滚动事件 if (e.detail&lt;0) &#123; var scrollHei=content.offsetTop+25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(content.clientHeight-viewHeight)) &#123; scrollHei=-(content.clientHeight-viewHeight); &#125;; var scale=scrollHei/(content.clientHeight-viewHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); content.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125; if (e.detail&gt;0) &#123; var scrollHei=content.offsetTop-25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(content.clientHeight-viewHeight)) &#123; scrollHei=-(content.clientHeight-viewHeight); &#125;; var scale=scrollHei/(content.clientHeight-viewHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); content.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; &#125;,false); &#125; else&#123;//非火狐浏览器 document.onmousewheel=function (ev)&#123; var e=ev||window.event; if (e.preventDefault) &#123; e.preventDefault(); &#125; else&#123; e.returnValue=false; &#125;; if (e.wheelDelta&gt;0) &#123; var scrollHei=content.offsetTop+25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(content.clientHeight-viewHeight)) &#123; scrollHei=-(content.clientHeight-viewHeight); &#125;; var scale=scrollHei/(content.clientHeight-viewHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); content.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; if (e.wheelDelta&lt;0) &#123; var scrollHei=content.offsetTop-25; if (scrollHei&gt;=0) &#123; scrollHei=0; &#125;; if (scrollHei&lt;=-(content.clientHeight-viewHeight)) &#123; scrollHei=-(content.clientHeight-viewHeight); &#125;; var scale=scrollHei/(content.clientHeight-viewHeight); var top=scale*(oBox.clientHeight-oDrag.clientHeight); content.style.top=scrollHei+&#x27;px&#x27;; oDrag.style.top=-top+&#x27;px&#x27;; &#125;; &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/tags/Javascript/"}]},{"title":"Javascript 面向对象编程初探（一）--- 封装","slug":"Javascript 面向对象编程初探（一）--- 封装","date":"2016-06-07T16:00:00.000Z","updated":"2020-09-16T09:07:33.000Z","comments":true,"path":"2016/06/08/Javascript 面向对象编程初探（一）--- 封装/","link":"","permalink":"http://mariogogogo.github.io/2016/06/08/Javascript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89---%20%E5%B0%81%E8%A3%85/","excerpt":"Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。","text":"Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。 一、 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。 12345var Cat = &#123; name : &#x27;&#x27;, color : &#x27;&#x27; &#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。 123456var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值cat1.color = &quot;黄色&quot;;var cat2 = &#123;&#125;;cat2.name = &quot;二毛&quot;;cat2.color = &quot;黑色&quot;; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 二、 原始模式的改进我们可以写一个函数，解决代码重复的问题。 1234567function Cat(name,color) &#123; return &#123; name:name, color:color &#125; &#125; 然后生成实例对象，就等于是在调用函数： 12var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 三、 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 比如，猫的原型对象现在可以这样写， 12345function Cat(name,color)&#123; this.name=name; this.color=color; &#125; 我们现在就可以生成实例对象了。 12345var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;); var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;); alert(cat1.name); // 大毛 alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。 12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。 12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 四、构造函数模式的问题 构造函数方法很好用，但是存在一个浪费内存的问题。 请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样： 1234567function Cat(name,color)&#123; this.name = name; this.color = color; this.type = &quot;猫科动物&quot;; this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;; &#125; 还是采用同样的方法，生成实例： 1234var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;); var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;); alert(cat1.type); // 猫科动物 cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。 1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。 五、 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。 123456function Cat(name,color)&#123; this.name = name; this.color = color; &#125; Cat.prototype.type = &quot;猫科动物&quot;; Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;; 然后，生成实例。 1234 var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;); var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;); alert(cat1.type); // 猫科动物 cat1.eat(); // 吃老鼠 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 1alert(cat1.eat == cat2.eat); //true 六、 Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 6.1 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12 alert(cat1.hasOwnProperty(&quot;name&quot;)); // true alert(cat1.hasOwnProperty(&quot;type&quot;)); // false6.3 in运算符 in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。 12alert(&quot;name&quot; in cat1); // true alert(&quot;type&quot; in cat1); // true in运算符还可以用来遍历某个对象的所有属性。 123for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mariogogogo.github.io/categories/Javascript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"面向对象","slug":"面向对象","permalink":"http://mariogogogo.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"前端之路","slug":"前端之路","date":"2016-06-03T16:00:00.000Z","updated":"2020-09-16T09:07:11.000Z","comments":true,"path":"2016/06/04/前端之路/","link":"","permalink":"http://mariogogogo.github.io/2016/06/04/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/","excerpt":"种一棵树最好的年龄是十年前，而后是现在。","text":"种一棵树最好的年龄是十年前，而后是现在。 对自己狠一点，开始写作吧我时常会有这样的感觉:自己心里觉得对一个技术点已经掌握了，但是当我试图给别人讲述的时候，发现并不能轻松自如、深入浅出地讲出来。这就说明了一个问题 :自认为掌握了，其实并没有真正掌握，大脑只是对这个技术点建立了一个整体的概念，在一些细节处做了想当然的假设，等到你用语言再来表达的时候就会发现，原来这个假设并不完全成立是有问题的。估计大家都有这样的经验:如果你能把一门技术通俗易懂地给别人讲明白，那就说明你已经掌握了。这种“转教别人( Teach others )”的办法属于主动学习，效率是最高的。但是在工作和生活当中，你是很少有机会去给别人讲授的。那怎么办?那就退而求其次吧，把自己的理解写出来。当然不是泛泛地记流水账，或者把几个孤立的点罗列在那里，而是要把思路厘清楚，尤其要写出为什么要有这门技术、这门技术解决了什么问题，然后才是这门技术是怎么使用的。当你逼着自己去回答这些问题的时候，很快就会发现，自己的理解还不够，还需要查找更多的资料。 如何学习？举个例子，你接触到一个新的知识点: Java动态代理。你也看了书或视频中的代码，知道了这个技术点是怎么使用的，接下来想要写一篇文章，首先要努力阐明的问题就是“为什么要用Java 动态代理“。这玩意儿到底要干吗?我已经知道了它能够对一个类进行增强，还是在运行时进行增强的，但是增强一个类有什么用处?我完全可以新写一个类对原有的类进行增强啊? 为什么要在运行时进行增强呢?如果你顺着这个思路挖掘下去，则会在通道的尽头找到一个宝贝: AOP。 具体到技术层面，还有一个问题，就是为什么Java动态代理只能对interface 进行操作，而不能对class进行操作?这个问题如果也深挖下去，那么你会发现另一一个宝贝:动态字节码的生成。 继续深挖就能看到ASM、CGLib这样的东西，看到它们怎么在内存中操作.class文件的字节码。至于字节码的格式是什么样子的，只好去看看Java虚拟机了。到了最后，你也许会体会到，原来Java是一门静态语言，在运行时不能对现有的方法逻辑进行修改， 不能添加方法，所以必须用别的手段，如ASM、 动态代理等创建一 个新类来做一点“额外”的事情。 有人可能要问了:我也可以按照这个思路去学习，为什么要写下来呢?原因很简单，不写出来，很容易放弃深度思考。你会觉得，我已经知道是怎么回事儿了一-其实 些关键的细节被大脑给忽略了。 我们已经进入了一个碎片化的时代，我们的大脑已经养成了碎片化的习惯，-天不看 碎片化的信息就觉得不舒服，这样下去会慢慢地丧失深度思考的能力。 写作会逼着你去思考，梳理知识体系，防止自己被碎片所填满。其实很多人都知道写作是一件很好的事情，就是犯懒，执行不下去。还是行动起来吧!逼自己一把，对自己狠一-点!有自制力的人、能够坚持的人才更有可能成功! 参考引用《码农翻身》第6章最后2节","categories":[{"name":"心路历程","slug":"心路历程","permalink":"http://mariogogogo.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"Javascript，基础","slug":"Javascript，基础","permalink":"http://mariogogogo.github.io/tags/Javascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]},{"title":"『转载』为什么你应该（从现在开始就）写博客","slug":"[转载]为什么你应该（从现在开始就）写博客","date":"2009-08-07T16:00:00.000Z","updated":"2020-09-16T09:06:50.000Z","comments":true,"path":"2009/08/08/[转载]为什么你应该（从现在开始就）写博客/","link":"","permalink":"http://mariogogogo.github.io/2009/08/08/[%E8%BD%AC%E8%BD%BD]%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%EF%BC%88%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B%E5%B0%B1%EF%BC%89%E5%86%99%E5%8D%9A%E5%AE%A2/","excerpt":"（一）为什么你应该（从现在开始就）写博客用一句话来说就是，写一个博客有很多好处，却没有任何明显的坏处。（阿灵顿的情况属于例外，而非常态，就像不能拿抽烟活到一百岁的英国老太太的个例来反驳抽烟对健康的极大损伤一样)","text":"（一）为什么你应该（从现在开始就）写博客用一句话来说就是，写一个博客有很多好处，却没有任何明显的坏处。（阿灵顿的情况属于例外，而非常态，就像不能拿抽烟活到一百岁的英国老太太的个例来反驳抽烟对健康的极大损伤一样) 让我说得更明确一点：用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。Note：碎碎念不算思考、心情琐记不算思考、唠唠叨叨也不算思考、没话找话也不算思考，请以此类推。 下面是我个人认为写一个长期的价值博客的最大的几点好处： 能够交到很多志同道合的朋友。我自己既写博客，也读别人的博客，在这个时代，对于生活中的绝大多数人来说，拓宽朋友圈子的途径几乎只有一个，通过网络，而如何在网络中寻找到气味相投的朋友，如何判断别人和自己是否有共同语言？显然，通过天天在 SNS 上碎碎念的那些日记是难以做到的。我佩服的一些朋友几乎全都是长期用博客记录想法的人，因此，和他们即便不打照面，也是心照不宣。即便素未谋面也能坐下来就聊得热火朝天。 为什么博客在结交志同道合的朋友方面的潜力要远胜于原始的交谈方式？ 很简单，第一，博客无地域限制，整个互联网上从 A 到 B 只有一个点击的距离，而传统的建立朋友圈子的方法则受到地域限制。 第二，也是更重要的一点，即如果按照以前结交朋友的方式，需要互相聊天，交流观点，然后才逐渐熟悉起来，这需要一个较长的过程，而且更糟糕的是，当你遇到另一个陌生人，又要把整个过程重复一次，表达你已经对老友表达过的那番想法。可博客却做到了“一次表达，无数次阅读”，当我看到一个写了好几年的博客，看完了之后我仿佛和这个人交谈了很久，用程序员们喜欢听的话来说就是，“博客极大地增强了话语的复用性”。 我曾在 CSDN 上写了近六年的博客，在一年半前建立了一个 Google Groups（TopLanguage），由于我的博客的长期阅读者都是互相有共同语言的，因此这个 Group 一开始就热火朝天，而高质量的技术讨论则进一步吸引了更多的牛人的参与，雪球滚起来之后，就很难停下来了，将近一年半下来，从这个 Group 的讨论中我获益良多[1]。而对于非程序员朋友，科学松鼠会则是一个很好的例子。 书写是为了更好的思考。我在《书写是为了更好的思考》里面详细总结了书写的好处，这里就不拷贝粘贴了。有些想法如果不写下来，也就忘掉了，有一个广为流传的《数学牛人们的轶事》（荣耀属于 ukim）里面讲了希尔伯特的一个故事：一次在 Hilbert 的讨论班上，一个年轻人报告，其中用了一个很漂亮的定理，Hilbert 说“这真是一个妙不可言（wunderbaschon）的定理呀,是谁发现的？”那个年轻人茫然的站了很久，对 Hilbert 说：“是你.……”。 “教”是最好的“学”。如果一件事情你不能讲清楚，十有八九你还没有完全理解。绝大多数人应该都知道在程序员行业面试官经常要求你讲解一个东西给他听，他会说他不懂这个东西（他如果真的不懂的话效果其实是最好的），而你的任务则是说到让他理解为止。 为了让一个不明白的人做到明白，你必须要知道从明白到不明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中整个的知识体系来个寻根究底，把藏在水面之下的那些东西统统挖出来，把大脑中的那些我们知道、但不知道自己知道的潜在概念或假设（assumptions）都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道、并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。 但是，你可能会怀疑，那除了能够讲清楚之外，弄清自己到底知道哪些东西还有其他什么好处吗？如果没有其他好处，那我又何必费这个劲呢？我又不当老师。 TopLanguage 上的一位朋友 sagasw 曾经讲了这样一个小故事：据说在某个著名软件公司里，开发组的桌上会放着一只小熊，大家互相问问题之前，先对着小熊把问题说一遍，看能不能把问题描述的清晰，基本上说的比较有条理以后，答案也就随之而来了。当然，你不一定要对小熊说，你可以在大脑中虚构一个听众，一个不懂行的听众，然后你说给他听。这是可行的，我经常在路上用。不过如果你能坐下来，我建议你还是说给实际的听众听——即写下你的思考，因为书写是更好的思考。 我们的绝大多数知识在绝大多数时候都隐藏在潜意识中，其实我们意识的窗口很小，我们的工作记忆只能容纳寥寥数个条目（记得那个“看你能够记住屏幕上同时闪现的多少个数字”的 flash 小游戏吗？），我们平时所作的推理过程很大部分都是自动的，发生在潜意识中，而我们只能感知到一些中间结论。不信你回忆一下你在和别人讨论问题的时候有多少次觉得“反正就是这样，我感觉得到它是对的，但是你问我，我也说不清到底怎么回事”，对此你不觉得很奇怪吗？如果你都不能从逻辑上支持你的结论，你怎么就能确信它是对的呢？仅仅因为你的直觉强烈地告诉你它是对的？那如果旁边有另一个人，他和你持相反的观念，而他的直觉也强烈地告诉他他是对的。这时候你又怎么想？“他的直觉错了，我的直觉是对的”？难道你这么自信你的直觉是世界上最可靠的？ 我自己则是非常珍惜类似这样的机会，即当“我强烈地觉得它是对的，但我却说不出所以然来”，这时候往往是到大脑中翻箱倒柜的时候，弄清来龙去脉的时候，深入反思的时候，纠正一直以来错误的潜在前提假设的时候。另一方面，“我强烈地觉得这个说法有问题，但我却说不清它为什么有问题，到底哪有问题”，这也是一个极有意义的瞬间，它几乎总是意味着你对一个问题的认识有潜在的偏差，肯定是在你自己都没有觉知到的地方引入了一个潜在的假设、偷换了一个重要的概念，等等。而这种时候就是深入反思的时候，当你终于潜到问题的底层，触摸到问题的实质，把水面之下的冰山整体看清了的时候你会有一种通体舒泰的感觉。 为什么说以上这些？因为刚才说的是你必须等待这样的反思机会，但如果你选择经常总结自己的知识体系，并说出来给你的读者听，你就会发现你自己创造了这样的机会。如果我们平时不反思，我们觉得很多事情都是当然的，但结果如果要你一开口说给别人听，常常会发现事情就开始变得不那么明显了，你说着说着，就开始莫名其妙地发现自己需要用到“反正”这个词了。 于是，反思的机会就来了。 一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能，而不是任它们在幕后阴险地左右你的思维。很多时候我们的思路出了问题并不是我们不会反思，而是不知道自己的思维中有那些隐含的假设（assumptions），如果你只感觉到答案，却不知道你大脑得到这个答案之前做了哪些推理，你又怎么知道哪一环可能出了问题呢？另一方面，一旦你弄清了自己到底是怎么想的，离意识到问题就不远了，很简单的道理——如果别人和你争辩的时候总是只摆立场，你就很难和他辩，但如果他把自己的推理过程原原本本暴露给你，批判起来总是容易得多的。（也正因为这个原因有很多人总是把逻辑藏在背后，不敢暴露出来） 绝大多数时候其实我们都会不假思索地得出一些结论，就像上了发条的自动机，但其实我们并不知道这些结论到底怎么来的，在思维的背后到底发生了哪些事情，故而当我们发现我们的结论错了的时候，一头雾水，没法着手寻找到底在哪错了。如果你注意一下很多人的发言（论坛、博客等等），如果你把他们的发言分为“前提”、“假设”、“逻辑”、“结论”这四个部分，你会发现一大堆人只会不停地下结论，摆立场，却见不到这些结论或离场的前提、假设和个中逻辑，倒也不是他们不愿意写出逻辑，而是因为反思自己的思维过程实在是一件困难非常的事情，我们的推理过程很大一部分发生在意识的水面之下，只有当有了重要结论的时候这条逻辑链才会浮出来冒一个泡，让我们的意识捕捉到。更何况绝大多数时候我们用的其实并不是完整严密的逻辑思维，而是思维捷径。 去教一个完全不懂的人，则是一种最最强大和彻底的反思途径——因为他没有任何预备的知识，所以要让他弄懂你所知道的，你就必须彻底反思你的知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的，你不能自己站在 11 层上，然后假设你的读者站在第 10 层，指望着只要告诉他第 11 层有那些内容就让他明白。你的读者站在第一层，你必须知道你脚下踩着的另外 10 层到底是怎么构造的。这就迫使你对你所掌握的、或之前认为正确的那些东西作彻彻底底的、深刻的反思，你的受众越是不懂，你需要反思得就越深刻。 讨论是绝佳的反思。另一方面，很多时候我们并不是有机会说给完全不懂的人听，更大的可能性是说给同领域有一定基础的人听，这个时候并不代表就不能促使反思了，实际上，你会发现，如果你公开你的想法，几乎总能看到与你持不同意见的人，然后你通过比较你和他的观念之间的差别，会发现你们在一开始的思路上就存在差异，差异从哪里来的？在进一步讨论中你们就会不断地迫使对方拿出更深层次的理由，这同样也是一种非常有效地促使自己反思的方法，在讨论的过程中双方的理由自然会变得越来越深入，越来越接近问题的本质，一些平时难以注意到的深层面的差异性就会逐渐浮现出来，你也就多了一次难得的机会去审视自己的思维中到底存放了哪些错误的信息。 激励你去持续学习和思考。如果你没有持续学习和思考的习惯，你的博客很快就会没有内容可写，就只能整点碎碎念或者转载，然后你就会失去读者，然后你就会关掉博客，然后一旦关掉博客之后你也就死了写博客的心，然后就少了一条激励你去思考和总结的途径，然后你变得更不高兴总结和思考，然后… 为了打破这个死循环，不要永久停止更新你的博客，就算你两个月，三个月都不写，只要你每篇都是写自己思考的产物，写有价值的东西，在互联网上，金子的确总是会发光的，因为有无数的信息聚合平台在期待这些有价值的内容，有搜索引擎为你的内容提供海量的潜在读者，有海量的人肉在手动挖掘和转载那些有价值的东西。我们所能做的最差的一个决策莫过于停止做一件没有任何坏处，却有一大堆好处的事情。 为了让你的博客有价值，你必须不断总结自己学习的结果，你必须不断思考，给出比别人深刻、独到的见解。这看起来有点本末倒置，但很快本和末就会正过来。 学会持之以恒地做一件事情。很多人在生活中容易觉得迷失，不知道想要做什么，是因为没有一件能够持续地做的事情，用俗话来说就是没有主心骨。用积极心理学的话来说就是没有一件能够创造流体验的事情，而书写自己的思想则是一件容易产生流体验的事情，在书写的时候，特别是理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。不过前提是你得开始，并且坚持过一开始的困难期，以后的一切便成了习惯成自然。 一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso 这样的博客，个人的影响力已经足以支撑出一份事业（牛博和 5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。 （二）怎么做到长期写一个价值博客注意到我并没有说“怎么做到长期坚持写一个价值博客”，因为当思考和总结成为习惯之后，诉诸文字以及借助书写来进一步思考就变成了一件自然而然的事情，就变成了一件“因为你在思考和总结从而必须书写下来”的事情，博客就变成了副产品。 一开始的时候你是因为要写博客而去使劲地思考和总结，指望给出令人眼睛一亮的东西，到了后来，就变成了因为你习惯了思考和总结，因为你意识到书写是更好的思考，你就必须使你的想法成为文字。至此本和末就会各归原位，不再颠倒。 怎样做到长期写一个价值博客？也许有人会给出很多有趣有用的小技巧来提供动机和激励，譬如如何做 SEO，如何鼓励读者留言等等，但是这些我都不想说，我只想说最最重要的，那就是： 让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。 就像那句经常被人传阅的话：只做你最感兴趣的事情，钱会随之而来[2]。 这方面的具体例子大家可以留意一下，随处可见，就不一一举了。我想再重复一下的是，千万不要碎碎念，我能理解每个人都想偶尔发发牢骚的冲动，但是现在已经有了一个很好的窗口：twitter，所以立即停止在你的博客上碎碎念，阅读博客的人希望得到信息而非噪音。如果实在忍不住想碎碎念的话不妨换一下位置，这么来告诉自己：如果你看到别人博客来上这么一段，你会有兴趣看吗？ （三）可能出现的问题以及怎样应付即便上文给出了 N 条写博客的理由，但有时候只要一条不写的理由就会让人停止做一件事情。所以我特别加上一节“可能出现的问题以及怎样应付”，《影响力 2》[3]第五章雄辩地证明，“Much of Will is Skill”，意志力很大程度上来源于有正确的方法，而非天生。 担心别人认为没有价值。事实是，你面临过的问题总会有人面临过，你独立思考了，别人没有，你的文章对他们就会有价值。当然，肯定会对某些人没有价值，他们早就知道了，但就算你再厉害，也总是有人比你厉害的，不能说因为这些原因就不记录你自己的想法了，你自己思考了之后理解得最深刻，就算有别人想过了，总有人没有想到的。况且，思考成了习惯，你的思考能力也会越来越强，你的文章也会越来越有价值。重复，无论你面临什么困惑，总会有很多人同样面临过，于是你苦苦思索之后的结果，肯定会对很多人有意义。 或者，你想通了之后觉得其实也很简单于是不愿意或者不好意思写了，但要知道，问题在想通了之后总是简单的，问题的困难程度不在于想通了之后还觉得有多难，而在于从你觉得它难到你觉得它简单需要耗费多少思维体力，你耗费的时间越长，说明有越多的人最终还是没有想明白（路越长走到底的人越少）。 最后，虽然我现在看一年前的文章觉得挺不成熟，但是如果没有那些不成熟的思考，也不会有现在更成熟的思考，我几年后来看现在写的东西，还是会觉得不成熟。 担心想法太幼稚或有漏洞等等被别人笑话。人非圣贤。正是因为单个人的想法总是有漏洞，才值得拿出来交流（《书写是更好的思考》，讨论是绝佳的反思），被别人指出问题正是改进的空间，藏着掖着的想法永远不可能变得更成熟。 Much of intelligence is knowledge，有这么一个非常发人深省的经典心理学实验[4]： 将孩子们分成两组，通过给他们不同的阅读材料让一组相信智力是天生的，不可在后天改变的，另一组则让他们相信智力其实只是知识和技能的代名词，完全是后天习得的。接下来让他们做一组任务，那些被相信智力天生说的孩子，倾向于回避困难的任务，选择较容易的任务，这里的逻辑想必是这样的：如果做困难的任务，就增大了失败的几率，就在降低了自己在别人和自己心目中的智力的值。为了保护这个智力的值不被降低，应该避免那些有失败风险的项目。而另一组孩子则对于有挑战性的事情跃跃欲试，并且在失败的时候明显没有前者沮丧，因为失败也是学得新的东西，不管怎样都是“智力”的提高。 况且，只会批判乃至嘲笑别人的人是最不知道怎么建设的人，忽略他们。 得不到激励。这其实是个最无聊的问题了，只有写碎碎念的博客才会面对“激励”的问题。如果写自己的总结，写自己独立的思考，那么书写下来、理解通透，本身就是一个极大的激励。就算放在自己的私密笔记本里面也一样有成就感。况且，如果你真做到了书写价值博客，那么绝对不用担心你的观点得不到传播，也许一开始会耗时长一点，但是这在任何事情上都是必要的初始阶段，Gmail 小组的核心人物、FriendFeed 创始人 Paul Buchheit，和编程界名博 Coding Horror 的博主 Jeff Atwood 都曾经感叹过：Overnight success takes a long time （(1)，(2)），不过对于价值博客来说，现在网络上的聚合类服务这么多，机器的、人肉的、半人肉的都有，情况又要好得多了，而且我相信情况还会越来越好。 写不出来。这个问题也比较无聊，思考本不是一件急于求成的事情。长期订阅我的博客的朋友知道我一般发文频率在一个月三五篇，实际上有不少次我个把月也不发布文章，原因很简单，要么是有手头的事情要处理思考的时间被压缩了，要么是遇到比较大或者比较困难的问题需要长时间的思考和积淀，没有关系，如果没有想清楚就再想想，爱思考的人和不爱思考的人有一个本质的区别，前者在生活中总是挂着几个问题在大脑中，它们时常都会冒出来骚扰你一下，让你琢磨琢磨，不爱思考的则是没事不主动想问题，遇到问题还要先想想是否能找捷径（找人帮忙）解决。 无论如何，不用急于求成，在一个主题上深入下去思考，总能挖到别人挖不到的角落。你能让一个问题在大脑中停留的时间越长，就越是能够发现新的东西，一般来说，我认为有价值的问题我会让他在意识或潜意识中待短则一个星期，长则一个月（视问题大小而定），利用走路吃饭的时间琢磨（我发现很多我佩服的人也都有这个习惯），有时即便已经想通了写下来了发出去了，大脑仍然还是会在回味问题，还没有把它撤出潜意识，然后看到某篇文章或某本书的时候忽然又有所新的感悟。 能够把问题长时间停靠在潜意识中是一种技能，能够带来很大的好处，停留得越长你越琢磨得透彻，比别人看到的就越多。我们必须要带着问题的眼镜看待事物才能发现新的视角，否则就会出现视而不见效应，别的不说，广为人知的例子是阿基米德的“尤里卡！”，如果不是长时间琢磨着一个问题，一直把它放在思维中，是不会从洗澡领悟到“排水测体积”的，否则他洗了那么多年澡怎么不早发现呢？[5] 所以，如果你习惯了思考问题，就总会有东西写，先有思考，然后有总结，然后在总结中进一步思考。 当然你也可以试试把不成熟的想法写下来，试图整理成条理清晰的文字，然后看看能否在整理的过程中走得更远。这往往是可行的。比如这篇文章在我的简记里面原本其实只有三行字（包含大约十来个备忘关键词），而最初在我的大脑里面其实只有一个走路时冒出来的问题——为什么要写博客？ — [1] 你可以看一下我收藏的一些精彩主题。 [2] 尽管我并不完全同意这句话本身，但它这种解决问题链上更基本环节的问题的精神是我赞同的。 [3] 《影响力 2》这个名字起得很聪明，其实它并不是《影响力》的作者写的。 [4] 我忘了这则实验的出处了，但实验的精神是记忆犹新的，哪位同学记得原始出处的麻烦提醒我一下。 [5] 对于阿基米德这个故事的真实性是有争议的，毕竟几千年久远的事情谁弄得清呢。但是故事的道理是很本质的，我们平时也经常有类似的体验，加上阿基米德的“尤里卡”实在太出名了，所以我相信用用无妨。 参考为什么你应该（从现在开始就）写博客","categories":[{"name":"心路历程","slug":"心路历程","permalink":"http://mariogogogo.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"Javascript，基础","slug":"Javascript，基础","permalink":"http://mariogogogo.github.io/tags/Javascript%EF%BC%8C%E5%9F%BA%E7%A1%80/"}]}]}
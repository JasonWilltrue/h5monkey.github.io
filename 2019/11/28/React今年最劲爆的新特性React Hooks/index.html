<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="好前端才分对错，成年人只分利弊">
    <meta name="author" content="Mariogogogo">
    
    <title>
        
            React2019 年最劲爆的新特性 React-Hooks |
        
        Mario Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"mariogogogo.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":false},"style":{"primary_color":"#ff7979","avatar":"/images/avatar.jpg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"200px","content_max_width":"1240px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Mario Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">React2019 年最劲爆的新特性 React-Hooks</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Mariogogogo</span>
                        
                            <span class="author-label">Lv6</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2019-11-28 00:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/React/">React</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/React/">React</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>25 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>React 在 v16.8 的版本中推出了 React Hooks 新特性，虽然社区还没有最佳实践如何基于 React Hooks 来打造复杂应用(至少我还没有)，凭借着阅读社区中大量的关于这方面的文章，下面我将通过十个案例来帮助你认识理解并可以熟练运用 React Hooks 大部分特性。</p>
<a id="more"></a>
<h3 id="为什么-React-要搞一个-Hooks？"><a href="#为什么-React-要搞一个-Hooks？" class="headerlink" title="为什么 React 要搞一个 Hooks？"></a>为什么 React 要搞一个 Hooks？</h3><blockquote>
<p>想要复用一个有状态的组件太麻烦了！</p>
</blockquote>
<p>react 都核心思想就是，<a href="">将一个页面拆成一堆独立的，可复用的组件</a>，并且用<code>自上而下</code>的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。<br>那之前，官方推荐怎么解决这个问题呢？</p>
<p><strong>答案</strong>是：<code>渲染属性</code>（Render Props）和<code>高阶组件</code>（Higher-Order Components）。我们可以举例这两种模式。</p>
<h4 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h4><p>渲染属性指的是使用一个值为函数的 prop 来传递需要动态渲染的 nodes 或组件。如下面的代码可以看到我们的 DataProvider 组件包含了所有跟状态相关的代码，而 Cat 组件则可以是一个单纯的展示型组件，这样一来 DataProvider 就可以单独复用了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Cat <span class="keyword">from</span> <span class="string">&#x27;components/cat&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">target</span>: <span class="string">&#x27;Zac&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.render(<span class="built_in">this</span>.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;DataProvider render=&#123;<span class="function"><span class="params">data</span> =&gt;</span> (</span><br><span class="line">  &lt;Cat target=&#123;data.target&#125; /&gt;</span><br><span class="line">)&#125;/&gt;</span><br><span class="line"></span><br><span class="line">============改写下=======</span><br><span class="line">&lt;DataProvider&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">data</span> =&gt;</span> (</span><br><span class="line">    &lt;Cat target=&#123;data.target&#125; /&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/DataProvider&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Higher-Order-Components"><a href="#Higher-Order-Components" class="headerlink" title="Higher-Order Components"></a>Higher-Order Components</h4><p>高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser 函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withUser = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = sessionStorage.getItem(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> UserPage = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  <span class="comment">//复用每一个组件都需要获取user参数</span></span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;user-container&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;My name is &#123;props.user&#125;!&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withUser(UserPage);</span><br></pre></td></tr></table></figure>
<p>很多库也运用了这种模式，比如我们常用的 React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的<code>层级关系</code>。最直观的体现，打开 devtool 看看你的组件层级嵌套是不是很夸张吧<br><img src="http://book.52react.cn/20191025132524.png" alt=""></p>
<h4 id="生命周期钩子函数的逻辑太混乱"><a href="#生命周期钩子函数的逻辑太混乱" class="headerlink" title="生命周期钩子函数的逻辑太混乱"></a>生命周期钩子函数的逻辑太混乱</h4><p>比如我们需要在 componentDidMount 中发起 ajax 请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在 componentDidUpdate 做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">           count: <span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">//销毁</span></span><br><span class="line">     <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="class-中的-this-绑定"><a href="#class-中的-this-绑定" class="headerlink" title="class 中的 this 绑定"></a>class 中的 this 绑定</h4><p>用 class 来创建 react 组件时，还有一件很麻烦的事情，就是 this 的指向问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h4><p>项目中需求变更是非常常见的问题,之前组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用 function 写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的 state，我们又得很麻烦的把 function 改成 class。</p>
<blockquote>
<p>在这样的背景下，Hooks 便横空出世了！</p>
</blockquote>
<h3 id="先从简单的-Hooks-说起–useState"><a href="#先从简单的-Hooks-说起–useState" class="headerlink" title="先从简单的 Hooks 说起–useState"></a>先从简单的 Hooks 说起–useState</h3><p>我们看一下原来简单的有状态组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        <span class="comment">//根据state的改变重新渲染</span></span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="built_in">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;)&#125;&gt;Click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 hooks 之后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">========或者==========</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//默认只执行一次console.log(&#x27;只执行初始化一次&#x27;);</span></span><br><span class="line">	<span class="keyword">const</span> initialState = someExpensiveComputation(props)</span><br><span class="line">	<span class="keyword">return</span> initialState</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">setState(<span class="function">(<span class="params">preState</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>特点:</p>
<ol>
<li>setState 组件重新渲染时不会变化，useState 返回的第一个值始终是<code>最新</code>的 state</li>
<li>state 如果是对象，当只更新对象部分属性时，state 更新不会合并对象</li>
<li>如果 state 不发生变化，调用 setState 将跳过更新</li>
<li>建议：将同一时间段更新的 state， 组合初始化在一起</li>
</ol>
<p>还有一个问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>普通函数是记忆不住<code>result</code>的变量的.</p>
<h4 id="为什么-useState-可以记住之前的状态？"><a href="#为什么-useState-可以记住之前的状态？" class="headerlink" title="为什么 useState 可以记住之前的状态？"></a>为什么 useState 可以记住之前的状态？</h4><p>useState 接收的初始值没有规定一定要是 string/number/boolean 这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的 this.setState 做的是合并状态后返回一个新状态，而 useState 是直接替换老状态后返回新状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]);</span><br></pre></td></tr></table></figure>
<p>useState 无论调用多少次，相互之间是独立的。不同组件调用同一个 hook 也能保证各自状态的独立性。<br>react 是怎么保证多个 useState 的相互独立的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次渲染</span></span><br><span class="line">useState(<span class="number">42</span>); <span class="comment">//将age初始化为42</span></span><br><span class="line">useState(<span class="string">&quot;banana&quot;</span>); <span class="comment">//将fruit初始化为banana</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&quot;Learn Hooks&quot;</span> &#125;]); <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>); <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line">useState(<span class="string">&quot;banana&quot;</span>); <span class="comment">//读取状态变量fruit的值（这时候传的参数banana直接被忽略）</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&quot;Learn Hooks&quot;</span> &#125;]); <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/20191025134656.png" alt=""></p>
<p>假如我们改一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> showFruit = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (showFruit) &#123;</span><br><span class="line">    <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    showFruit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">&quot;Learn Hooks&quot;</span> &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/20191025134456.png" alt=""></p>
<blockquote>
<p>react 是根据 useState 出现的顺序来定的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次渲染</span></span><br><span class="line">useState(<span class="number">42</span>); <span class="comment">//将age初始化为42</span></span><br><span class="line">useState(<span class="string">&quot;banana&quot;</span>); <span class="comment">//将fruit初始化为banana</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&quot;Learn Hooks&quot;</span> &#125;]); <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>); <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line"><span class="comment">// useState(&#x27;banana&#x27;);</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&quot;Learn Hooks&quot;</span> &#125;]); <span class="comment">//读取到的却是状态变量fruit的值，导致报错</span></span><br></pre></td></tr></table></figure>
<h3 id="什么是-Effect-Hooks"><a href="#什么是-Effect-Hooks" class="headerlink" title="什么是 Effect Hooks?"></a>什么是 Effect Hooks?</h3><p>useEffect 组件渲染之后异步执行回调，并在下次渲染前执行<br>useLayoutEffect 组件渲染之后同步执行回调<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(callback); <span class="comment">//组件每次渲染，都会重新生成 useEffect</span></span><br><span class="line">useEffect(callback, [依赖参数]); <span class="comment">//组件每次渲染之后，根据依赖参数判断是否重新生成 useEffect</span></span><br><span class="line">useEffect(callback, []); <span class="comment">// 只在组件挂载时运行一</span></span><br></pre></td></tr></table></figure>
<p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起 ajax 请求获取数据，添加一些监听的注册和取消注册，手动修改 dom 等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如 componentDidMount，componentDidUpdate 和 componentWillUnmount。而现在的 useEffect 就相当与这些声明周期函数钩子的集合体。它以一抵三。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更新文档的标题</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useEffect Hook 对应的生命周期：</p>
<ol>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ol>
<p>再梳理一遍下面代码的逻辑：</p>
<ol>
<li>我们声明了一个状态变量 count，将它的初始值设为 0。</li>
<li>然后我们告诉 react，我们的这个组件有一个副作用。我们给 useEffecthook 传了一个匿名函数，这个匿名函数就是我们的副作用。</li>
<li>在这个例子里，我们的副作用是调用 browser API 来修改文档标题。</li>
<li>当 react 要渲染我们的组件时，它会先记住我们用到的副作用。等 react 更新了 DOM 之后，它再依次执行我们定义的副作用函数。</li>
</ol>
<p><strong>这里要注意几点：</strong></p>
<p>第一，react 首次渲染和之后的每次渲染都会调用一遍传给 useEffect 的函数。而之前我们要用两个声明周期函数来分别表示<code>首次渲染</code>（componentDidMount），和之后的<code>更新导致的重新渲染</code>（componentDidUpdate）<br>第二，useEffect 中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的 componentDidMount 或 componentDidUpdate 中的代码则是同步执行的。这种安排对大多数副作用说都是合理的</p>
<h4 id="useEffect-怎么解绑一些副作用"><a href="#useEffect-怎么解绑一些副作用" class="headerlink" title="useEffect 怎么解绑一些副作用"></a>useEffect 怎么解绑一些副作用</h4><p>这种场景很常见，当我们在 componentDidMount 里添加了一个注册，我们得马上在 componentWillUnmount 中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p>
<p><strong>怎么清除呢？</strong>让我们传给 useEffect 的副作用函数返回一个新的函数即可。这个新的函数将会在组件<code>下一次重新渲染之后</code>执行。这种模式在一些 pubsub 模式的实现中很常见。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="comment">// 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Loading...&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">&quot;Online&quot;</span> : <span class="string">&quot;Offline&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举个小李子<br><img src="http://book.52react.cn/20191025141139.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理事件绑定</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;#size&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, changeName, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//清理事件绑定</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;#size&quot;</span>).removeEventListener(<span class="string">&quot;click&quot;</span>, changeName, <span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="这种解绑的模式与-componentWillUnmount-区别"><a href="#这种解绑的模式与-componentWillUnmount-区别" class="headerlink" title="这种解绑的模式与 componentWillUnmount 区别?"></a>这种解绑的模式与 componentWillUnmount 区别?</h4><p>componentWillUnmount 只会在组件被<code>销毁前执行一次</code>而已，而 useEffect 里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p>
<p>为什么要让副作用函数每次组件更新都执行一遍？<br>我们在 componentDidMount 注册，再在 componentWillUnmount 清除注册。但假如这时候 props.friend.id 变了怎么办？我们不得不再添加一个 componentDidUpdate 来处理这种情况：<br>原来的做法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   ChatAPI.subscribeToFriendStatus(</span><br><span class="line">     <span class="built_in">this</span>.props.friend.id,</span><br><span class="line">     <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//增加一步动态改变id</span></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 先把上一个friend.id解绑</span></span><br><span class="line">   ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">     prevProps.friend.id,</span><br><span class="line">     <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">   );</span><br><span class="line">   <span class="comment">// 再重新注册新但friend.id</span></span><br><span class="line">   ChatAPI.subscribeToFriendStatus(</span><br><span class="line">     <span class="built_in">this</span>.props.friend.id,</span><br><span class="line">     <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">     <span class="built_in">this</span>.props.friend.id,</span><br><span class="line">     <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看到了吗？很繁琐，而我们但 useEffect 则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：</p>
<p>1.页面首次渲染 2.替 friend.id=1 的朋友注册 3.突然 friend.id 变成了 2 4.页面重新渲染 5.清除 friend.id=1 的绑定 6.替 friend.id=2 的朋友注册<br>…</p>
<h4 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h4><p>我们只需要给 useEffect 传第二个参数即可。用第二个参数来告诉 react 只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 只有当count的值发生变化时，才会重新执行`document.title`这一句</span></span><br></pre></td></tr></table></figure>
<p>当我们第二个参数传一个<code>空数组[]</code>时，其实就相当于只在<code>首次渲染的时候执行</code>。也就是 componentDidMount 加 componentWillUnmount 的模式。不过这种用法可能带来 bug，少用。</p>
<h3 id="怎么写自定义的-Effect-Hooks"><a href="#怎么写自定义的-Effect-Hooks" class="headerlink" title="怎么写自定义的 Effect Hooks?"></a>怎么写自定义的 Effect Hooks?</h3><p>为什么要自己去写一个 Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p>
<p>比如我们可以把上面写的 FriendStatus 组件中判断朋友是否在线的功能抽出来，新建一个 useFriendStatus 的 hook 专门用来判断某个 id 是否在线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br><span class="line">============这时候FriendStatus组件就可以简写为：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如别的组件需要一个朋友列表也需要显示是否在线的信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入方法</span></span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">isOnline</span> ? &quot;<span class="attr">green</span>&quot; <span class="attr">:</span> &quot;<span class="attr">black</span>&quot; &#125;&#125;&gt;</span>&#123;props.friend.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是-useContext"><a href="#什么是-useContext" class="headerlink" title="什么是 useContext"></a>什么是 useContext</h3><p>用来处理多层级传递数据的方式，在以前组件树种，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;color =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider value=&#123;<span class="string">&quot;grey&quot;</span>&#125;&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/20191025141519.png" alt=""></p>
<p>React Hooks 中，我们可以使用 useContext 进行改造</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//接受这个变量</span></span><br><span class="line">  <span class="keyword">const</span> color = useContext(colorContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先声明一个变量</span></span><br><span class="line"><span class="keyword">const</span> colorContext = React.createContext(<span class="string">&quot;gray&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;colorContext.Provider value=&#123;<span class="string">&quot;red&quot;</span>&#125;&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;/colorContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/20191025141949.png" alt=""><br>传递给 useContext 的是 context 而不是 consumer，返回值即是想要透传的数据了。用法很简单，使用 useContext 可以解决 Consumer 多状态嵌套的问题。</p>
<p>原本嵌套的方法层级太多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HeaderBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;CurrentUser.Consumer&gt;</span><br><span class="line">      &#123;<span class="function"><span class="params">user</span> =&gt;</span></span><br><span class="line">        &lt;Notifications.Consumer&gt;</span><br><span class="line">          &#123;<span class="function"><span class="params">notifications</span> =&gt;</span></span><br><span class="line">            &lt;header&gt;</span><br><span class="line">              Welcome back, &#123;user.name&#125;!</span><br><span class="line">              You have &#123;notifications.length&#125; notifications.</span><br><span class="line">            &lt;/header&gt;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/CurrentUser.Consumer&gt;</span><br><span class="line">  );&#125;</span><br></pre></td></tr></table></figure>
<p>现在用 useContext</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HeaderBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//想要传过来的值直接用useContext读取即可,可读性大大增加</span></span><br><span class="line">  <span class="keyword">const</span> user = useContext(CurrentUser);</span><br><span class="line">  <span class="keyword">const</span> notifications = useContext(Notifications);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      Welcome back, &#123;user.name&#125;! You have &#123;notifications.length&#125; notifications.</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是-useReducer"><a href="#什么是-useReducer" class="headerlink" title="什么是 useReducer"></a>什么是 useReducer</h3><p>这个 Hooks 在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//初始化一个值</span></span><br><span class="line"><span class="keyword">const</span> initData = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + action.payload &#125;;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;remove&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - action.payload &#125;;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initData);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;Count:&#123;state.count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;add&quot;</span>, <span class="attr">payload</span>: <span class="number">5</span> &#125;)&#125;&gt;增加&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;remove&quot;</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;)&#125;&gt;减少&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/2019-10-25 14.51.21.gif" alt=""><br><strong>用法跟 Redux 基本上是一致的，用法也很简单，算是提供一个 mini 的 Redux 版本。</strong></p>
<h3 id="什么是-useCallback"><a href="#什么是-useCallback" class="headerlink" title="什么是 useCallback"></a>什么是 useCallback</h3><p>四个字:记忆函数<br>在类组件中，我们经常犯下面这样的错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;SomeComponent</span><br><span class="line">          style=&#123;&#123; <span class="attr">fontSize</span>: <span class="number">14</span> &#125;&#125;</span><br><span class="line">          doSomething=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/2019-10-25 15.02.04.gif" alt=""><br>这样写有什么坏处呢？一旦 App 组件的 props 或者状态改变了就会触发重渲染，即使跟 SomeComponent 组件不相关，由于每次 render 都会产生新的 style 和 doSomething，所以会导致 SomeComponent 重新渲染，倘若 <strong>SomeComponent 是一个大型的组件树</strong>，这样的 Virtual Dom 的比较显然是很浪费的，解决的办法也很简单，将参数抽离成变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeStyle = &#123; <span class="attr">fontSize</span>: <span class="number">14</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  doSomething = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;SomeComponent style=&#123;fontSizeStyle&#125; doSomething=&#123;<span class="built_in">this</span>.doSomething&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类组件中，我们还可以通过 this 这个对象来存储函数，而在函数组件中没办法进行挂载了。所以函数组件在每次渲染的时候如果有传递函数的话<code>都会重渲染子组件</code>。</p>
<p>而有了 <code>useCallback</code> 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p>
<p><img src="http://book.52react.cn/2019-10-25 15.26.00.gif" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Click happened&quot;</span>);</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count:&#123;count&#125;</span><br><span class="line">      &lt;SomeComponent doSomething=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/SomeComponent&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老规矩，第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p>
<p>这样只要子组件继承了 PureComponent 或者使用 React.memo 就可以有效避免不必要的 VDOM 渲染。<br>还有一些注意的事情如果此时子组件再传入其他的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Click happened&quot;</span>);</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count:&#123;count&#125;</span><br><span class="line">      &lt;SomeComponent doSomething=&#123;memoizedHandleClick&#125; count=&#123;count&#125;&gt;</span><br><span class="line">        Click Me</span><br><span class="line">      &lt;/SomeComponent&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只执行一次因为数组为空代表只执行一次<br><img src="http://book.52react.cn/20191025153344.png" alt=""></p>
<h3 id="什么是-useMemo"><a href="#什么是-useMemo" class="headerlink" title="什么是 useMemo"></a>什么是 useMemo</h3><p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> memoizedHandleClick = useMemo(</span><br><span class="line">  () =&gt; <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Click happened&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [count]</span><br><span class="line">); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br></pre></td></tr></table></figure>
<p>唯一的区别是：</p>
<ol>
<li>useCallback <code>不会执行</code>第一个参数函数，而是将它返回给你，</li>
<li>useMemo <code>会执行第一个函数</code>并且将函数执行结果返回给你。<br>所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。</li>
</ol>
<p><strong> useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。</strong><br><strong> useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Only re-rendered if `a` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child1</span> <span class="attr">a</span>=<span class="string">&#123;a&#125;</span> /&gt;</span></span>, [a]);</span><br><span class="line">  <span class="comment">// Only re-rendered if `b` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child2 = useMemo(<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child2</span> <span class="attr">b</span>=<span class="string">&#123;b&#125;</span> /&gt;</span></span>, [b]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 a/b 改变时，child1/child2 才会重新渲染。从例子可以看出来，只有在第二个参数数组的值发生变化时，才会触发子组件的更新。</p>
<h3 id="什么是-useRef"><a href="#什么是-useRef" class="headerlink" title="什么是 useRef"></a>什么是 useRef</h3><p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [name, setName] = useState(<span class="string">&quot;Nate&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> nameRef = useRef();</span><br><span class="line">  <span class="keyword">const</span> submitButton = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setName(nameRef.current.value);</span><br><span class="line">    nameRef.current.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;name&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;nameRef&#125; type=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;button&quot;</span> onClick=&#123;submitButton&#125;&gt;</span><br><span class="line">          Submit</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/2019-10-25 15.51.16.gif" alt=""><br>useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值访问组件或真实的 DOM 节点，从而可以对 DOM 进行一些操作，比如监听事件等等。</p>
<p>当然 useRef 远比你想象中的功能更加强大，useRef 的功能有点像类属性，或者说您想要在组件中记录一些值，并且这些值在稍后可以更改。</p>
<p>利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。参考例子：精读《Function VS Class 组件》<br><img src="http://book.52react.cn/20191025155425.png" alt=""></p>
<h4 id="什么是-React-Hooks-中存在-Capture-Value-的特性"><a href="#什么是-React-Hooks-中存在-Capture-Value-的特性" class="headerlink" title="什么是 React Hooks 中存在 Capture Value 的特性"></a>什么是 React Hooks 中存在 Capture Value 的特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MessageThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;You said: &quot;</span> + message);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSendClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleMessageChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setMessage(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在点击 Send 按钮后,再次修改输入框的值，3 秒后的输出依然是点击前输入框的值。这就是所谓的 capture value 的特性。<br>而在类组件中 3 秒后输出的就是修改后的值，因为这时候 message 是挂载在 this 变量上，它保留的是一个引用值，对 this 属性的访问都会获取到最新的值。<br>讲到这里你应该就明白了，useRef 创建一个引用，就可以有效规避 React Hooks 中 Capture Value 特性,<code>ref拿到的是最新的值</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MessageThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> latestMessage = useRef(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;You said: &quot;</span> + latestMessage.current);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSendClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleMessageChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    latestMessage.current = e.target.value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;latestMessage.current.value&#125; onChange=&#123;handleMessageChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要将赋值与取值的对象变成 useRef，而不是 useState，就可以躲过 capture value 特性，在 3 秒后得到最新的值。</p>
<h3 id="什么是-useImperativeMethods"><a href="#什么是-useImperativeMethods" class="headerlink" title="什么是 useImperativeMethods"></a>什么是 useImperativeMethods</h3><p>通过 useImperativeHandle 用于让父组件获取子组件内的索</p>
<h3 id="什么是-useMutationEffect"><a href="#什么是-useMutationEffect" class="headerlink" title="什么是 useMutationEffect"></a>什么是 useMutationEffect</h3><h3 id="什么是-useLayoutEffect"><a href="#什么是-useLayoutEffect" class="headerlink" title="什么是 useLayoutEffect"></a>什么是 useLayoutEffect</h3><p>useLayoutEffect 同步执行副作用<br>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;useEffect&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#title&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> titleWidth = title.getBoundingClientRect().width;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;useLayoutEffect&quot;</span>, width, titleWidth, title.getBoundingClientRect());</span><br><span class="line">    <span class="keyword">if</span> (width !== titleWidth) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setWidth(titleWidth);</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1 id=<span class="string">&quot;title&quot;</span>&gt;hello&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;&#123;width&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p><img src="http://book.52react.cn/20191025162213.png" alt=""></p>
<h5 id="加入定时器后再看看执行顺序"><a href="#加入定时器后再看看执行顺序" class="headerlink" title="加入定时器后再看看执行顺序"></a>加入定时器后再看看执行顺序</h5><p><img src="http://book.52react.cn/2019-10-25 16.25.50.gif" alt=""></p>
<h2 id="React-Hooks-不足"><a href="#React-Hooks-不足" class="headerlink" title="React Hooks 不足"></a>React Hooks 不足</h2><p>尽管我们通过上面的例子看到 React Hooks 的强大之处，似乎类组件完全都可以使用 React Hooks 重写。但是当下 v16.8 的版本中，还无法实现 <code>getSnapshotBeforeUpdate</code> 和 <code>componentDidCatch</code> 这两个在类组件中的生命周期函数。官方也计划在不久的将来在 React Hooks 进行实现,<strong>期待吧!</strong>😄💪🏻</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：React2019 年最劲爆的新特性 React-Hooks</li>
        <li>本文作者：Mariogogogo</li>
        <li>创建时间：2019-11-28 00:00:00</li>
        <li>
            本文链接：http://www.h5web.cc/2019/11/28/React今年最劲爆的新特性React Hooks/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2019/12/01/Redux%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2-createStore/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Redux源码探索-createStore</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/10/27/Redux%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Redux 异步方案选型</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Mariogogogo</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-React-%E8%A6%81%E6%90%9E%E4%B8%80%E4%B8%AA-Hooks%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">为什么 React 要搞一个 Hooks？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Render-Props"><span class="nav-number">1.1.</span> <span class="nav-text">Render Props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Higher-Order-Components"><span class="nav-number">1.2.</span> <span class="nav-text">Higher-Order Components</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%AA%E6%B7%B7%E4%B9%B1"><span class="nav-number">1.3.</span> <span class="nav-text">生命周期钩子函数的逻辑太混乱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-%E4%B8%AD%E7%9A%84-this-%E7%BB%91%E5%AE%9A"><span class="nav-number">1.4.</span> <span class="nav-text">class 中的 this 绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%8F%98%E6%9B%B4"><span class="nav-number">1.5.</span> <span class="nav-text">需求变更</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84-Hooks-%E8%AF%B4%E8%B5%B7%E2%80%93useState"><span class="nav-number">2.</span> <span class="nav-text">先从简单的 Hooks 说起–useState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-useState-%E5%8F%AF%E4%BB%A5%E8%AE%B0%E4%BD%8F%E4%B9%8B%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">为什么 useState 可以记住之前的状态？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Effect-Hooks"><span class="nav-number">3.</span> <span class="nav-text">什么是 Effect Hooks?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useEffect-%E6%80%8E%E4%B9%88%E8%A7%A3%E7%BB%91%E4%B8%80%E4%BA%9B%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">useEffect 怎么解绑一些副作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%99%E7%A7%8D%E8%A7%A3%E7%BB%91%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%8E-componentWillUnmount-%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">这种解绑的模式与 componentWillUnmount 区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BF%87%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">怎么跳过一些不必要的副作用函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-Effect-Hooks"><span class="nav-number">4.</span> <span class="nav-text">怎么写自定义的 Effect Hooks?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useContext"><span class="nav-number">5.</span> <span class="nav-text">什么是 useContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useReducer"><span class="nav-number">6.</span> <span class="nav-text">什么是 useReducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useCallback"><span class="nav-number">7.</span> <span class="nav-text">什么是 useCallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useMemo"><span class="nav-number">8.</span> <span class="nav-text">什么是 useMemo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useRef"><span class="nav-number">9.</span> <span class="nav-text">什么是 useRef</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Hooks-%E4%B8%AD%E5%AD%98%E5%9C%A8-Capture-Value-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">9.1.</span> <span class="nav-text">什么是 React Hooks 中存在 Capture Value 的特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useImperativeMethods"><span class="nav-number">10.</span> <span class="nav-text">什么是 useImperativeMethods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useMutationEffect"><span class="nav-number">11.</span> <span class="nav-text">什么是 useMutationEffect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-useLayoutEffect"><span class="nav-number">12.</span> <span class="nav-text">什么是 useLayoutEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%8E%E5%86%8D%E7%9C%8B%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">12.0.1.</span> <span class="nav-text">加入定时器后再看看执行顺序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-Hooks-%E4%B8%8D%E8%B6%B3"><span class="nav-number"></span> <span class="nav-text">React Hooks 不足</span></a>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

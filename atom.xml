<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mario</title>
  
  <subtitle>📌好前端才分对错，成年人只分利弊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mariogogogo.github.io/"/>
  <updated>2021-06-18T08:42:55.959Z</updated>
  <id>http://mariogogogo.github.io/</id>
  
  <author>
    <name>Codding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue-AST语法树转render原理</title>
    <link href="http://mariogogogo.github.io/2021/06/18/Vue-AST%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
    <id>http://mariogogogo.github.io/2021/06/18/Vue-AST语法树/</id>
    <published>2021-06-17T16:00:00.000Z</published>
    <updated>2021-06-18T08:42:55.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是AST"><a href="#什么是AST" class="headerlink" title="什么是AST"></a>什么是AST</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021061816image-20210614102953117.png"                      alt="image-20210614102953117" style="zoom:50%;"                 ></p><blockquote><p>抽象语法树本质上就是js对象</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021061816image-20210614103035580.png"                      alt="image-20210614103035580" style="zoom:50%;"                 ></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote><p>词法分析的时候，经常要用到栈这个数据结构</p></blockquote><p>在分析</p><p>首先解析一下普通字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> templateString = <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;你好&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;A&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;C&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parse函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">templateString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    rest = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> startRegExp = <span class="regexp">/^\&lt;([a-z]+[1-6]?)\&gt;/</span>;</span><br><span class="line">  <span class="keyword">var</span> endRegExp = <span class="regexp">/^\&lt;\/([a-z]+[1-6]?)\&gt;/</span>;</span><br><span class="line">  <span class="comment">// 抓取结束标记前的文字</span></span><br><span class="line">  <span class="keyword">var</span> wordRegExp = <span class="regexp">/^([^\&lt;]+)\&lt;\/[a-z]+[1-6]?\&gt;/</span>;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; templateString.length - <span class="number">1</span>) &#123;</span><br><span class="line">    rest = templateString.substring(index);</span><br><span class="line">    <span class="comment">// console.log(&#x27;剩余节点&#x27;, rest);</span></span><br><span class="line">    <span class="comment">// 识别遍历到这个字符 是不是一个开始字符</span></span><br><span class="line">    <span class="keyword">if</span> (startRegExp.test(rest)) &#123;</span><br><span class="line">      <span class="keyword">let</span> tag = rest.match(startRegExp)[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;检测到开始标志 :&gt;&gt; &#x27;</span>, tag);</span><br><span class="line">      <span class="comment">//开始标记推入栈1</span></span><br><span class="line">      stack1.push(tag);</span><br><span class="line">      <span class="comment">// 将空数组推入栈2</span></span><br><span class="line">      stack2.push([]);</span><br><span class="line">      index += tag.length + <span class="number">2</span>; <span class="comment">//因为 &lt; &gt; 占2位</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endRegExp.test(rest)) &#123;</span><br><span class="line">      <span class="keyword">let</span> tag = rest.match(endRegExp)[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;检测到结束标志 :&gt;&gt; &#x27;</span>, tag);</span><br><span class="line">      index += tag.length + <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> (tag === stack1[stack1.length - <span class="number">1</span>]) &#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;标签没有封闭: &#x27;</span>, stack1[stack1.length - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wordRegExp.test(rest))&#123;</span><br><span class="line">      <span class="keyword">let</span> word = rest.match(wordRegExp)[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// 如果word全空判断  去除空字符</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="regexp">/^\s+$/</span>.test(word))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;检测文字 :&gt;&gt; &#x27;</span>, word);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 指针移动标签的长度</span></span><br><span class="line">      index += word.length</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;stack1,stack2 :&gt;&gt; &#x27;</span>, stack1, stack2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021061816image-20210614224646388.png"                      alt="image-20210614224646388" style="zoom:50%;"                 ></p><h2 id="使用栈形成AST"><a href="#使用栈形成AST" class="headerlink" title="使用栈形成AST"></a>使用栈形成AST</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> templateString = <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;你好&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;A&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;C&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">templateString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>, <span class="comment">//指针</span></span><br><span class="line">    rest = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> startRegExp = <span class="regexp">/^\&lt;([a-z]+[1-6]?)\&gt;/</span>;</span><br><span class="line">  <span class="keyword">var</span> endRegExp = <span class="regexp">/^\&lt;\/([a-z]+[1-6]?)\&gt;/</span>;</span><br><span class="line">  <span class="comment">// 抓取结束标记前的文字</span></span><br><span class="line">  <span class="keyword">var</span> wordRegExp = <span class="regexp">/^([^\&lt;]+)\&lt;\/[a-z]+[1-6]?\&gt;/</span>;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [&#123;<span class="string">&#x27;children&#x27;</span>:[]&#125;];  <span class="comment">//小技巧🔥🔥🔥 这里填充children</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; templateString.length - <span class="number">1</span>) &#123;</span><br><span class="line">    rest = templateString.substring(index);</span><br><span class="line">    <span class="comment">// console.log(&#x27;剩余节点&#x27;, rest);</span></span><br><span class="line">    <span class="comment">// 识别遍历到这个字符 是不是一个开始字符</span></span><br><span class="line">    <span class="keyword">if</span> (startRegExp.test(rest)) &#123;</span><br><span class="line">      <span class="keyword">let</span> tag = rest.match(startRegExp)[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;检测到开始标志 :&gt;&gt; &#x27;</span>, tag);</span><br><span class="line">      <span class="comment">//开始标记推入栈1</span></span><br><span class="line">      stack1.push(tag);</span><br><span class="line">      <span class="comment">// 将空数组推入栈2🔥🔥🔥🔥</span></span><br><span class="line">      stack2.push(&#123; <span class="attr">tag</span>: tag, <span class="attr">children</span>: [] &#125;);</span><br><span class="line">      index += tag.length + <span class="number">2</span>; <span class="comment">//因为 &lt; &gt; 占2位</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endRegExp.test(rest)) &#123;</span><br><span class="line">      <span class="keyword">let</span> tag = rest.match(endRegExp)[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;检测到结束标志 :&gt;&gt; &#x27;</span>, tag);</span><br><span class="line">      index += tag.length + <span class="number">3</span>;</span><br><span class="line">      <span class="comment">// console.log(&#x27;stack1 :&gt;&gt; &#x27;, stack1,JSON.stringify(stack2));</span></span><br><span class="line">      <span class="comment">//tag一定与 栈1顶  相同</span></span><br><span class="line">      <span class="keyword">let</span> pop_tag = stack1.pop();</span><br><span class="line">      <span class="keyword">if</span> (tag === pop_tag) &#123;</span><br><span class="line">        <span class="keyword">let</span> pop_arr = stack2.pop();</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (stack2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          stack2[stack2.length - <span class="number">1</span>].children.push(pop_arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;标签没有封闭: &#x27;</span>, stack1[stack1.length - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordRegExp.test(rest)) &#123;</span><br><span class="line">      <span class="keyword">let</span> word = rest.match(wordRegExp)[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 如果word全空判断  去除空字符</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/^\s+$/</span>.test(word)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;检测文字 :&gt;&gt; &#x27;</span>, word);</span><br><span class="line">        stack2[stack2.length - <span class="number">1</span>].children.push(&#123; <span class="attr">text</span>: word, <span class="attr">type</span>: <span class="number">3</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 指针移动标签的长度</span></span><br><span class="line">      index += word.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//stack2 只有一个根</span></span><br><span class="line">  <span class="keyword">return</span> stack2[<span class="number">0</span>].children[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021061816image-20210615130730248.png"                      alt="image-20210615130730248"                  ></p><h2 id="识别attrs"><a href="#识别attrs" class="headerlink" title="识别attrs"></a>识别attrs</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 <span class="keyword">class</span>=&quot;<span class="symbol">box</span>”&gt;你好&lt;/<span class="symbol">h3</span>&gt;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021061816image-20210615132247430.png"                      alt="image-20210615132247430"                ></p><p>如何把 <code>class=&quot;box red blue”</code>解析成对象形式 <code>&#123;name: &quot;class&quot;, value: &quot;box red blue&quot;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 把attrsString变为数组返回</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">attrsString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (attrsString == <span class="literal">undefined</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;%c 🥪 attrsString: &#x27;</span>, <span class="string">&#x27;font-size:20px;background-color: #B03734;color:#fff;&#x27;</span>, attrsString);</span><br><span class="line">  <span class="comment">// 当前是否在引号内</span></span><br><span class="line">  <span class="keyword">var</span> isYinhao = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 断点</span></span><br><span class="line">  <span class="keyword">var</span> point = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历attrsString，而不是你想的用split()这种暴力方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrsString.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> char = attrsString[i];</span><br><span class="line">      <span class="keyword">if</span> (char == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">          isYinhao = !isYinhao;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char == <span class="string">&#x27; &#x27;</span> &amp;&amp; !isYinhao) &#123;</span><br><span class="line">          <span class="comment">// 遇见了空格，并且不在引号中</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;断点&#x27;</span>,i);</span><br><span class="line">          <span class="keyword">if</span> (!<span class="regexp">/^\s*$/</span>.test(attrsString.substring(point, i))) &#123;</span><br><span class="line">              result.push(attrsString.substring(point, i).trim());</span><br><span class="line">              point = i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束之后，最后还剩一个属性k=&quot;v&quot;</span></span><br><span class="line">  result.push(attrsString.substring(point).trim());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的代码功能是，将[&quot;k=v&quot;,&quot;k=v&quot;,&quot;k=v&quot;]变为[&#123;name:k, value:v&#125;, &#123;name:k, value:v&#125;, &#123;name:k,value:v&#125;];</span></span><br><span class="line">  result = result.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据等号拆分</span></span><br><span class="line">      <span class="keyword">const</span> o = item.match(<span class="regexp">/^(.+)=&quot;(.+)&quot;$/</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;%c 🍪 o: &#x27;</span>, <span class="string">&#x27;font-size:20px;background-color: #6EC1C2;color:#fff;&#x27;</span>, o);<span class="number">8</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          name: o[<span class="number">1</span>],</span><br><span class="line">          value: o[<span class="number">2</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AST语法树转render函数"><a href="#AST语法树转render函数" class="headerlink" title="AST语法树转render函数"></a>AST语法树转render函数</h2><p>整个AST语法树转render函数的起点是<code>index.js</code>文件中的<code>generate()</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params">ast</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> code = genElement(ast);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">`with (this) &#123; return <span class="subst">$&#123;code&#125;</span>&#125;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如一段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;el&quot;</span>&gt;Hello &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _c(</span><br><span class="line">   <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      attrs:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;el&quot;</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">      _v(<span class="string">&quot;hello &quot;</span>+_s(name))</span><br><span class="line">    ]</span><br><span class="line">  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是一个嵌套函数的调用，_c其实是<code>createElement</code>，调用这个函数生成一个VNode</p><p>这其中还有  属性解析genData  子节点解析genChildren  文本解析genText  注释节点genComment；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字符串拼接的过程，通过递归AST生成字符串，最终先生成根节点，将其拼接再根节点的参数中，子节点拼接再子节点的参数中，一层层拼接，拼接后，调用with返回vnode</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是AST&quot;&gt;&lt;a href=&quot;#什么是AST&quot; class=&quot;headerlink&quot; title=&quot;什么是AST&quot;&gt;&lt;/a&gt;什么是AST&lt;/h2&gt;&lt;p&gt;&lt;img  
                     lazyload
                 
      
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="http://mariogogogo.github.io/2021/02/21/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://mariogogogo.github.io/2021/02/21/算法-二叉树的层次遍历/</id>
    <published>2021-02-20T16:00:00.000Z</published>
    <updated>2021-06-18T06:50:41.456Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>学会二叉树的层序遍历，可以一口气撸完leetcode上八道题目:</p><ul><li>107.二叉树的层次遍历II </li><li>199.二叉树的右视图</li><li>637.二叉树的层平均值 </li><li>429.N叉树的前序遍历 </li><li>515.在每个树行中找最大值</li><li>116.填充每个节点的下一个右侧节点指针 </li><li>117.填充每个节点的下一个右侧节点指针II</li></ul><h2 id="二叉树的层次遍历II"><a href="#二叉树的层次遍历II" class="headerlink" title="二叉树的层次遍历II"></a>二叉树的层次遍历II</h2><p>题目链接:<a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" >https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/<i class="fas fa-external-link-alt"></i></a></p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 (即按从叶子节点所在层到根节点所在的层，逐 层从左向右遍历)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102211418559202021022114.png"                      alt="image-20210221141855920"                ></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.前面都是层次遍历套路</p><p>2.最后结果再用数组reverse方法</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102211439511272021022114.png"                      alt="image-20210221143951127"                ></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">   <span class="keyword">const</span> q = [[root,<span class="number">0</span>]]</span><br><span class="line">   <span class="keyword">const</span> res = []</span><br><span class="line">   <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> [n,level] =q.shift()</span><br><span class="line">       <span class="keyword">if</span>(!res[level])&#123;</span><br><span class="line">         res.push([n.val])</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         res[level].push(n.val)  </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(n.left) q.push([n.left,level+<span class="number">1</span>])</span><br><span class="line">       <span class="keyword">if</span>(n.right)q.push([n.right,level+<span class="number">1</span>])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反转</span></span><br><span class="line">   <span class="keyword">return</span> res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h2><p>题目链接:<a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >https://leetcode-cn.com/problems/binary-tree-right-side-view/<i class="fas fa-external-link-alt"></i></a></p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>,null,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>层序遍历的时候，</p></li><li><p><code>判断是否遍历到单层的最后面的元素</code> (重点分析 对每一层q的数组进行while len–操作)</p></li><li><p>如果是，就放进result数组中，随后返回result 就可以了。</p></li></ol><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102211523112642021022115.png"                      alt="image-20210221152311264" style="zoom:80%;"                 ></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rightSideView = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">   <span class="keyword">const</span> q = [root]</span><br><span class="line">   <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = q.length</span><br><span class="line">        <span class="comment">//对每一层进行遍历 [1]  [2,3 ]  [4,5,6]   [7]</span></span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">          <span class="keyword">let</span> n = q.shift()</span><br><span class="line">            <span class="comment">//每一层最后一位</span></span><br><span class="line">            <span class="keyword">if</span>(len === <span class="number">1</span>) res.push(n.val)</span><br><span class="line">            <span class="keyword">if</span>(n.left) q.push(n.left)</span><br><span class="line">            <span class="keyword">if</span>(n.right) q.push(n.right)</span><br><span class="line">            len--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h2><p>题目链接:<a class="link"   href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" >https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/<i class="fas fa-external-link-alt"></i></a></p><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line"> <span class="number"> 9 </span> 20</span><br><span class="line">    /  \</span><br><span class="line">  <span class="number"> 15 </span>  7</span><br><span class="line">输出：[3, 14.5, 11]</span><br><span class="line">解释：</span><br><span class="line">第<span class="number"> 0 </span>层的平均值是<span class="number"> 3 </span>,  第1层是 14.5 , 第2层是<span class="number"> 11 </span>。因此返回 [3, 14.5, 11] 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>用层序遍历的方法。维护一个队列去遍历节点。</p></li><li><p>用 for 循环控制一层的节点逐个出列，节点值累加求和。</p></li><li><p>节点出列的同时，下一层的子节点加入队列，在 for 循环结束时，队列中就全是下一层的节点。</p></li><li><p>此时当前层的求和也好了，除以当前层的节点个数，就是当前层的平均值，加入结果数组。</p></li><li><p>接着处理下一层的节点，重复以上步骤，就构建好了结果数组。</p></li></ol><h3 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/2021-02-21%2015.56.07-38942632021022115.gif"                      alt="2021-02-21 15.56.07"                ></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> averageOfLevels = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">const</span> p = [root]</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size = p.length <span class="comment">//每一层的长度</span></span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;size;i++)&#123;</span><br><span class="line">             <span class="keyword">const</span> n = p.shift()</span><br><span class="line">              <span class="comment">//每一层的总和</span></span><br><span class="line">              sum += n.val</span><br><span class="line">             <span class="keyword">if</span>(n.left) p.push(n.left)</span><br><span class="line">             <span class="keyword">if</span>(n.right) p.push(n.right)</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(sum/size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h2><p>题目链接:<a class="link"   href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" >https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/<i class="fas fa-external-link-alt"></i></a> </p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">const</span> p = [root]</span><br><span class="line">   <span class="keyword">const</span> res = []</span><br><span class="line">   <span class="keyword">while</span>(p.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> size = p.length</span><br><span class="line">      <span class="keyword">const</span> temp = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; size;i++)&#123;</span><br><span class="line">          <span class="keyword">const</span> n = p.shift()</span><br><span class="line">          temp.push(n.val)</span><br><span class="line">          p.push(...n.children)</span><br><span class="line">      &#125;</span><br><span class="line">     res.push(temp)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;学会二叉树的层序遍历，可以一口气撸完leetcode上八道题目:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;107.二叉树的层次遍历II &lt;/li&gt;
&lt;li&gt;199.二叉树的右视图&lt;/li&gt;
&lt;li&gt;637.二叉树的层平均值 &lt;/li&gt;
&lt;li&gt;429.
      
    
    </summary>
    
      <category term="算法" scheme="http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的先中后层序遍历</title>
    <link href="http://mariogogogo.github.io/2021/02/20/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/"/>
    <id>http://mariogogogo.github.io/2021/02/20/算法-二叉树的先中后遍历/</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2021-06-18T05:26:54.585Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>二叉树的四种遍历方式：先序遍历、中序遍历、后序遍历、层序遍历。</p><h3 id="模拟一棵二叉树"><a href="#模拟一棵二叉树" class="headerlink" title="模拟一棵二叉树"></a>模拟一棵二叉树</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.root = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">4</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      val: <span class="number">5</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="number">3</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">6</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      val: <span class="number">7</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="先序遍历算法口诀"><a href="#先序遍历算法口诀" class="headerlink" title="先序遍历算法口诀"></a>先序遍历算法口诀</h3><ol><li>访问根节点</li><li>对根节点左子树进行先序遍历</li><li>对根节点右子树进行先序遍历</li></ol><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102210004234802021022100.png"                      alt="image-20210221000423480" style="zoom:50%;"                 ></p><h2 id="先序遍历（递归版本）"><a href="#先序遍历（递归版本）" class="headerlink" title="先序遍历（递归版本）"></a>先序遍历（递归版本）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root)&#123;</span><br><span class="line">     <span class="comment">//遍历左节点</span></span><br><span class="line">     preorder(root.left)</span><br><span class="line">     <span class="comment">//遍历右节点</span></span><br><span class="line">     preorder(root.right)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先序遍历（迭代版本）"><a href="#先序遍历（迭代版本）" class="headerlink" title="先序遍历（迭代版本）"></a>先序遍历（迭代版本）</h2><blockquote><p>思路：我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同</p></blockquote><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/2021-02-21%2000.19.152021022100.gif"                      alt="2021-02-21 00.19.15"                ></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>前序遍历是中左右，每次先处理的是中间节点，那么先将<strong><em>跟节点</em></strong>放入栈中，</p></li><li><p>然后将右节点加入栈，再加入左节点。</p></li><li><p>为什么要先加入 右节点，再加入左节点呢？ 因为这样出栈的时候才是中左右的顺序。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">  <span class="comment">//拿到n.val</span></span><br><span class="line">  <span class="keyword">if</span>(n.right) stack.push(n.right) <span class="comment">//为什么要先存right值 因为数组后进先出</span></span><br><span class="line">  <span class="keyword">if</span>(n.left) stack.push(n.left)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历算法口诀"><a href="#中序遍历算法口诀" class="headerlink" title="中序遍历算法口诀"></a>中序遍历算法口诀</h3><ol><li>对根节点左子树进行中序遍历</li><li>访问根节点</li><li>对根节点右子树进行先序遍历</li></ol><h3 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102210007115022021022100.png"                      alt="image-20210221000711502" style="zoom:50%;"                 ></p><h2 id="中序遍历（递归版本）"><a href="#中序遍历（递归版本）" class="headerlink" title="中序遍历（递归版本）"></a>中序遍历（递归版本）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> midSort = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">     midSort(root.left)</span><br><span class="line">     res.push(root.val)</span><br><span class="line">     midSort(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> midSort(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历（迭代版本）"><a href="#中序遍历（迭代版本）" class="headerlink" title="中序遍历（迭代版本）"></a>中序遍历（迭代版本）</h2><h3 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/2021-02-21%2000.42.122021022100.gif"                      alt="2021-02-21 00.42.12"                ></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>中序遍历是<code>左中右</code>，先访问的是二叉树顶部的节点，然后一层一层向下访问。</p><p>直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">let</span> stack = []  <span class="comment">//设置一个空栈</span></span><br><span class="line">   <span class="keyword">let</span> p = root <span class="comment">//设置指</span></span><br><span class="line">   <span class="keyword">while</span>(stack.length || p)&#123;</span><br><span class="line">      <span class="comment">/*****一直找左节点****/</span>            </span><br><span class="line">       <span class="keyword">while</span>(p)&#123;</span><br><span class="line">          stack.push(p) <span class="comment">//每当左子树有值 [root left left left]</span></span><br><span class="line">          p = p.left</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*****一直找左节点****/</span></span><br><span class="line">    <span class="comment">//找完所有左节点 推出栈 [root left1 left2 left3] ==&gt; [left3 left2 left1 root ]</span></span><br><span class="line">    <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">    <span class="comment">//拿n.val</span></span><br><span class="line">    p = n.right</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历算法口诀"><a href="#后序遍历算法口诀" class="headerlink" title="后序遍历算法口诀"></a>后序遍历算法口诀</h3><ol><li>对根节点左子树进行中序遍历</li><li>对根节点右子树进行先序遍历</li><li>访问根节点</li></ol><h3 id="图解-4"><a href="#图解-4" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102210008331602021022100.png"                      alt="image-20210221000833160" style="zoom:50%;"                 ></p><h2 id="后序遍历（递归版本）"><a href="#后序遍历（递归版本）" class="headerlink" title="后序遍历（递归版本）"></a>后序遍历（递归版本）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">const</span> postorderTraversal = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">  postorderTraversal(root.left)</span><br><span class="line">  postorderTraversal(root.right)</span><br><span class="line">  res.push(root.val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历（迭代版本）"><a href="#后序遍历（迭代版本）" class="headerlink" title="后序遍历（迭代版本）"></a>后序遍历（迭代版本）</h2><h3 id="思路（这是一个讨巧的办法）"><a href="#思路（这是一个讨巧的办法）" class="headerlink" title="思路（这是一个讨巧的办法）"></a>思路（这是一个讨巧的办法）</h3><ol><li>如果我们把前序遍历的 list.push(node.val) 变更为 list.unshift(node.val) （遍历结果逆序），</li><li>那么遍历顺序就由 根左右 变更为 右左根。</li><li>然后我们仅需将 右左根 变更为 <code>左右根</code> 即可完成后序遍</li></ol><h3 id="图解-5"><a href="#图解-5" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102211144390252021022111.png"                      alt="image-20210221114439025"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/2021-02-21%2012.18.14-tuya2021022113.gif"                      alt="2021-02-21 12.18.14-tuya"                ></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderTraversal = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = [] <span class="comment">//遍历结果</span></span><br><span class="line">    <span class="keyword">let</span> stack = [root] <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">     <span class="keyword">while</span>(stack.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> n = stack.pop() <span class="comment">// [n.left,n.right]</span></span><br><span class="line">       list.unshift(n.val) <span class="comment">//根是最后加的 最里面  [ n.left  n.right  n.val]</span></span><br><span class="line">       <span class="keyword">if</span>(n.left) stack.push(n.left)</span><br><span class="line">       <span class="keyword">if</span>(n.right) stack.push(n.right)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><blockquote><p>题目来源：LeetCode：102 二叉树的层序遍历</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202102211313433592021022113.png"                      alt="image-20210221131343359" style="zoom: 80%;"                 ></p><p>👑类似广度优先遍历二叉树。</p><p>👑遍历工程中，记录<code>每一个节点的层级</code>，并将其添加到不同的数组中。</p><h3 id="图解-6"><a href="#图解-6" class="headerlink" title="图解"></a>图解</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/%E5%B1%82%E5%BA%8F2021022113.gif"                      alt="层序"                ></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先写一个广度优先遍历</p><p>加入层级计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">const</span> q = [[root,<span class="number">0</span>]] <span class="comment">//把顶层加入栈中</span></span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//推出每一个栈中顶层节点</span></span><br><span class="line">      <span class="keyword">const</span> [n,level]= q.shift()</span><br><span class="line">      <span class="keyword">if</span>(!res[level])&#123;</span><br><span class="line">          res.push([n.val])</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         res[level].push(n.val)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右节点都存在则层级+1</span></span><br><span class="line">      <span class="keyword">if</span>(n.left) q.push([n.left,level+<span class="number">1</span>])</span><br><span class="line">      <span class="keyword">if</span>(n.right) q.push([n.right,level+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;二叉树的四种遍历方式：先序遍历、中序遍历、后序遍历、层序遍历。&lt;/p&gt;
&lt;h3 id=&quot;模拟一棵二叉树&quot;&gt;&lt;a href=&quot;#模拟一棵二叉树&quot; class=&quot;headerlink&quot; title=&quot;模拟一棵二叉树&quot;&gt;&lt;/a&gt;模拟一棵二叉树&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度广度优先遍历</title>
    <link href="http://mariogogogo.github.io/2021/02/19/%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>http://mariogogogo.github.io/2021/02/19/算法-深度广度优先遍历/</id>
    <published>2021-02-18T16:00:00.000Z</published>
    <updated>2021-06-18T05:27:17.049Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>先来学一下树的深度与广度优先</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021022017image-20210220170016966.png"                      alt="image-20210220170016966"                 ></p><h2 id="深度优先遍历算法口诀"><a href="#深度优先遍历算法口诀" class="headerlink" title="深度优先遍历算法口诀"></a>深度优先遍历算法口诀</h2><p>1.访问根节点</p><p>2.对根节点chilidren挨个进行深度优先遍历（递归）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs.js</span></span><br><span class="line"><span class="keyword">const</span> root = &#123;</span><br><span class="line">  val: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      val: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          val: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          val: <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      val: <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          val: <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          val: <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">   root.chilidren.forEach(dfs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一行代码  是不是很简单</p></blockquote><h2 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021022017image-20210220170917519.png"                      alt="image-20210220170917519"                ></p><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//新建队列 入队</span></span><br><span class="line">   <span class="keyword">const</span> q = [root]</span><br><span class="line">   <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="comment">//把队头出队后 q就空了</span></span><br><span class="line">       <span class="keyword">const</span> n = q.shift()</span><br><span class="line">       <span class="comment">//这里可以拿到n.val,继续遍历children</span></span><br><span class="line">       n.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span>&#123;</span><br><span class="line">           q.push(child)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p><p>常见的 DFS ： 先序遍历、中序遍历、后序遍历；<br>常见的 BFS ： 层序遍历（即按层遍历）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;先来学一下树的深度与广度优先&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
             
      
    
    </summary>
    
      <category term="算法" scheme="http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法入门指南</title>
    <link href="http://mariogogogo.github.io/2021/02/18/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>http://mariogogogo.github.io/2021/02/18/算法入门/</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2021-02-20T09:26:04.465Z</updated>
    
    <content type="html"><![CDATA[<p>最常用的数据结构预算法:</p><p>数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire 树<br>算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p><a id="more"></a><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021022014image-20210220143950354.png"                      alt="image-20210220143950354"                ></p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>复杂度分析法则<br>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//每次执行一次</span></span><br></pre></td></tr></table></figure><h4 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="O-logN"><a href="#O-logN" class="headerlink" title="O(logN)"></a>O(logN)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt; n)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">   i*=<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>的多少次方 === N</span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><blockquote><p>算法在运行过程中临时占用存储空间大小的量度</p></blockquote><h4 id="0-1"><a href="#0-1" class="headerlink" title="0(1)"></a>0(1)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//声明了单个变量  占用内存就是1</span></span><br></pre></td></tr></table></figure><h4 id="O-n-1"><a href="#O-n-1" class="headerlink" title="O(n)"></a>O(n)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  res.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res的空间占用 取决于 n</span></span><br></pre></td></tr></table></figure><h4 id="O-n-2-1"><a href="#O-n-2-1" class="headerlink" title="O(n^2)"></a>O(n^2)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  res.push(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    res[i].push(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">类似于一个矩阵---- - 多维数组;</span><br></pre></td></tr></table></figure><h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><h3 id="什么是线性"><a href="#什么是线性" class="headerlink" title="什么是线性"></a>什么是线性</h3><p>线性表: 线性表就是数据排成像一条线一样的结构.每个现行表上的数据最多只有前和后两个方向.常见的线性表结构：数组，链表、队列、栈等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2021022014image-20210220145243033.png"                      alt="image-20210220145243033"                ></p><h3 id="什么是非线性"><a href="#什么是非线性" class="headerlink" title="什么是非线性"></a>什么是非线性</h3><p>递归：比如二叉树遍历就是典型的非线性遍历结构</p><h2 id="刷题指南"><a href="#刷题指南" class="headerlink" title="刷题指南"></a>刷题指南</h2><blockquote><p>数据结构是工具，算法是通过合适的工具解决特定问题的办法</p></blockquote><p><strong>先刷二叉树，先刷二叉树，先刷二叉树，</strong></p><p>为什么呢？</p><p>因为二叉树是最容易培养框架思维的，而且大部分常考算法本质上都是树的遍历问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最常用的数据结构预算法:&lt;/p&gt;
&lt;p&gt;数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire 树&lt;br&gt;算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://mariogogogo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://mariogogogo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue-nextTick原理</title>
    <link href="http://mariogogogo.github.io/2020/12/15/Vue-nextTick%E5%8E%9F%E7%90%86/"/>
    <id>http://mariogogogo.github.io/2020/12/15/Vue-nextTick原理/</id>
    <published>2020-12-14T16:00:00.000Z</published>
    <updated>2021-01-05T05:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.了解nextTick的实现原理</p><p>2.了解数据变化到DOM的变化是异步过程</p><a id="more"></a><h2 id="先了解下宏任务和微任务"><a href="#先了解下宏任务和微任务" class="headerlink" title="先了解下宏任务和微任务"></a>先了解下宏任务和微任务</h2><table><thead><tr><th><strong>常见**</strong>宏任务**</th><th>setTimeout  setInterval  setImmediate    script    MessageChannel</th></tr></thead><tbody><tr><td><strong>常见**</strong>微任务**</td><td>Promise    MutationObserver        Object.observe(废弃)      process.nextTick（node）</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.nextTick = nextTick; <span class="comment">//赋值给大Vue的静态方法</span></span><br><span class="line"><span class="comment">//全局挂载</span></span><br><span class="line"> Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先查看是否浏览器支持<code>setImmediate</code>还有<code>Promise</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="keyword">if</span> (isIOS) &#123; <span class="built_in">setTimeout</span>(noop); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks);</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> callbacks = [] <span class="comment">//缓存进数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果没有传cb  则返回promise 可以接.then（）方法</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过判断 <code>pending</code> 来确定是否需要注册宏微任务 。</p><p>当第一次注册的时候，把 <code>pending</code> 设置为 <code>true</code>，表示任务队列已经在开始了，同一时期内无需注册了</p><p>然后在 任务队列 执行完毕之后，再把 pending 设置为 <code>false</code>（在 <code>flushCallbacks</code> 中）</p><h2 id="flushCallbacks"><a href="#flushCallbacks" class="headerlink" title="flushCallbacks"></a>flushCallbacks</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">var</span> pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏任务和 微任务 的回调，都是执行这个 flushCallbacks，这个方法作用：</p><p>1、复制一遍 callbacks </p><p>2、把 原来 callbacks 清空</p><p>3、遍历 复制的 callbacks ，然后逐个执行</p><h2 id="一个有意思的小测试"><a href="#一个有意思的小测试" class="headerlink" title="一个有意思的小测试"></a>一个有意思的小测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  retrun &#123;</span><br><span class="line">      msg: <span class="string">&quot;This is NextTick Page&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change () &#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&quot;hello vue&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;sync:&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText)   <span class="comment">// &#x27;This is NextTick Page&#x27;</span></span><br><span class="line">       <span class="built_in">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText) <span class="comment">// &#x27;hello vue&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.$nextTick().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText) <span class="comment">// &#x27;hello vue&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">change1 () &#123;</span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText) <span class="comment">// &#x27;This is NextTick Page&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&quot;hello vue&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;sync:&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText) <span class="comment">// &#x27;This is NextTick Page&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>,<span class="built_in">this</span>.$refs.msg.innerText) <span class="comment">// &#x27;hello vue&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>为什么会这样呢，因为callback函数会优先push进去$nextTick的cb函数，但这时候this.msg才开始重新赋值加入<code>flushSchedulerQueue</code>函数，重新渲染是再后面。所以第一个nextTick拿到的还是旧的值</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>nextTick</code>是要把执行的任务推入到一个队列中，再下一个tick同步执行</p><p>数据改变后触发了渲染watcher的update，但是watcher的flush是再nexttIck后，所以重新渲染是异步的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.了解nextTick的实现原理&lt;/p&gt;
&lt;p&gt;2.了解数据变化到DOM的变化是异步过程&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-数组劫持监听原理</title>
    <link href="http://mariogogogo.github.io/2020/12/11/Vue-%E6%95%B0%E7%BB%84%E5%8A%AB%E6%8C%81%E7%9B%91%E5%90%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://mariogogogo.github.io/2020/12/11/Vue-数组劫持监听原理/</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2021-01-05T05:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>响应式数据中对于对象<code>新增删除属性</code>及数组的下标访问修改核添加数据等变化是观察不到的</p></li><li><p>通过Vue.set以及数组的Api可以解决这些问题本质上他们内部手动做了依赖更新的派发</p></li></ol><a id="more"></a><h2 id="为什么监听不了"><a href="#为什么监听不了" class="headerlink" title="为什么监听不了"></a>为什么监听不了</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121009image-20201210093723350.png"                      alt="image-20201210093723350" style="zoom:50%;"                 ></p><p>从上面代码里，首先监听了model数组里所有的属性，然后通过各种数组的方法来修改当前数组，得出以下几个结论。</p><p>1、==直接修改数组中已有的元素是可以被监听的==。</p><p>2、数组的操作方法如果是操作已经存在的被监听的元素也是可以触发setter被监听的。</p><p>3、只有push、length、pop一些特殊的方法确实不能触发setter，这跟方法的内部实现与Object.defineProperty的setter钩子的触发实现有关系，是语言层面的原因。</p><p>4、==改变超过数组长度的下标的值时，值变化是不能监听到的==。这个其实很好理解，不存在的属性当然是不能监听到，因为绑定监听操作在之前已经执行过了，后添加的元素属性在绑定当时都还没有存在，当然没有办法提前去监听它了。</p><p>所以综上，Object.defineProperty不能监听到数组内的值变化的说法是错误的，同时也得出了a问题的答案，语言层面不支持用Object.defineProperty监听不存在的数组元素，并且通过一些能造成数组的方法造成数组改变也不能监听到。</p><h2 id="Vue监听Array三步曲"><a href="#Vue监听Array三步曲" class="headerlink" title="Vue监听Array三步曲"></a>Vue监听Array三步曲</h2><p>第一步：先获取原生 Array 的原型方法，因为拦截后还是需要原生的方法帮我们实现数组的变化。</p><p>第二步：对 Array 的原型方法使用 Object.defineProperty 做一些拦截操作。</p><p>第三步：==把需要被拦截的 Array 类型的数据原型指向改造后原型==。8888</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype <span class="comment">// 获取Array的原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key); <span class="comment">// 控制台输出 push</span></span><br><span class="line">      <span class="built_in">console</span>.log(args); <span class="comment">// 控制台输出 [Array(2), 7, &quot;hello!&quot;]</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取原生的方法</span></span><br><span class="line">      <span class="keyword">let</span> original = arrayProto[key];</span><br><span class="line">      <span class="comment">// 将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变</span></span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something 比如通知Vue视图进行更新</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我的数据被改变了，视图该更新啦&#x27;</span>);</span><br><span class="line">      <span class="built_in">this</span>.text = <span class="string">&#x27;hello Vue&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的原型</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写赋值</span></span><br><span class="line">def(obj, <span class="string">&#x27;push&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型的指向重写</span></span><br><span class="line">arr.__proto__ = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行push</span></span><br><span class="line">arr.push([<span class="number">1</span>, <span class="number">2</span>], <span class="number">7</span>, <span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>那必须想个办法–拦截器覆盖Array.prototype。</p><blockquote><p>通过Vue.set可以解决这个问题，本质上内部手动去做了==依赖更新的派发==</p></blockquote><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><blockquote><p>Array在<code>getter</code>中收集依赖，在拦截器中触发依赖</p></blockquote><p>最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(arr, injackingPrototype)</span><br></pre></td></tr></table></figure><p>数组是一种特殊的对象，其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象。</p><p>但是 Vue 并没有采用上述方法劫持数组对象，笔者猜测主要由于以下两点：（读者有更好的见解，欢迎留言。）</p><p><strong>1、特殊的 length 属性</strong></p><p>数组对象的 length 属性的描述符天生独特：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(arr, <span class="string">&#x27;length&#x27;</span>).configurable <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这就意味着无法通过 Object.defineProperty() 方法劫持 length 属性的读取和设置方法。</p><p>相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。</p><p><strong>2、数组的操作场景</strong></p><p>数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。</p><p><strong>3、数组方法的劫持</strong></p><p>最终 Vue 选择劫持一些常用的数组操作方法，从而知晓数组的变化情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methods = [ <span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>]</span><br></pre></td></tr></table></figure><p>数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 Array.prototype 对象。</p><p>但是这里不能直接篡改 Array.prototype 对象，这样会影响所有的数组实例，为了避免这种情况，需要采用原型继承得到一个新的原型对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototypeconst injackingPrototype = <span class="built_in">Object</span>.create(arrayProto)</span><br></pre></td></tr></table></figure><p>拿到新的原型对象之后，再重写这些常用的操作方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> originArrayMethod = arrayProto[method]</span><br><span class="line"> injackingPrototype[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = originArrayMethod.apply(<span class="built_in">this</span>, args)</span><br><span class="line">  <span class="keyword">let</span> inserted</span><br><span class="line">  <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">    inserted = args</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">    inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">   <span class="comment">// 对于新增的元素，继续劫持</span></span><br><span class="line">   <span class="comment">// ob.observeArray(inserted)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知变化</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(arr, injackingPrototype)</span><br></pre></td></tr></table></figure><p>顺便提一下，采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//api:数组set方式数据改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  .............</span><br><span class="line">  <span class="comment">//isValidArrayIndex 判断数组是有效的下标</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key);</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val);</span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  .............</span><br><span class="line">  <span class="keyword">var</span> ob = (target).__ob__;</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变成响应式对象</span></span><br><span class="line">  defineReactive(ob.value, key, val);</span><br><span class="line">  <span class="comment">// 通知依赖更新</span></span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj,</span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  val,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// debugger 如果下面没有依赖收集 则久不会更新</span></span><br><span class="line">          <span class="comment">// ❤️❤️❤️❤️很关键 依赖收集</span></span><br><span class="line">         childOb.dep.depend(); </span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="methodsToPatch"><a href="#methodsToPatch" class="headerlink" title="methodsToPatch"></a>methodsToPatch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录原始Array未重写之前的API原型方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 拷贝一份上面的原型出来</span></span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 将要重写的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [ <span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 原有的数组方法调用执行</span></span><br><span class="line">    <span class="keyword">const</span> result = arrayProto[method].apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是插入的数据，将其再次监听起来</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发订阅，像页面更新响应就在这里触发</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>手动调用:star::star::star:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.dep.notify()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>为什么数组变化内部用splice 外部可以用push都可以改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.splice(key, <span class="number">1</span>, val);</span><br><span class="line"><span class="built_in">this</span>.array.push(<span class="number">100</span>)  <span class="comment">//数组的添加</span></span><br></pre></td></tr></table></figure><h2 id="最后看看尤大的回答"><a href="#最后看看尤大的回答" class="headerlink" title="最后看看尤大的回答"></a>最后看看尤大的回答</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121009image-20201210095216449.png"                      alt="image-20201210095216449"                ></p><h2 id="12月更新–扩展一下Vue3-0的数组监听"><a href="#12月更新–扩展一下Vue3-0的数组监听" class="headerlink" title="12月更新–扩展一下Vue3.0的数组监听"></a>12月更新–扩展一下Vue3.0的数组监听</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">  name: <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    val: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  list: [<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObj</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监控器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将属性都做监控</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isObj(data[key])) &#123;</span><br><span class="line">      <span class="comment">// 对象类型的继续监听它的属性</span></span><br><span class="line">      data[key] = observe(data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defineProxy(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成Proxy代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProxy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">obj, key, val</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`属性<span class="subst">$&#123;key&#125;</span>变化为<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">      compile(obj, key, val);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析器，响应页面变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">obj, id, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123; <span class="comment">// 数组变化</span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>).value = model.list;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;id&#125;</span>`</span>).value = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">model= observe(model);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;响应式数据中对于对象&lt;code&gt;新增删除属性&lt;/code&gt;及数组的下标访问修改核添加数据等变化是观察不到的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过Vue.set以及数组的Api可以解决这些问题本质上他们内部手动做了依赖更新的派发&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue—Watch原理</title>
    <link href="http://mariogogogo.github.io/2020/12/09/Vue-Watch%E5%8E%9F%E7%90%86/"/>
    <id>http://mariogogogo.github.io/2020/12/09/Vue-Watch原理/</id>
    <published>2020-12-08T16:00:00.000Z</published>
    <updated>2021-06-18T06:48:57.672Z</updated>
    
    <content type="html"><![CDATA[<p>今天分析下Watch的内部原理</p><a id="more"></a><h3 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h3><p> 1、监听的数据改变的时，watch 如何工作<br> 2、设置 immediate 时，watch 如何工作<br> 3、设置了 deep 时，watch 如何工作</p><h2 id="常见的api使用情况"><a href="#常见的api使用情况" class="headerlink" title="常见的api使用情况"></a>常见的api使用情况</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">   <span class="comment">//函数</span></span><br><span class="line">   <span class="function"><span class="title">useless</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;useless&#x27;</span>,newValue)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">//对象</span></span><br><span class="line">   name:&#123;</span><br><span class="line">     immediate:<span class="literal">true</span>,  </span><br><span class="line">     <span class="function"><span class="title">handler</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span>,newValue)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   nestect:&#123;</span><br><span class="line">     deep:<span class="literal">true</span>,</span><br><span class="line">     <span class="function"><span class="title">handler</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;nestect&#x27;</span>,newValue)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h2 id="什么时候初始化"><a href="#什么时候初始化" class="headerlink" title="什么时候初始化"></a>什么时候初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opts.watch !== nativeWatch</code>的意思是不等于浏览器原生的watch，为什么要这样写？</p><p>因为Firefox浏览器中Object.prototype中有个watch方法，如果用户没有设置watch，则opts.watch 将是Object.prototype.watch</p><h2 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm, watch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="comment">//handler 类型是不确定的 可以是 对象 方法  字符串 数组</span></span><br><span class="line">    <span class="keyword">var</span> handler = watch[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="comment">//如果是数组遍历每一项来创建watcher</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createWatcher"><a href="#createWatcher" class="headerlink" title="createWatcher"></a>createWatcher</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,  <span class="comment">//vue实例</span></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn, <span class="comment">//表达式 或者 计算属性函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  handler, <span class="comment">//回调函数  或者 字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">  options <span class="comment">//传递给vm.$watch选项对象</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler;</span><br><span class="line">    handler = handler.handler;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    handler = vm[handler];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch 在一开始初始化的时候，会 <strong>读取</strong> 一遍 监听的数据的值，于是，此时 那个数据就收集到 watch 的 watcher 了</p><p>然后 你给 watch 设置的 handler ，watch 会放入 watcher 的更新函数中</p><p>当 数据改变时，通知 watch 的 watcher 进行更新，于是 你设置的 handler 就被调用了</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121715image-20201217154210438.png"                      alt="image-20201217154210438"                ></p><h2 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    options.user = <span class="literal">true</span>; <span class="comment">// 代表watcher 为 userWatcher</span></span><br><span class="line">    <span class="comment">//创建watcher实例 这是一个 user watcher，因为 options.user = true</span></span><br><span class="line">    <span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options);</span><br><span class="line">    <span class="comment">//immediate = true 则函数立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      cb.call(vm, watcher.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//销毁watcher函数</span></span><br><span class="line">      watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、判断是否立即执行监听回调</strong></p><p>如果你设置了 <code>immediate</code> 的话，表示不用等我数据变化，初始化时马上执行一遍，执行的代码就是直接调用 回调，绑定上下文，传入监听值</p><p><strong>2、每个 watch 配发 watcher</strong></p><h2 id="new-Watcher"><a href="#new-Watcher" class="headerlink" title="new Watcher"></a>new Watcher</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  options,</span></span></span><br><span class="line"><span class="function"><span class="params">  isRenderWatcher</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">    vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="built_in">this</span>.deep = !!options.deep;</span><br><span class="line">    <span class="built_in">this</span>.user = !!options.user;</span><br><span class="line">    <span class="built_in">this</span>.computed = !!options.computed;</span><br><span class="line">    <span class="built_in">this</span>.sync = !!options.sync;</span><br><span class="line">    <span class="built_in">this</span>.before = options.before;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.computed = <span class="built_in">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.cb = cb;</span><br><span class="line">  <span class="built_in">this</span>.id = ++uid$<span class="number">1</span>; <span class="comment">// uid for batching</span></span><br><span class="line">  <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.computed; <span class="comment">// for computed watchers</span></span><br><span class="line">  <span class="built_in">this</span>.deps = [];</span><br><span class="line">  <span class="built_in">this</span>.newDeps = [];</span><br><span class="line">  <span class="built_in">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">  <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">  <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? expOrFn.toString()</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// parse expression for getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.computed) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>this.getter 的函数进行理解，他的本质是为了获取对象的key值.</strong></p><p>当 watch.getter 执行，而读取了 <code>vm.name</code> 的时候，==name的依赖收集器就会收集到 watch-watcher==</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushTarget(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, (<span class="string">&quot;getter for watcher \&quot;&quot;</span> + (<span class="built_in">this</span>.expression) + <span class="string">&quot;\&quot;&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value);</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Watch 在结尾会立即执行一次 watcher.get，其中便会执行 getter，便会根据你监听的key，去实例上读取并返回，存放在 watcher.value 上</p><h2 id="deep深度监听"><a href="#deep深度监听" class="headerlink" title="deep深度监听"></a>deep深度监听</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects);</span><br><span class="line">  seenObjects.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val, seen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, keys;</span><br><span class="line">  <span class="keyword">var</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断值是否已经响应式</span></span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">var</span> depId = val.__ob__.dep.id;</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//是否是数组</span></span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; _traverse(val[i], seen); &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//递归遍历对象</span></span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">    i = keys.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; _traverse(val[keys[i]], seen); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是深层级的对象，其中的每个属性也都是响应式的，每个属性都有自己的依赖收集器</p><p>通过不断深入的读取每个属性，这样每个属性就都可以收集到 <code>watch-watcher</code> 了</p><p>这样不管对象内多深的属性变化，都会通知到 <code>watch-watcher</code></p><h2 id="回调更新"><a href="#回调更新" class="headerlink" title="回调更新"></a>回调更新</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run(); <span class="comment">//同步执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>); <span class="comment">//先执行这里</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getAndInvoke(<span class="built_in">this</span>.cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比计算属性返回值</span></span><br><span class="line">Watcher.prototype.getAndInvoke = <span class="function"><span class="keyword">function</span> <span class="title">getAndInvoke</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="built_in">this</span>.get();</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    value !== <span class="built_in">this</span>.value ||</span><br><span class="line">    isObject(value) ||</span><br><span class="line">    <span class="built_in">this</span>.deep</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// set new value</span></span><br><span class="line">    <span class="keyword">var</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行回调函数</span></span><br><span class="line">        cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, <span class="built_in">this</span>.vm, (<span class="string">&quot;callback for watcher \&quot;&quot;</span> + (<span class="built_in">this</span>.expression) + <span class="string">&quot;\&quot;&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121616image-20201216161914318.png"                      alt="image-20201216161914318"                ></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>watcher属性本质就是<code>user watcher</code>，它还支持deep，sync，immediate等配置，监听属性适合观察某个值得变化去完成一段复杂的业务逻辑。</p><p>如何实现watch监听？<code>正是因为watch对应key是被数据拦截的属性</code>，在选项watch下：</p><ul><li>每一个key都会对应一个watcher对象</li><li>watcher对象的getter函数就是获取当前key对应的值，从而建立key对应Dep对象与当前watcher对象建立联系</li><li>当key改变时就会触发视图更新，从而执行key对应的回调函数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分析下Watch的内部原理&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>各种移动端Bug解决方案</title>
    <link href="http://mariogogogo.github.io/2020/12/08/%E5%90%84%E7%A7%8D%E7%A7%BB%E5%8A%A8%E7%AB%AFBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://mariogogogo.github.io/2020/12/08/各种移动端Bug解决方案/</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2020-12-08T07:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种移动端Bug解决方案持续更新"><a href="#各种移动端Bug解决方案持续更新" class="headerlink" title="各种移动端Bug解决方案持续更新"></a>各种移动端Bug解决方案持续更新</h1><p><a class="link"   href="https://www.notion.so/Bug-075fd58447e94728a6e1ac2b84e10764" >各种移动端Bug解决方案<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种移动端Bug解决方案持续更新&quot;&gt;&lt;a href=&quot;#各种移动端Bug解决方案持续更新&quot; class=&quot;headerlink&quot; title=&quot;各种移动端Bug解决方案持续更新&quot;&gt;&lt;/a&gt;各种移动端Bug解决方案持续更新&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link
      
    
    </summary>
    
      <category term="Web" scheme="http://mariogogogo.github.io/categories/Web/"/>
    
    
      <category term="Javascript" scheme="http://mariogogogo.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue—props原理</title>
    <link href="http://mariogogogo.github.io/2020/12/06/Vue-props%E5%8E%9F%E7%90%86/"/>
    <id>http://mariogogogo.github.io/2020/12/06/Vue-props原理/</id>
    <published>2020-12-05T16:00:00.000Z</published>
    <updated>2021-06-21T01:33:46.634Z</updated>
    
    <content type="html"><![CDATA[<p>今天分析下props的内部原理</p><a id="more"></a><h3 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h3><p> 1、父组件 怎么传值给 子组件的 props<br> 2、子组件如何读取props<br> 3、父组件 data 更新，子组件的props 如何更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">          &lt;h1&gt;分析props&lt;/h1&gt;</span><br><span class="line">          &lt;hello-world :msg=<span class="string">&quot;parentMsg&quot;</span>&gt;&lt;/hello-world&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;hello&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg:&#123;</span><br><span class="line">      type:<span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>模板解析过程中，如果某个标签的名字是组件名，虚拟DOM渲染过程中会将<code>子组件实例化</code>，模板解析时候从标签属性上解析出数据当做参数传递给子组件，其中就包括<code>props数据</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析父组件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">staticClass</span>:<span class="string">&quot;parent&quot;</span>&#125;,[</span><br><span class="line">            _c(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;&#125;&#125;)</span><br><span class="line">            _c(<span class="string">&#x27;hello-world&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">&quot;msg&quot;</span>:parentMsg&#125;&#125;)</span><br><span class="line">        ],<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with 的作用是，绑定大括号内代码的 <strong>变量访问作用域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123; <span class="built_in">console</span>.log(parentName) &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.call(&#123;<span class="attr">parentName</span>:<span class="string">&quot;测试名字&quot;</span>&#125;)  <span class="comment">//测试名字</span></span><br></pre></td></tr></table></figure><p>props的实现原理简单的理解：父组件提供数据，子组件通过props字段选择组件需要哪些内如，通过子组件props选项将需要的数据筛选出来添加到子组件的上下文中</p><h2 id="normalizeProps"><a href="#normalizeProps" class="headerlink" title="normalizeProps"></a>normalizeProps</h2><p>Vue.component()注册组件的时候会调用Vue.extend()生成一个Vue基础构造器，内部会调用mergeOptions函数合并属性， mergeOptions又会调用normalizeProps对props的属性进行一些规范化的修饰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span> (<span class="params">options, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> props = options.props;</span><br><span class="line">  <span class="keyword">if</span> (!props) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> i, val, name;</span><br><span class="line">  <span class="comment">//如果props是个数组 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    i = props.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        name = camelize(val);</span><br><span class="line">        <span class="comment">//保存到res里面  例如:&#123; msg: &#123;type: null&#125; &#125;</span></span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">//...错误处理</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果props是个对象  </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key];</span><br><span class="line">      name = camelize(key);</span><br><span class="line">      res[name] = isPlainObject(val)</span><br><span class="line">        ? val</span><br><span class="line">        : &#123; <span class="attr">type</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">   <span class="comment">//...错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 经过normalizeProps规范后，props被修饰为一个对象格式，例子里的执行到这里等于:<code>&#123; msg: &#123;type: null&#125; &#125;</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    initState(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options;    </span><br><span class="line">    <span class="keyword">if</span> (opts.props) &#123;</span><br><span class="line">        initProps(vm, opts.props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h2><p>initProps接受2个参：<code>vm</code>  <code>propsOptions</code>。</p><p>第一个参是 vm实例。</p><p>第二个参是 规格化后的props选项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm, propsOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> props = vm._props = &#123;&#125;;</span><br><span class="line">  <span class="comment">//缓存props的key</span></span><br><span class="line">  <span class="keyword">var</span> keys = vm.$options._propKeys = [];</span><br><span class="line">  <span class="keyword">var</span> isRoot = !vm.$parent;</span><br><span class="line">  <span class="comment">//如果不是根组件则变成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;</span><br><span class="line">    keys.push(key);</span><br><span class="line">    <span class="keyword">var</span> value = validateProp(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">       <span class="comment">//...错误处理</span></span><br><span class="line">      defineReactive(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...错误处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="comment">//设置代理 把vm.x 访问 vm._props.x</span></span><br><span class="line">      proxy(vm, <span class="string">&quot;_props&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop( key );</span><br><span class="line">  toggleObserving(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 每一个 实例都会有 一个 _props 的同时，也会把属性直接放在 实例上。</p><table><thead><tr><th style="text-align:left">propsData</th><th style="text-align:left">保存通过父组件传入或者用户通过propsData传入的props数据</th></tr></thead><tbody><tr><td style="text-align:left">props</td><td style="text-align:left">指向vm._props指针。所有设置到props变量中的属性保存到vm.props</td></tr><tr><td style="text-align:left">keys</td><td style="text-align:left">指向 vm.$options._propskeys</td></tr><tr><td style="text-align:left">isRoot</td><td style="text-align:left">判断是否是根组件</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了三件事</p><p>1、遍历 props</p><p>2、给 props 设置响应式</p><p>3、给 props 设置代理 (把vm.x 访问 vm._props.x)</p><h2 id="validateProp"><a href="#validateProp" class="headerlink" title="validateProp"></a>validateProp</h2><p>调用这个函数得到的props数据通过defineReactive函数设置到vm._props中，目的就是<code>校验</code>，就是检查一下我们传递的数据是否满足 <code>prop</code>的定义规范</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行validateProp检查propsData里的key值是否符合propsOptions里对应的要求，并将值保存到value里面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prop = propOptions[key];</span><br><span class="line">  <span class="keyword">var</span> absent = !hasOwn(propsData, key);</span><br><span class="line">  <span class="keyword">var</span> value = propsData[key];</span><br><span class="line">  <span class="comment">// boolean casting</span></span><br><span class="line">  <span class="keyword">var</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type);</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">&#x27;default&#x27;</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span> || value === hyphenate(key)) &#123;</span><br><span class="line">      <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">      <span class="comment">// boolean has higher priority</span></span><br><span class="line">      <span class="keyword">var</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type);</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//✅✅✅检测如果 prop 没有定义 default 属性，那么返回 undefined，通过这块逻辑我们知道除了 Boolean 类型的数据，其余没有设置    default 属性的 prop 默认值都是 undefined。</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = getPropDefaultValue(vm, prop, key);</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">var</span> prevShouldObserve = shouldObserve;</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">    observe(value);</span><br><span class="line">    toggleObserving(prevShouldObserve);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// skip validation for weex recycle-list child component props</span></span><br><span class="line">    !(<span class="literal">false</span> &amp;&amp; isObject(value) &amp;&amp; (<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> value))</span><br><span class="line">  ) &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要就做 3 件事情：</p><ol><li>处理 <code>Boolean</code> 类型的数据。</li><li>处理默认数据。</li><li><code>prop</code> 断言，并最终返回 <code>prop</code> 的值。</li></ol><h2 id="proxy代理"><a href="#proxy代理" class="headerlink" title="proxy代理"></a><strong>proxy</strong>代理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target, sourceKey, key</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;    </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;            </span><br><span class="line">          <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码做了2 个事</strong></p><p>1、使用 props 在 vm 上占位，使得可以通过 vm.xxx 的形式访问到 props </p><p>2、设置 [Object.defineProperty] 的 get 和 set ，间接获取和赋值 vm._props</p><h2 id="defineReactive响应式"><a href="#defineReactive响应式" class="headerlink" title="defineReactive响应式"></a>defineReactive响应式</h2><p>在 <code>defineReactive</code> 的时候会添加一个自定义 <code>setter</code>，当我们直接对 <code>prop</code> 赋值的时候会输出警告。</p><p><code>prop</code> 的响应式有一点不同的是当 <code>vm</code> 是非根实例的时候，会先执行 <code>toggleObserving(false)</code>，它的目的是为了响应式的优化</p><h2 id="Props-更新"><a href="#Props-更新" class="headerlink" title="Props 更新"></a>Props 更新</h2><p> 如果是基本类型，是这个流程</p><ol><li>父组件数据改变，只会把新的数据传给子组件</li><li>子组件拿到新数据，就会直接替换到原来的 props</li><li>替换就是直接等哈，看下源码，重要语句标红</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vm, propsData</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;        </span><br><span class="line">      <span class="comment">// 保存 props 的地方，用于访问转接，具体看文章下面</span></span><br><span class="line">      <span class="keyword">var</span> props = vm._props;        </span><br><span class="line">      <span class="comment">// 所有子组件上设置的 props 的 key</span></span><br><span class="line">      <span class="keyword">var</span> propKeys = vm.$options._propKeys || [];        </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;            </span><br><span class="line">        <span class="keyword">var</span> key = propKeys[i];</span><br><span class="line">        props[key] = propsData[key]</span><br><span class="line">      &#125;</span><br><span class="line">     vm.$options.propsData = propsData;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是对象，是这个流程</p><ol><li>父组件传 对象 给 子组件，并且父子组件 页面都使用到了这个数据</li><li>结果那么这个对象，会收集到 父子组件的 watcher</li><li>所以当 对象内部被修改的时候，会通知到 父和子 更新。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、父组件 data 的值 和 子组件的 props <strong>没有任何联系</strong>，更改 props 不影响父组件 data （其实也影响如果data是个对象）</p><p>2、props 也是<strong>响应式</strong>的，跟 data 本质 差不多</p><p>3、props 会访问转接，赋值转接 ，其实操作的是 <strong>vm._props</strong> 的属性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分析下props的内部原理&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue—响应式对象</title>
    <link href="http://mariogogogo.github.io/2020/12/04/Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://mariogogogo.github.io/2020/12/04/Vue-响应式对象/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2021-06-18T06:57:00.355Z</updated>
    
    <content type="html"><![CDATA[<p>被Object.defineProperty绑定过的对象，会变成「响应式」化。也就是改变这个对象的时候会触发get和set事件。进而触发一些视图更新</p><a id="more"></a><h3 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h3><p> 1、Vue 是怎么知道数据改变？<br> 2、Vue 在数据改变时，怎么知道通知哪些视图更新？<br> 3、Vue 在数据改变时，视图怎么知道什么时候更新？</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我被读了，我要不要做点什么好?&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="params">newVal</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;数据被改变了，我要把新的值渲染到页面上去!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  text: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对data上的text属性进行绑定</span></span><br><span class="line">defineReactive(data, <span class="string">&#x27;text&#x27;</span>, data.text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.text); <span class="comment">// 控制台输出 &lt;我被读了，我要不要做点什么好?&gt;</span></span><br><span class="line">data.text = <span class="string">&#x27;hello Vue&#x27;</span>; <span class="comment">// 控制台输出 &lt;hello Vue &amp;&amp; 数据被改变了，我要把新的值渲染到页面上去!&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Observer「响应式」"><a href="#Observer「响应式」" class="headerlink" title="Observer「响应式」"></a>Observer「响应式」</h2><p>Vue中用Observer类来管理上述响应式化Object.defineProperty的过程。我们可以用如下代码来描述，将this.data也就是我们在Vue代码中定义的data属性全部进行「响应式」绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 响应式绑定数据通过方法</span></span><br><span class="line">   observe(<span class="built_in">this</span>.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 将data中我们定义的每个属性进行响应式绑定</span></span><br><span class="line">    defineReactive(obj, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码中"><a href="#源码中" class="headerlink" title="源码中"></a>源码中</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shouldObserve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   尝试为一个值创建一个观察者实例； </span></span><br><span class="line"><span class="comment"> *  如果成功观察到，则返回新观察者； </span></span><br><span class="line"><span class="comment"> *  如果该值已经具有一个观察者，则返回现有观察者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// value是不是object 不能是vnode实例</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="comment">//判断带不带 ob标识</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;   <span class="comment">//全局控制 shouldObserve === false </span></span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;   <span class="comment">//可扩展属性</span></span><br><span class="line">    !value._isVue       <span class="comment">//不是vue实例</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 附加到每个观察对象的观察者类。附加后，</span></span><br><span class="line"><span class="comment"> 观察者会将目标对象的属性键转换为用于收集依赖项并调度更新的getter / setter。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">//创建dep实例 后面再说先跳过</span></span><br><span class="line">  <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//目的 为valu添加ob标识 变成响应式 并且this指向当前实例</span></span><br><span class="line">  <span class="comment">//下一次执行上面的hasOwn(value, &#x27;__ob__&#x27;) 直接true了</span></span><br><span class="line">  def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.observeArray(value);  <span class="comment">//遍历数组每一个元素 递归把他们都观察起来</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value);<span class="comment">//遍历对象每一个属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//enumerable 是不可枚举 如果不传则是 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj, key, val, enumerable</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,  <span class="comment">//false 代表不可枚举 不能加入for循环</span></span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 观察数组项的列表。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">     observe(items[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历所有属性并将它们转换为* getter / setter。</span></span><br><span class="line"><span class="comment">  * 仅当*值类型为Object时，才应调用此方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">     defineReactive$$1(obj, keys[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="defineReactive-1"><a href="#defineReactive-1" class="headerlink" title="defineReactive$$1"></a>defineReactive$$1</h2><p>就是把对象变成响应式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">   obj,</span></span></span><br><span class="line"><span class="function"><span class="params">   key,</span></span></span><br><span class="line"><span class="function"><span class="params">   val,</span></span></span><br><span class="line"><span class="function"><span class="params">   customSetter,</span></span></span><br><span class="line"><span class="function"><span class="params">   shallow</span></span></span><br><span class="line"><span class="function"><span class="params"> </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 如果有childe  则递归调用observe</span></span><br><span class="line">   <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">     enumerable: <span class="literal">true</span>,</span><br><span class="line">     configurable: <span class="literal">true</span>,</span><br><span class="line">     get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">       <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">         dep.depend();    <span class="comment">//依赖收集</span></span><br><span class="line">         <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">           childOb.dep.depend();</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">             dependArray(value);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> value</span><br><span class="line">     &#125;,</span><br><span class="line">     set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">       <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">       <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">       <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">         customSetter();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">       <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">       <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">         setter.call(obj, newVal);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         val = newVal;</span><br><span class="line">       &#125;</span><br><span class="line">       childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">       dep.notify();  <span class="comment">//派发更新</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>响应式对象就是给它对象上的属性添加getter/setter,无论访问还是修改它都有一定的逻辑需要执行</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121014image-20201210145546930.png"                      alt="image-20201210145546930" style="zoom:70%;"                 ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121015image-20201210150502903.png"                      alt="image-20201210150502903" style="zoom:70%;"                 ></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、data 中每个声明的属性，都会有一个 专属的依赖收集器 <code>subs</code></p><p>2、当页面使用到 某个属性时，页面的 <code>watcher</code> 就会被 放到 依赖收集器 <code>subs</code> 中</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/h5web/2020121015image-20201210150707130.png"                      alt="image-20201210150707130"                ></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被Object.defineProperty绑定过的对象，会变成「响应式」化。也就是改变这个对象的时候会触发get和set事件。进而触发一些视图更新&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue—DOM挂载机制</title>
    <link href="http://mariogogogo.github.io/2020/12/03/Vue-DOM%E6%8C%82%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://mariogogogo.github.io/2020/12/03/Vue-DOM挂载机制/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-15T02:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 中我们是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的<br><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Temp <span class="keyword">from</span> <span class="string">&#x27;./Temp.vue&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el是实例挂载点，会将根组件替换掉原文档中id为 app 标签</span></span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="comment">// 通过render函数渲染</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里App是根组件</span></span><br><span class="line">        h(App)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Temp.vue</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"> 这是消息：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid$<span class="number">3</span>++;</span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// expose real self  初始化</span></span><br><span class="line">    vm._self = vm;</span><br><span class="line">    <span class="comment">/******************/</span></span><br><span class="line">    initLifecycle(vm);</span><br><span class="line">    initEvents(vm);</span><br><span class="line">    initRender(vm);</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">    initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm);</span><br><span class="line">    initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="comment">/**************************/</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      <span class="comment">//跳转 10976行</span></span><br><span class="line">      vm.$mount(vm.$options.el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mount = Vue.prototype.$mount;</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//如果没有render函数，那么获取模板将模板编译成渲染函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将vue原型上的<code>$mount</code>方法保存在mount中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012121629474342020121216.png"                      alt="image-20201212162947434"                ></p><p>然后Vue原型上<code>$mount</code>方法上被一个<code>新的方法覆盖</code>了。新方法会调用原始的方法，这种方法通常被称为<code>函数劫持</code>。通常函数劫持可以在原有功能的基础上<code>新增其他功能</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">&#x27;Cannot find element: &#x27;</span> + el</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query的主要作用是获取DOM元素</p><h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><p>$mount方法将id转换为dom元素后，使用mountComponent函数将Vue.js实例挂载到DOM上。</p><blockquote><p>实例挂载到DOM上实际就是将模板渲染到指定DOM元素中。而且是持续性的，当状态发生改变，可以重新触发渲染到指定DOM元素中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//开发环境会发出⚠️警告</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行生命周期beforeMount方法</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义方法</span></span><br><span class="line">  <span class="keyword">var</span> updateComponent;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//挂载</span></span><br><span class="line">    updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//vm._render() ==&gt; 生成vnode  传入update</span></span><br><span class="line">      vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before: <span class="function"><span class="keyword">function</span> <span class="title">before</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm  <span class="comment">//返回vm实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vm._update</code>的作用调用虚拟DOM中<code>patch方法</code>去执行<code>节点对比</code>与<code>渲染操作</code></p><p><code>vm._render()</code>执行渲染函数得到一份最新的<code>VNode节点树</code></p><p>==先执行渲染函数得到一份最新的node节点，然后通过_update方法对最新的Vnode和旧Vnode进行对比并更新dom节点。==</p><h2 id="new-Watcher"><a href="#new-Watcher" class="headerlink" title="new Watcher"></a>new Watcher</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before: <span class="function"><span class="keyword">function</span> <span class="title">before</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br></pre></td></tr></table></figure><p>在new Watcher中很重要的一步就是将<code>updateComponent</code> 赋值给<code>watcher.getter</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  options,</span></span></span><br><span class="line"><span class="function"><span class="params">  isRenderWatcher</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012121655076302020121216.png"                      alt="image-20201212165507630"                ></p><p><strong>挂载是持续性的，这个关键在于用new watcher，当它的第二个参数<code>updateComponent</code> 支持函数，它会同时观察函数中读取所有vue实例上的响应式数据</strong></p><p>挂载完毕后还有执行<code>mounted</code>钩子函数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012131047035452020121310.png"                      alt="image-20201213104703545" style="zoom:50%;"                 ></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 中我们是通过 &lt;code&gt;$mount&lt;/code&gt; 实例方法去挂载 &lt;code&gt;vm&lt;/code&gt; 的&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-初始化原理</title>
    <link href="http://mariogogogo.github.io/2020/12/01/Vue-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>http://mariogogogo.github.io/2020/12/01/Vue-初始化原理/</id>
    <published>2020-11-30T16:00:00.000Z</published>
    <updated>2021-06-21T01:34:09.924Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，<br>这样的编程思想是非常值得借鉴和学习的。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br></pre></td></tr></table></figure><p>构造函数中首先进行安全检查，然后进行_init初始化</p><h2 id="init"><a href="#init" class="headerlink" title="_init"></a>_init</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">        ...</span><br><span class="line">    vm._self = vm;</span><br><span class="line">    initLifecycle(vm);</span><br><span class="line">    initEvents(vm);</span><br><span class="line">    initRender(vm);</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">    initInjections(vm); <span class="comment">// 在数据/道具之前解决注入问题</span></span><br><span class="line">    initState(vm);</span><br><span class="line">    initProvide(vm); <span class="comment">// 解决提供数据/道具后的问题</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>); </span><br><span class="line">    </span><br><span class="line">      <span class="comment">//如果没有el选项，它就处于未挂载状态，没有关联的dom，</span></span><br><span class="line">      <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">         <span class="comment">//调用mount挂载vm，渲染成真实dom</span></span><br><span class="line">         vm.$mount(vm.$options.el);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数initMixin被调用，会向vue构造函数的<code>prototype</code>属性添加<code>init</code>方法，当执行new Vue(),就会调用_init方法，该方法实现一系列初始化操作，包括生命周期，及响应式系统流程的启动等</p><h3 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a>mergeOptions</h3><p>这个函数的目的将用户传递的<code>options</code>,与当前构造函数的<code>options</code>及==父级实例==构造函数的<code>options</code>合并成一个新的<code>options</code> 赋值给<code>$options</code>属性，</p><p>为什么会有父级？ </p><p>因为vue.js可能是一个子组件</p><p>初始化事件与属性后触发生命周期<code>beforeCreate</code>，</p><p>随后初始化provide/inject和state后触发<code>created</code></p><h2 id="callHook函数原理"><a href="#callHook函数原理" class="headerlink" title="callHook函数原理"></a>callHook函数原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm, hook</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget();</span><br><span class="line">  <span class="keyword">var</span> handlers = vm.$options[hook];</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="comment">//捕获钩子函数发生的错误 js单线程如果错误了就会停止往下执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handlers[i].call(vm);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, (hook + <span class="string">&quot; hook&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callHook的作用是触发用户设置生命周期钩子</code>，而用户设置的生命周期钩子会在new Vue（）通过参数传递给vue，可以通过options参数得到用户设置的生命周期钩子<code>（vm.$options.created获取到的是一个数组，数组包含钩子函数）</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012112320016442020121123.png"                      alt="image-20201211232001644"                ></p><h3 id="为什么生命周期函数钩子转换成数组？"><a href="#为什么生命周期函数钩子转换成数组？" class="headerlink" title="为什么生命周期函数钩子转换成数组？"></a>为什么生命周期函数钩子转换成数组？</h3><p>我们知道在Vue.mixin中也可以写入生命周期钩子，如果与一个组件一起混用，需要同时触发2个生命周期函数，而转成数组后，可以在同一个生命周期钩子列表中保存多个生命周期钩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;混入对象的钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">&#x27;./mixin&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins:[mixin],</span><br><span class="line">    name:<span class="string">&quot;temp&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">         msg:<span class="string">&quot;hello vue&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012112330004232020121123.png"                      alt="image-20201211233000423"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012112332129822020121123.png"                      alt="image-20201211233212982"                ></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>各种初始化逻辑我们先不看。在初始化的最后，检测到如果有el属性，则调用vm.$mount方法挂载vm，挂载的目标就是==把模板渲染成最终的 DOM==</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，&lt;br&gt;这样的编程思想是非常值得借鉴和学习的。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>为什么要有一个好的架构</title>
    <link href="http://mariogogogo.github.io/2020/11/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
    <id>http://mariogogogo.github.io/2020/11/15/为什么要有一个好的架构/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-12-09T05:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、为什么要有一个好的架构"><a href="#1、为什么要有一个好的架构" class="headerlink" title="1、为什么要有一个好的架构"></a>1、为什么要有一个好的架构</h2><p> 首先明确一点，<code>架构是为需求服务的</code>。</p><a id="more"></a><p> 前端架构存在的目的，就我个人理解来说，有以下几点：</p><p>  1、提高代码的可读性。一个好的架构，代码的可读性一定是很强的。简单来说，假如有一个新人加入团队，那么他接手这个项目，一定是容易上手的，能简单轻松的了解整个前端部分的相互关系，从而找到自己需要重点关注的点。而不是需要花很多时间去熟悉这个项目的很多细节，才能开始上手做东西。就文件来说，可以从文件名上，分清哪些是页面、哪些是逻辑、哪些是样式、哪些是可以复用的组件、哪些是图标组、又有哪些是移动端或是PC端专享的样式/逻辑等。就代码来说，包括统一的命名风格，封装在同一个文件里的代码的相关性足够强等。</p><p>  2、提高代码的可维护性。一个好的架构，一定是易于维护的，例如在新增需求、更改需求、修正bug，都不会造成意料之外的变化，比如说修改了一个页面组件的内容，却导致另外一个页面组件发生变化（这也太坑了）。因此，要低耦合，高内聚，以及输入和输出是可预期的。</p><p>  3、提高代码的可扩展性。一个好的架构，一定扩展性要强，不能写死。需求变更太TM正常了，新增需求也太TM正常了。因此好的架构，必须要考虑到这些情况的发生，因为他们是一定会发生的。所以，<code>一定要避免把代码写死</code>。比如页面组件A里需要有一个日历组件，而这个日历组件引用的是别人的（比如从github上找的）。那么尽量不要直接在页面组件A里面直接引用这个日历组件，而是将写一个日历组件B，在这个日历组件B里封装你引用的日历组件C，然后通过这个日历组件B来进行操作。<code>原因很简单，假如某天产品经理说，这个日历组件太丑了，我们换一个吧。如果你直接在页面组件A里内嵌这个引用的日历组件C，你很可能就要改很多代码（因为不同日历组件的使用方法和暴露的接口可能不同）</code>。假如你还在其他多个地方引用了这个日历组件，那就更糟糕了！每个地方都要改。而若是将引用的日历组件C封装到自己写的日历组件B之中，那么你只需要改日历组件B里的相应代码即可，而因为日历组件B暴露的接口是不变的，那么自然不用修改页面中的代码了。</p><p> 附图，以日历组件为例，是否考虑到扩展性的结果</p><p> <strong>未考虑到扩展性</strong></p><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011302242444772020113022.png"                      alt="image-20201130224244477"                ></p><p> <strong>考虑到扩展性：</strong></p><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011302243019392020113022.png"                      alt="image-20201130224301939"                ></p><p>  4、便于协同。包括前端和后端的协同，前端和前端之间的协同。具体来说，前后端的协同通常是以ajax为交互，那么应至少有一个用于专门封装了所有ajax请求的文件，所有ajax请求都封装在这里。在开发时，这里封装的方法应该可以模拟发送和接收约定好的交互内容，方便开发联调。而前端和前端的协同，主要体现在同时在更改代码时，不会影响对方代码的正常运行。因此要求封装、解耦以及低干扰度是必须的。</p><p>  5、自动化自动打包，压缩，混淆，如果有必要，再加上自动单元测试。</p><p>  总结：总结来说，一个好的架构的目的是，让前端写代码写的舒服，让后端联调的舒服，让产品经理改需求改的舒服。</p><h2 id="2、我如何设计架构"><a href="#2、我如何设计架构" class="headerlink" title="2、我如何设计架构"></a>2、我如何设计架构</h2><p> 我不敢说自己的架构是好的架构（显然不是啦），只能分享自己最近做的一个项目，它的架构的如何做的。</p><h3 id="首先，确定需求："><a href="#首先，确定需求：" class="headerlink" title="首先，确定需求："></a><strong>首先，确定需求：</strong></h3><p>  1、一个中小型网站，同时面向移动端和PC端（单端大概15个页面，算上弹窗大约20个）。2、预算有限（给的钱少），开发时间有限（一个月）。3、可能存在一定程度上的需求变更（比如增加页面或修改某些页面内容）。4、客户可能不太在乎优化（但是我自己在乎啊！）5、要求兼容IE9以上。</p><h3 id="其次开始决定："><a href="#其次开始决定：" class="headerlink" title="其次开始决定："></a><strong>其次开始决定：</strong></h3><p>  1、兼容IE9以上说明可以使用主流框架，而无需必须使用jquery。因此我采用了vue，版本是2.0；2、预算有限，时间有限，因此PC端和移动端共html和js，独立css。3、页面有限，因此无需将架构层级划分的比较细，只需要按其类型划分即可；4、根据原型图来看，页面复杂程度有限，复用部分不是很多，因此可以确定哪些东西需要封装复用，哪些比较复杂需要独立封装，哪些比较简单为了简化开发难度可以直接耦合。5、自己比较熟练单页面网站，因此采用以单页面为主，异步加载其他页面的形式。</p><p> 于是使用相关配套的东西，比如webpack，vue-router等，另外为了开发和生产的方便性，采用以下模式进行开发。</p><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011302243206212020113022.png"                      alt="image-20201130224320621"                ></p><hr><h3 id="第三，划分功能。"><a href="#第三，划分功能。" class="headerlink" title="第三，划分功能。"></a><strong>第三，划分功能。</strong></h3><p> 首先有一个根html，用户需要通过访问它来加载我们的js逻辑，因此js逻辑的代码被写在main.js之中。</p><p> 在main.js之下，我们的前端代码可以被划分为三部分：</p><ol><li>组件树；</li><li>功能模块；</li><li><p>各种资源；</p><p>如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011302243474002020113022.png"                      alt="image-20201130224347400"                ></p><p>功能划分好之后，相同功能的放在同一个文件夹下，命名风格应该类似。</p><p>具体来说，组件树相关的东西，通常是以.vue结尾，放置在components文件夹下；资源，有图片或者国际化资源等，以.png或者.js或.json结尾，放置在resources文件夹下；而功能插件、服务等，因为可能被多处引用，因此为了方便引用，放在src文件夹下，并且该文件夹是components文件夹和resources文件夹的上级文件夹；</p></li></ol><hr><h3 id="第四、细化功能模块"><a href="#第四、细化功能模块" class="headerlink" title="第四、细化功能模块"></a><strong>第四、细化功能模块</strong></h3><p> 功能、组件树以及资源，我们已经明确了有哪些东西，那么接下来，我们要明确这些东西该如何以文件的形式来划分。</p><p> 如下图：</p><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011302244049912020113022.png"                      alt="image-20201130224404991"                ></p><h3 id="1、项目构建相关"><a href="#1、项目构建相关" class="headerlink" title="1、项目构建相关"></a><strong>1、项目构建相关</strong></h3><p> 因为要使用vue.js，也要使用es6语法，因此<strong>babel</strong>是必须的；又因为要自动化混淆打包，因此<strong>webpack</strong>也是必须的；最后因为要方便多人协同，因此npm的<strong>package.json</strong>的配置，方便不同人可以快速自动化通过npm install来安装依赖，也是必须的；</p><h3 id="2、CDN相关"><a href="#2、CDN相关" class="headerlink" title="2、CDN相关"></a><strong>2、CDN相关</strong></h3><p> 而又因为我们要采用外部字体（需求要求引入非常见字体），因此<strong>CDN加速</strong>是必须的，该字体文件放在html中来配置引用即可；</p><h3 id="3、配置和插件"><a href="#3、配置和插件" class="headerlink" title="3、配置和插件"></a><strong>3、配置和插件</strong></h3><p> 我们需要直接引入一些插件和配置文件；为了使用vue，我们需要一个根组件，那么就是<strong>App.vue</strong>；使用vue-router，我们需要配置路由文件，因此<strong>router-config.js</strong>这个路由配置也是必须的；然后我们还需要以插件形式引入一些功能和服务，因此有了<strong>Plugin-开头的若干个vue插件</strong>，这些都是根据需要封装好的低耦合高内聚方法；</p><h3 id="4、需要的npm依赖"><a href="#4、需要的npm依赖" class="headerlink" title="4、需要的npm依赖"></a><strong>4、需要的npm依赖</strong></h3><p> 当然，要使用vue肯定要引入<strong>vue.js</strong>；类似的还有<strong>vue-router.js</strong>和各种兼容性<strong>polyfill</strong>和全局插件；</p><h3 id="5、抽离出的功能模块"><a href="#5、抽离出的功能模块" class="headerlink" title="5、抽离出的功能模块"></a><strong>5、抽离出的功能模块</strong></h3><p> 除了直接引用的这些插件，我们还有一些和项目高度耦合的功能服务，我认为不能作为插件，但依然需要抽离出来封装好，方便使用和修改；如封装ajax请求的<strong>ajax.js</strong>，所有的ajax请求都放置其中，只对外暴露接口，方便管理和使用；又如实时国际化功能的组件<strong>LanguageManager.js</strong>，他需要引入国际化资源和管理国际化资源的加载；又例如实现跨组件通信的<strong>event-bus.js</strong>又比如管理用户信息的<strong>user.js</strong></p><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a><strong>6、总结</strong></h3><p> 而这些划分，都体现在上图之中。这就是<strong>src目录下的功能模块文件</strong>，我们需要的绝大多数功能都可以包括在其中，我们只需要按照实际开发中的需要，将对应的功能写入在这些文件中并引用即可；</p><h3 id="第五、组件树"><a href="#第五、组件树" class="headerlink" title="第五、组件树"></a><strong>第五、组件树</strong></h3><p> 之前谈了功能模块的划分，接下来是组件树；</p><p> 因此是中小型页面，因此组件树的层级无需太深，但该抽离出来的依然还是要抽离，尽量保证抽离出来的组件解耦以及一个页面组件的逻辑不要太多；</p><p> 如下图：</p><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/SouthEast2020113022.png"                      alt="img"                ></p><h3 id="0、根组件"><a href="#0、根组件" class="headerlink" title="0、根组件"></a><strong>0、根组件</strong></h3><p> 所有组件最终往上找，都会找到共同的根组件App.vue，根组件只负责管理他的直接子组件；每个组件都只负责管理自己的直接子组件，不跨级管理，并且不依赖于自己的子组件（否则可能因为子组件的未加载或错误而导致父组件错误），做到解耦和内聚；</p><h3 id="1、弹窗dialog和弹窗tips"><a href="#1、弹窗dialog和弹窗tips" class="headerlink" title="1、弹窗dialog和弹窗tips"></a><strong>1、弹窗dialog和弹窗tips</strong></h3><p> 因为弹窗dialog和弹窗提示tips可能同时存在，因此将其划分为2个组件，方便管理；</p><h3 id="2、未登录页面和登录页面"><a href="#2、未登录页面和登录页面" class="headerlink" title="2、未登录页面和登录页面"></a><strong>2、未登录页面和登录页面</strong></h3><p> 因为页面存在登录和未登录状态，而为了加载速度考虑，当未登录时，不加载已登录页面，因此需要划分出来，并进行异步加载处理；</p><h3 id="3、未登录页面"><a href="#3、未登录页面" class="headerlink" title="3、未登录页面"></a><strong>3、未登录页面</strong></h3><p> 未登录页面又分为三种情况：1、初始页面：毫无疑问要直接加载2、登录弹窗：点击登录时加载（异步）3、注册弹窗：点击注册时加载（异步）之所以分拆开，是因为根据需求，已登录用户刷新页面，可以直接进入登录后页面，因此无需登录和注册，这种处理可以减少流量消耗，提升加载页面加载速度（特别是注册弹窗需要加载的内容还比较多）；</p><h3 id="4、已登录页面"><a href="#4、已登录页面" class="headerlink" title="4、已登录页面"></a><strong>4、已登录页面</strong></h3><p> 已登录页面有较多页面，采用默认加载初始页，然后异步加载其他页面（访问时）；</p><h3 id="5、弹窗dialog"><a href="#5、弹窗dialog" class="headerlink" title="5、弹窗dialog"></a><strong>5、弹窗dialog</strong></h3><p> 由于逻辑较少，代码量不多，因此为了方便管理，统一将其合并在一个vue文件中，共同相同的打开逻辑，根据传递的key决定打开哪一个。这样在新增弹窗时，无需再去写弹窗的打开、关闭逻辑。假如有较复杂的弹窗，可以以子组件的形式引入到当前vue文件中，如此也方便管理；</p><h3 id="6、国际化管理"><a href="#6、国际化管理" class="headerlink" title="6、国际化管理"></a><strong>6、国际化管理</strong></h3><p> 和页面高耦合，负责加载对应的国际化资源，并进行切换管理；</p><h3 id="7、页面组件"><a href="#7、页面组件" class="headerlink" title="7、页面组件"></a><strong>7、页面组件</strong></h3><p> 可能有子页面和复用的组件，按照正常方式引用即可。</p><h3 id="8、样式文件"><a href="#8、样式文件" class="headerlink" title="8、样式文件"></a><strong>8、样式文件</strong></h3><p> 可以独立写为.css文件，但因为我的公共样式文件比较少，因此我还是将其放在一个.vue文件中，并在App.vue里来引用</p><h3 id="8、页面组件起名"><a href="#8、页面组件起名" class="headerlink" title="8、页面组件起名"></a><strong>8、页面组件起名</strong></h3><p> 通常以.vue为结尾，除了国际化LanguageManager.js因为高耦合度，因此以.js结尾并是一个单独的vue实例，表示他更像是一个功能模块，而不是一个vue的页面组件；</p><p> 基础页面，如登录和未登录页面，<code>公共组件（并且是header和footer这种），以**base-**开头；弹窗统一以**box-**为开头;可复用的组件以**extend-**开头；引入的外部组件以**import-**开头</code>；<code>普通页面组件以**page-**开头</code>（这些页面往往是一个独立的页面，并且挂靠在登录或未登录页面下）；注册弹窗因为逻辑比较复杂，并且同类较多，因此以<strong>register-</strong>为开头；</p><p> 通过以文件名来划分，不同的页面组件之间的区分可以说是一目了然，同时也方便管理；</p><hr><h1 id="3、还没有谈到的内容"><a href="#3、还没有谈到的内容" class="headerlink" title="3、还没有谈到的内容"></a><strong>3、还没有谈到的内容</strong></h1><p> 想了想，目前还没有谈到的内容有以下几点：</p><p>  1、路由：以路由为驱动来写页面，似乎是一种不错的选择；好处是只需要通过查看路由的配置文件router-config.js，就可以了解页面组件的架构；不过我自己关于vue-router的实践经验比较少，因此就略过不谈了；</p><p>  2、单元测试：按道理说，单元测试是非常有必要的，因此在进行架构设计时，必须考虑到这一点；不过作者我目前在的公司关于前端方面都不太正规，实在没这方面的经验，又因为作者我本人转行做前端的时间也比较短，虽然周周9.12.7，但也没来得及学习这方面的知识（没有需求驱动，这方面动力不足哈哈）</p><p>  3、自动化配置：关于webpack的自动化，是前端架构的重要组成部分，因此配置也是蛮重要的；不过一是这方面需要很多笔墨的，二是网上也有一些别人分享的文章（肯定比我的好），所以我这里就不细说了；</p><p>  4、一些自动化工具：依然尴尬，没有大厂经验，路子比较野，所以大厂专有的一些工具是木有的，而自己找的话又嫌麻烦，所以没有优化到极致，只做到了基本满足目前项目需求的程度，见谅见谅；等以后有这方面经验的话我再写博客来分享吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、为什么要有一个好的架构&quot;&gt;&lt;a href=&quot;#1、为什么要有一个好的架构&quot; class=&quot;headerlink&quot; title=&quot;1、为什么要有一个好的架构&quot;&gt;&lt;/a&gt;1、为什么要有一个好的架构&lt;/h2&gt;&lt;p&gt; 首先明确一点，&lt;code&gt;架构是为需求服务的&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务器数据被黑 😂</title>
    <link href="http://mariogogogo.github.io/2020/09/16/%E6%95%B0%E6%8D%AEMoogose%E8%A2%AB%E9%BB%91/"/>
    <id>http://mariogogogo.github.io/2020/09/16/数据Moogose被黑/</id>
    <published>2020-09-16T07:13:48.000Z</published>
    <updated>2021-02-18T06:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>幸亏这次丢失的数据不多，也只是自己个人的测试数据，如果是公司的商用数据库数据，那被勒索多少 BTC 也得给啊 😁</p><a id="more"></a><h2 id="服务器又一次被恶意攻击，MongoDB-被删库"><a href="#服务器又一次被恶意攻击，MongoDB-被删库" class="headerlink" title="服务器又一次被恶意攻击，MongoDB 被删库"></a>服务器又一次被恶意攻击，MongoDB 被删库</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/uPic/2020%2009%2016%2016%2028%2027%201600244907.png"                      alt="image-20200915164254240"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/uPic/2020%2009%2016%2016%2028%2022%201600244902.png"                      alt="image-20200915164549369"                ></p><h2 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mongo --version</span><br><span class="line">MongoDB shell version v4<span class="number">.0</span><span class="number">.6</span></span><br><span class="line">git version: caa42a1f75a56c7643d0b68d3880444375ec42e3</span><br><span class="line">OpenSSL version: OpenSSL <span class="number">1.0</span><span class="number">.1f</span> <span class="number">6</span> Jan <span class="number">2014</span></span><br><span class="line">allocator: tcmalloc</span><br><span class="line">modules: none</span><br><span class="line">build environment:</span><br><span class="line">    distmod: ubuntu1404</span><br><span class="line">    distarch: x86_64</span><br><span class="line">    target_arch: x86_64</span><br></pre></td></tr></table></figure><h2 id="重新卸载"><a href="#重新卸载" class="headerlink" title="重新卸载"></a>重新卸载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">停止服务：</span><br><span class="line">sudo service mongod stop</span><br><span class="line">删除软件包：</span><br><span class="line">sudo yum erase $(rpm -qa | grep mongodb-org)</span><br><span class="line"> 删除数据和日志目录：</span><br><span class="line">sudo rm -r /<span class="keyword">var</span>/log/mongodb（日志）</span><br><span class="line">sudo rm -r /<span class="keyword">var</span>/lib/mongo（数据）</span><br></pre></td></tr></table></figure><h2 id="安装重启服务"><a href="#安装重启服务" class="headerlink" title="安装重启服务"></a>安装重启服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">sudo apt-get install -y mongodb-org</span><br><span class="line"></span><br><span class="line"># 开启服务</span><br><span class="line">sudo service mongod start</span><br><span class="line"></span><br><span class="line"># 停止服务</span><br><span class="line">sudo service mognod stop</span><br><span class="line"></span><br><span class="line"># 重启服务</span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo;</span><br></pre></td></tr></table></figure><h2 id="配置文件信息"><a href="#配置文件信息" class="headerlink" title="配置文件信息"></a>配置文件信息</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dbPath</span>=。。。 <span class="comment">#数据文件存放目录</span></span><br><span class="line"><span class="attr">path</span>=。。。 <span class="comment">#日志文件存放目录</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">27017</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span> <span class="comment">#以守护程序的方式启用,即在后台运行</span></span><br><span class="line"><span class="attr">logappend</span> = <span class="literal">true</span> <span class="comment">#日志以追加的形式添加</span></span><br><span class="line"><span class="attr">bind_ip</span> = <span class="number">0.0</span>.<span class="number">0.0</span> <span class="comment">#可以访问的地址. 127.0.0.1表示自己访问, 0.0.0.0 表示所有人都能访问</span></span><br></pre></td></tr></table></figure><h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">修改etc/mongod.conf文件内的配置信息</span><br><span class="line">net:</span><br><span class="line">  port: <span class="number">12345</span> <span class="comment">//端口号</span></span><br><span class="line">  bindIp: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,<span class="number">1</span>**<span class="number">.16</span>*<span class="number">.1</span>**<span class="number">.18</span>   <span class="comment">//内网</span></span><br><span class="line"></span><br><span class="line">  # 重启服务</span><br><span class="line">sudo service mongod restart</span><br><span class="line">提示</span><br><span class="line">mongod stop/waiting</span><br><span class="line">mongod start/running, process <span class="number">19206</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接MongoDB并指定端口</span></span><br><span class="line">mongo <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>:<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="限制端口访问"><a href="#限制端口访问" class="headerlink" title="限制端口访问"></a>限制端口访问</h2><p>想要实现：</p><p>限制外网访问 mongo，只允许特定的 IP 进来访问 mongo 的话，则：</p><p>Mongo 的配置中，是无法实现这个效果的。</p><p>只能换用其他办法，比如：</p><p>通过设置防火墙，添加：</p><p>只允许某些 IP，入网方向，能够访问 mongo 的对应的端口</p><p>从而禁止掉其他的 IP 访问 mongo</p><p>而此处的阿里云的 ECS 服务器中，可以通过设置安全组，实现和防火墙一样的效果。</p><p>具体设置办法：</p><p>进去阿里云控制后台-》云服务器 ECS-》安全组-〉你的 ECS 服务器所在的区域-》对应的 ECS 服务器-〉配置规则：</p><p>增加 2 个规则：</p><p>（1）规则 1： 允许特定的 IP（单个 IP，某个 IP 地址段（内的所有的 IP），某几个 IP）允许访问某端口</p><p>（2）规则 2：禁止掉，其他的 IP 访问该端口</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/uPic/2020%2009%2016%2016%2028%2003%201600244883.png"                      alt="image-20200916131318130"                ></p><h2 id="配置管理员账号"><a href="#配置管理员账号" class="headerlink" title="配置管理员账号"></a>配置管理员账号</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 切换到 admin 数据库</span><br><span class="line">use admin</span><br><span class="line"></span><br><span class="line"># 创建用户</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">&#x27;tanya&#x27;</span>, <span class="attr">pwd</span>: <span class="string">&#x27;tanya&#x27;</span>, <span class="attr">roles</span>: [&#123;<span class="attr">role</span>: <span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, <span class="attr">db</span>: <span class="string">&#x27;admin&#x27;</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"># 授权</span><br><span class="line">db.auth(<span class="string">&#x27;tanya&#x27;</span>, <span class="string">&#x27;tanya&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 切换到其他数据库</span><br><span class="line">use dream-wall</span><br><span class="line"></span><br><span class="line"># 创建用户</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">&#x27;tanya_dream-wall_runner&#x27;</span>, <span class="attr">pwd</span>: <span class="string">&#x27;tanya&#x27;</span>, <span class="attr">roles</span>: [&#123;<span class="attr">role</span>: <span class="string">&#x27;readWrite&#x27;</span>, <span class="attr">db</span>: <span class="string">&#x27;dream-wall&#x27;</span>&#125;]&#125;)</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">&#x27;tanya_dream-wall_wheel&#x27;</span>, <span class="attr">pwd</span>: <span class="string">&#x27;tanya&#x27;</span>, <span class="attr">roles</span>: [&#123;<span class="attr">role</span>: <span class="string">&#x27;read&#x27;</span>, <span class="attr">db</span>: <span class="string">&#x27;dream-wall&#x27;</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"># 修改配置，开启授权</span><br><span class="line">sudo vi /etc/mongod.conf</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  authorization: <span class="string">&#x27;enabled&#x27;</span></span><br><span class="line"></span><br><span class="line"># 重启 mongo 服务，使配置生效</span><br><span class="line">sudo service mongod restart</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：每次要进行数据库操作都需要先进行授权 db.auth(‘tanya’, ‘tanya’)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 登录到指定数据库，无需授权</span><br><span class="line">mongo <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:xx/dream-wall -u tanya_dream-wall_runner -p tanya</span><br><span class="line"></span><br><span class="line"># 验证一下</span><br><span class="line">show tables</span><br><span class="line">db.dreams.find()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="安全事故猛于虎"><a href="#安全事故猛于虎" class="headerlink" title="安全事故猛于虎"></a>安全事故猛于虎</h4><p>这里给再次给自己也给大家提个醒，安全事故猛于虎，安全责任重于山。</p><ul><li>一定不要为了图方便，就忽略某些安全配置，平时做什么都要有安全意识。</li><li>重要数据及时备份。</li><li>服务器设置 IP 黑白名单，关闭一切可以关闭的端口</li><li>如果跟我似的，访问服务的 ip 经常变，可以考虑修改一些服务的默认端口，增加被扫到的概率</li><li>一定要设置密码，为了防止被爆，最好是无规则的强密码</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://blog.csdn.net/dandanfengyun/article/details/95497728" >https://blog.csdn.net/dandanfengyun/article/details/95497728<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.crifan.com/mongodb_add_restrict_ip_access/" >https://www.crifan.com/mongodb_add_restrict_ip_access/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.bbsmax.com/A/x9J238pM56/" >https://www.bbsmax.com/A/x9J238pM56/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/savoygu/blog/blob/master/博客/Node.js项目线上服务器部署与发布/Node.js项目线上服务器部署与发布.md#52-修改-mongodb-默认端口" >https://github.com/savoygu/blog/blob/master/博客/Node.js项目线上服务器部署与发布/Node.js项目线上服务器部署与发布.md#52-修改-mongodb-默认端口<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;幸亏这次丢失的数据不多，也只是自己个人的测试数据，如果是公司的商用数据库数据，那被勒索多少 BTC 也得给啊 😁&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJs" scheme="http://mariogogogo.github.io/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://mariogogogo.github.io/tags/NodeJs/"/>
    
      <category term="基础" scheme="http://mariogogogo.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://mariogogogo.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端自动化部署之Shell</title>
    <link href="http://mariogogogo.github.io/2020/06/01/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B9%8BShell/"/>
    <id>http://mariogogogo.github.io/2020/06/01/前端自动化部署之Shell/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-12-08T07:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知前端是一个不善言辞并不会使用cmd的的一类人，开个玩笑！！！</p><a id="more"></a><h1 id="前端项目发布流程"><a href="#前端项目发布流程" class="headerlink" title="前端项目发布流程"></a><strong>前端项目发布流程</strong></h1><ul><li>开发新功能啦 -&gt; 切新分支 <code>git ck -b newBranch</code></li><li>开发完成后 -&gt; 提交代码 <code>git add .</code> <code>git commit -m &#39;msg&#39;</code></li><li>合并到内外侧分支 -&gt; 合并到 <code>Rel</code> 内外侧分支 <code>git marge rel</code></li><li>就拿 <code>Vue</code> <code>React</code> 项目来说，发布测试之前我们还需要将之前生产的代码给删除，不然体积会越来越大 <code>rm -rf /linux目录路径~当前项目/*</code></li><li>发布内外侧（还有个预发布），<code>build - FileZilla | ZOC7 - 上传</code> 不管你是拖拽，还是linux命令都可以，开心就好嘛</li></ul><p>上面就是发布一个新功能的流程，可想而知，你让我一天做一次还能接受，要是隔几分钟来一次谁受得了？当然现实就是这样的操作隔几分钟就会来一次！！！并且同时改几个项目也是存在的，所以，这种操作要把人整神…</p><h2 id="说个故事"><a href="#说个故事" class="headerlink" title="说个故事"></a>说个故事</h2><p>有一天我开发了一个功能，按照上面流程把代码发布到了内外侧，这时候测试姐姐测试了，发现我把<strong>登录写成登陆</strong>了，通知到我，你有一个超级严重的bug，需要现在改，改好就传，我收到这条指令，菊花不由得一紧，我当机立断切换分支，改起我的代码来，时间一分一秒过去，在一分钟的时间内我就改完bug，毕竟拧螺丝非常简单。</p><p>该上传代码了，上传操作用了我10分钟，在测试姐姐看来，我修改这个代码用了11分钟，测试姐姐心里肯定就在想这个菜逼，改个字要这么久？我等着这么烦，后面给他打分往低了打，哼~~，让某某前端崽儿拿不到奖金。</p><p>我也很无奈啊！！！</p><h2 id="Shell神器"><a href="#Shell神器" class="headerlink" title="Shell神器"></a>Shell神器</h2><p>其实有很多后端在用的东西，前端都能拿来减少自己平时开发的重复工作，Shell就是其中一种。</p><p>关于Shell知识的话，很多教程啦，去学习吧，我把我的脚本拿出来和大家交流交流。</p><h2 id="我的自动化脚本"><a href="#我的自动化脚本" class="headerlink" title="我的自动化脚本"></a>我的自动化脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 在&quot;set -e&quot;之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出，那么就可以避免一些脚本的危险操作。</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;shell脚本本身的名字: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;传给shell的第一个参数: <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;传给shell的第二个参数: <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="comment">#获取当前分支</span></span><br><span class="line">branch=$(git symbolic-ref --short HEAD)</span><br><span class="line"><span class="comment">#获取当前分支完整路径</span></span><br><span class="line"><span class="built_in">echo</span> -e $(git symbolic-ref HEAD)</span><br><span class="line"><span class="comment"># refs/heads/master</span></span><br><span class="line"><span class="built_in">echo</span> -e $(git symbolic-ref --short HEAD)</span><br><span class="line"><span class="comment"># master</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x != <span class="string">&quot;devx&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x != <span class="string">&quot;testx&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x != <span class="string">&quot;prex&quot;</span> ]&amp;&amp; [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> != <span class="string">&quot;master&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[41;37m 不存在 <span class="variable">$1</span> 环境  只有 -&gt; dev(内测) test(外侧) pre(预发布) \\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 链接服务器</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">devFn</span></span>() &#123;</span><br><span class="line">    ssh -p 22 root@120.27.2x0.xxx rm -rf /home/chan/koa2/*</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 连接成功，开始上传代码....... \\033[0m&quot;</span></span><br><span class="line">    <span class="comment">#rsync 三种模式：本地模式、ssh 模式、rsync 模式。</span></span><br><span class="line">    <span class="comment">#rsync -e &quot;ssh -p 1876&quot;  --exclude=storage -a  /Users/lovewcc/Documents/04_Vue/easy-vue/dist/*      root@120.27.220.173:/home/chan/koa2/</span></span><br><span class="line">    rsync -avz -e ssh /Users/lovewcc/Documents/04_Vue/easy-vue/dist/* root@120.27.220.173:/home/chan/koa2/</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 上传成功,预览试试吧 \\033[0m\\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">testFn</span></span>() &#123;</span><br><span class="line">    ssh -p 端口 root@ip rm -rf 服务器项目路径/*</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 连接成功，上传代码中... \\033[0m&quot;</span></span><br><span class="line"></span><br><span class="line">    rsync -e <span class="string">&quot;ssh -p 873&quot;</span>  --exclude=storage -a  本地代码路径/dist/*      root@ip:服务器项目路径/</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 外侧上传成功 \\033[0m\\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">preFn</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;执行链接预发布服务器&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">build</span></span>() &#123;</span><br><span class="line">    <span class="comment"># cd source</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;master&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m&quot;</span><span class="variable">$1</span><span class="string">&quot;支打包开始 \\033[0m&quot;</span></span><br><span class="line">          yarn run build</span><br><span class="line">    <span class="keyword">else</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x == <span class="string">&quot;testx&quot;</span> ]</span><br><span class="line">          yarn run build:<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 打包完毕 \\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 连接 <span class="variable">$1</span> 服务器 \\033[0m&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;master&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        devFn</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x == <span class="string">&quot;devx&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        devFn</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x == <span class="string">&quot;testx&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        testFn</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span>x == <span class="string">&quot;prex&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        preFn</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\\033[41;37m 应该不会走到这里来吧... \\033[0m&quot;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是否是rel分支</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;branch&#125;</span> == <span class="string">&quot;master&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 当前在rel分支\\n 不出意外应该刚发布过内测\\n 所以无需执行git操作\\n 所以是否直接发布 <span class="variable">$1</span> 环境\\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">read</span> -p $<span class="string">&#x27;\\n\\033[31m是否直接打包上传？y or n: \\033[0m&#x27;</span> isbuild</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isbuild</span>&quot;</span> != <span class="string">&#x27;y&#x27;</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    build <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#此sh脚本只适用于单子发布rel环境,提醒</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[31m dev(内测) test(外侧) pre(预发布) \\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[31m 当前需要发布 <span class="variable">$1</span> 环境 \\033[0m&quot;</span></span><br><span class="line">    <span class="comment">#询问是否继续发布当前环境</span></span><br><span class="line">    <span class="built_in">read</span> -p $<span class="string">&#x27;\\n\\033[31m是否继续操作？y or n: \\033[0m&#x27;</span> isVersion</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isVersion</span>&quot;</span> != <span class="string">&#x27;y&#x27;</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 已确认环境 \\033[0m\\n&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[31m <span class="variable">$1</span> 环境，当前分支为： <span class="variable">$&#123;branch&#125;</span> \\033[0m&quot;</span></span><br><span class="line">    <span class="comment">#确认当前分支，是否继续</span></span><br><span class="line">    <span class="built_in">read</span> -p $<span class="string">&#x27;\\n\\033[31m请确认分支，是否继续操作？y or n: \\033[0m&#x27;</span> isContinue</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isContinue</span>&quot;</span> != <span class="string">&#x27;y&#x27;</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 已确认分支，分支为 -&gt; <span class="variable">$&#123;branch&#125;</span> \\033[0m\\n&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 开始提交 <span class="variable">$&#123;branch&#125;</span> 分支代码，执行 add commit  \\033[0m\\n&quot;</span></span><br><span class="line">    git add .</span><br><span class="line">    <span class="built_in">read</span> -p $<span class="string">&#x27;\\n\\033[31m请输入本次commit信息：\\033[0m&#x27;</span> commitInfo</span><br><span class="line">    git commit -m <span class="variable">$&#123;commitInfo&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 开始切换分支 \\033[0m\\n&quot;</span></span><br><span class="line">    git checkout rel</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 开始拉取 rel origin \\033[0m\\n&quot;</span></span><br><span class="line">    git pull origin rel</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m 开始 merge 修改至 rel \\033[0m\\n&quot;</span></span><br><span class="line">    git merge <span class="variable">$&#123;branch&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断merge是否成功</span></span><br><span class="line">    <span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\\033[32m merge <span class="variable">$&#123;branch&#125;</span> -&gt; rel 成功 \\033[0m\\n&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 开始推送 rel 至远端 origin \\033[0m\\n&quot;</span></span><br><span class="line"></span><br><span class="line">        git push origin rel</span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 推送 rel 至远端 origin 成功 \\033[0m\\n&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\\n\\033[32m 执行打包 \\033[0m\\n&quot;</span></span><br><span class="line"></span><br><span class="line">        build <span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e  <span class="string">&quot;\\033[31m merge失败，请检查 \\033[0m&quot;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shell.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知前端是一个不善言辞并不会使用cmd的的一类人，开个玩笑！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://mariogogogo.github.io/categories/Web/"/>
    
    
      <category term="Javascript" scheme="http://mariogogogo.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue中设置页面切换时的过渡动画</title>
    <link href="http://mariogogogo.github.io/2020/04/15/vue%E4%B8%AD%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E6%97%B6%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    <id>http://mariogogogo.github.io/2020/04/15/vue中设置页面切换时的过渡动画/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-12-09T07:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中设置页面切换时的过渡动画"><a href="#vue中设置页面切换时的过渡动画" class="headerlink" title="vue中设置页面切换时的过渡动画"></a>vue中设置页面切换时的过渡动画</h1><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 页面切换动画transitionName --&gt;</span><br><span class="line">    &lt;transition :name=<span class="string">&quot;transitionName&quot;</span>&gt;</span><br><span class="line">      &lt;!-- 缓存数据 &lt;router-view&gt; --&gt;</span><br><span class="line">      &lt;keep-alive&gt;</span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/keep-alive&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">    &lt;transition :name=<span class="string">&quot;transitionName&quot;</span>&gt;</span><br><span class="line">      &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      transitionName: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.body.scrollHeight &gt;= <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">      <span class="built_in">document</span>.body.style.height = <span class="built_in">document</span>.body.scrollHeight + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.body.style.height = <span class="built_in">document</span>.documentElement.clientHeight + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 页面切换动画 */</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">//使用watch 监听$router的变化</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">//console.log(&quot;to=&quot; + to.meta.index, &quot;from=&quot; + from.meta.index);</span></span><br><span class="line">      <span class="comment">//(1) 如果to的索引值为0，不添加任何动画；如果to索引大于from索引,判断为前进状态,反之则为后退状态</span></span><br><span class="line">      <span class="keyword">if</span> (to.meta.index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to.meta.index &lt; <span class="keyword">from</span>.meta.index) &#123;</span><br><span class="line">          <span class="built_in">this</span>.transitionName = <span class="string">&quot;slide-right&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.transitionName = <span class="string">&quot;slide-left&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (to.meta.index == <span class="number">0</span> &amp;&amp; <span class="keyword">from</span>.meta.index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.transitionName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//(2) 当然，如果你没有需要设置索引值为0的页面可以直接用着一段</span></span><br><span class="line">      <span class="comment">// if (to.meta.index &lt; from.meta.index) &#123;</span></span><br><span class="line">      <span class="comment">//   this.transitionName = &quot;slide-right&quot;;</span></span><br><span class="line">      <span class="comment">// &#125; else &#123;</span></span><br><span class="line">      <span class="comment">//   this.transitionName = &quot;slide-left&quot;;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">  height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#app &#123;</span><br><span class="line">  height: <span class="number">100</span>%;</span><br><span class="line">  width: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/********页面切换动画 *********/</span></span><br><span class="line">.slide-right-enter-active,</span><br><span class="line">.slide-right-leave-active,</span><br><span class="line">.slide-left-enter-active,</span><br><span class="line">.slide-left-leave-active &#123;</span><br><span class="line">  <span class="comment">/* will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置 */</span></span><br><span class="line">  will-change: transform;</span><br><span class="line">  transition: all ease <span class="number">0.</span>4s;</span><br><span class="line">  -webkit-transition: all ease <span class="number">0.</span>4s;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: <span class="number">100</span>%;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-enter &#123;</span><br><span class="line">  transform: translateX(-<span class="number">100</span>%);</span><br><span class="line">  -webkit-transform: translateX(-<span class="number">100</span>%);</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-leave-active &#123;</span><br><span class="line">  transform: translateX(<span class="number">100</span>%);</span><br><span class="line">  -webkit-transform: translateX(<span class="number">100</span>%);</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-enter &#123;</span><br><span class="line">  transform: translateX(<span class="number">100</span>%);</span><br><span class="line">  -webkit-transform: translateX(<span class="number">100</span>%);</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-leave-active &#123;</span><br><span class="line">  transform: translateX(-<span class="number">100</span>%);</span><br><span class="line">  -webkit-transform: translateX(-<span class="number">100</span>%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********页面切换动画 *********/</span></span><br><span class="line">...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202011281723430302020112915.png"                      alt="image-20201128172343030" style="zoom:50%;"                 ></p><p>有个bug如果子页面没有高度，进入子页面再返回底部导航会有抖动bug</p><p>比如</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%8A%96%E5%8A%A82020112915.gif"                      alt="底部导航抖动" style="zoom: 50%;"                 ></p><p>加上一定高度后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.promise</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/2020-11-28%2016.32.422020112915.gif"                      alt="2020-11-28 16.32.42" style="zoom: 50%;"                 ></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vue中设置页面切换时的过渡动画&quot;&gt;&lt;a href=&quot;#vue中设置页面切换时的过渡动画&quot; class=&quot;headerlink&quot; title=&quot;vue中设置页面切换时的过渡动画&quot;&gt;&lt;/a&gt;vue中设置页面切换时的过渡动画&lt;/h1&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue阅读源码准备了什么</title>
    <link href="http://mariogogogo.github.io/2020/03/15/Vue%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E5%87%86%E5%A4%87%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://mariogogogo.github.io/2020/03/15/Vue阅读源码准备了什么/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-12-12T03:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、掌握-Vue-所有API"><a href="#1、掌握-Vue-所有API" class="headerlink" title="1、掌握 Vue 所有API"></a>1、掌握 Vue 所有API</h2><p>​    我把 Vue 的所有 API 都详细研究使用过了一遍，而且尽量在项目中都有使用，让自己有深一点的体会</p><p>​    而且我对着官方文档，一个个做了详细的笔记，而且联想过了使用场景。</p><a id="more"></a><h2 id="2、JavaScript-扎实基础"><a href="#2、JavaScript-扎实基础" class="headerlink" title="2、JavaScript 扎实基础"></a>2、JavaScript 扎实基础</h2><p>​    幸好自己之前花了大力气去给自己打基础，让自己现在的 JavaScript 基础还算不错。</p><p>逼着自己把很多本 JavaScript 书都看完了，并且做了详细笔记。像是【 JavaScript易维护】【JavaScript性能 】，【JavaScript 高级程序设计】【巴菲特给股东的信】看了两遍，说不上精通，也算是还可以？</p><h2 id="3、看完-JavaScript-设计模式"><a href="#3、看完-JavaScript-设计模式" class="headerlink" title="3、看完 JavaScript 设计模式"></a>3、看完 JavaScript 设计模式</h2><p>​    光是 JavaScript 设计模式 这本书 我就看了一年半，不能说自己把所有设计模式都掌握了，掌握了大部分吧，设计模式港真真的很有趣，不然我也不会决心学</p><p>​    在这里推荐 张容铭的 【JavaScript设计模式】，书讲得非常透彻和详细，我是从完全不懂开始看的</p><p>​    也经常使用一部分，我一直以设计模式为我的项目基构。就是 能用设计模式的地方，我都尽量使用设计模式。</p><p>​    设计模式看起来就像是 剑客 的剑谱，有招有式，连人家武侠剧发功的时候都知道 喊出 招式的名字… 降龙十八掌！！！！</p><p>​    野路子难登大雅之堂，主要是不好看啊，代码为了好维护，易扩展</p><h2 id="4、学会调试"><a href="#4、学会调试" class="headerlink" title="4、学会调试"></a>4、学会调试</h2><p>​    我很大胆地说，如果你不会调试，你看 Vue 源码，或者你会想死，你会出现这个场景…</p><blockquote><p>MMP，这个方法是怎么跳到 那个方法的，那个方法和 这个方法又是怎么联系起来的？</p></blockquote><p>​    也许你可以慢慢 使用 函数名字 去寻找，但是无疑你会多消耗几倍时间，而且你会更烦</p><p>​    使用调试真的方便，以前我也真的不喜欢调试，觉得好像很难？？？</p><p>​    更喜欢使用 console.log 去打印信息…..</p><p>​    是啊，我自己写项目的时候，我还是会使用 console.log 去调试…….</p><p>​    那是因为我自己代码，我知道怎么跑，你 看别人的代码，还是超级抽象的框架，使用 console.log 的方式…..</p><p>​    放心，相信我，你会掉很多头发………</p><p>​    这里，我使用的是 VSCode 去调试，真的简单又方便，我当时也真的很难去让自己又要学一个东西</p><p>​    但是我咬咬牙，我还是学了，感谢自己……</p><p>​    我可以保证，你从不懂到掌握，只要不到十分钟，简直就是 现实版的 十分钟精通到入门</p><p>​    好吧，下面开始说，Vue 的简单总结。</p><p><strong>Vue 源码的简短的总结</strong></p><h3 id="1、封装了很多常用的函数！"><a href="#1、封装了很多常用的函数！" class="headerlink" title="1、封装了很多常用的函数！"></a>1、封装了很多常用的函数！</h3><p>为了 复用 且 易维护</p><p>常用的类型判断、 类型转换 、数据格式转换（数组转对象）…..</p><p>举些例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;    <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndef</span>(<span class="params">v</span>) </span>&#123;    <span class="keyword">return</span> v === <span class="literal">undefined</span> || v === <span class="literal">null</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDef</span>(<span class="params">v</span>) </span>&#123;    <span class="keyword">return</span> v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params">val</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> val == <span class="literal">null</span> ?    <span class="string">&#x27;&#x27;</span> :    </span><br><span class="line">    <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ?    </span><br><span class="line">    <span class="built_in">JSON</span>.stringify(val, <span class="literal">null</span>, <span class="number">2</span>) :    <span class="built_in">String</span>(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toObject</span>(<span class="params">arr</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">            extend(res, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>​    你说说不定过了几年，判断是否是一个对象，不再是 什么 typeof obj==”object”</p><p>​    如果没有封装，那岂不是所有代码涉及到的都要改一遍，且不说如果有很多个都变了…..那你就头大了</p><h3 id="节点操作兼容函数"><a href="#节点操作兼容函数" class="headerlink" title="节点操作兼容函数"></a>节点操作兼容函数</h3><p>addClass ,removeClass，createElement，appendChild，removeChild </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">el, cls</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!cls || !(cls = cls.trim())) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (el.classList) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (cls.indexOf(<span class="string">&#x27; &#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            cls.split(<span class="regexp">/\s+/</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123; <span class="keyword">return</span> el.classList.add(c); &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.classList.add(cls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">       <span class="keyword">var</span> cur = <span class="string">&quot; &quot;</span> + (el.getAttribute(<span class="string">&#x27;class&#x27;</span>) || <span class="string">&#x27;&#x27;</span>) + <span class="string">&quot; &quot;</span>;        </span><br><span class="line">       <span class="keyword">if</span> (cur.indexOf(<span class="string">&#x27; &#x27;</span> + cls + <span class="string">&#x27; &#x27;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            el.setAttribute(<span class="string">&#x27;class&#x27;</span>, (cur + cls).trim());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这些函数都很有用，所以我都记下来了，毕竟是 框架封装的，肯定是最完善的</p><h3 id="2、真的用了很多设计模式"><a href="#2、真的用了很多设计模式" class="headerlink" title="2、真的用了很多设计模式"></a>2、真的用了很多设计模式</h3><p>就我看到的设计模式就有</p><p> Vue涉及的设计模式观察者模式、状态模式、节流模式、参与者模式、备忘录模式、单例模式装饰者模式、组合继承模式、链模式………</p><p>我怀疑 Vue 把所有的设计模式都用完了…. 真的….. 如果你不懂设计模式</p><p>你真不会领悟到他这么写的精髓</p><p>我就选 Vue 常用的一个设计模式来讲</p><p>【参与者模式】</p><p>Vue 封装的很多函数都是用了 参与者模式，也可以叫做柯里化</p><p>先来简单解释下 参与者模式</p><p>1、保存第一次调用 传入参数</p><p>2、返回定制函数，函数内使用 参数</p><blockquote><p><a class="link"   href="https://blog.csdn.net/Forever201295/article/details/104032369" >https://blog.csdn.net/Forever201295/article/details/104032369<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>简单实现像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123; <span class="keyword">return</span> a+b &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了定制函数，把第一次调用时的参数闭包保存</span></span><br><span class="line">add5 = add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> result  = add5(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>看一下 Vue其中一个 使用柯里化 的封装函数</p><p><strong>makeMap</strong></p><p>创建 对象 map，返回函数，用于后面查找 某个东西是否存在 map 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params"> str,  expectsLowerCase </span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);   </span><br><span class="line">    <span class="keyword">var</span> list = str.split(<span class="string">&#x27;,&#x27;</span>);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        map[list[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> expectsLowerCase ?        </span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> map[val.toLowerCase()]; &#125; :        </span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> map[val]; &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"><span class="keyword">var</span> isUnaryTag = makeMap(   </span><br><span class="line"> <span class="string">&#x27;area,base,br,col,embed,frame,hr,img,input,isindex,keygen,&#x27;</span> +  </span><br><span class="line"> <span class="string">&#x27;link,meta,param,source,track,wbr&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找 area 标签是否存在 上面保存过的 字符串中</span></span><br><span class="line">isUnaryTag(<span class="string">&#x27;area&#x27;</span>)</span><br></pre></td></tr></table></figure><p>**3、使用很多闭包！</p><p>据我看过的地方</p><p>1、解析组件模板 使用了闭包作为缓存，为了重复解析</p><p>2、cached 函数，一个专门使用闭包 为缓存的函数</p><p>3、上面所讲到 的 柯里化所有涉及的函数，makeMap,parthPath,</p><p>4、createPatchFunction 当属篇幅最大的使用闭包的函数了，把一堆函数作为闭包，然后返回 一个函数。他最大的作用是 比较更新DOM 节点</p><p><strong>4、使用很多标志位</strong></p><p>Vue 常用标志位来</p><p><strong>1、表明是否已经做了某件事</strong></p><p> _isMounted：dom 是否已经挂载</p><p>_isDestroyed ：组件是否已经摧毁</p><p>pending：表明更新回调的 setTimeout 已经执行</p><p>waiting：是否已经初始化更新队列，在等待新的成员进入对垒</p><p>flushing：更新队列是否已经开始逐个更新成员</p><p>……</p><p><strong>2、指明当前东西的身份</strong></p><p>isStatic：是否是静态节点</p><p>isComment：是否是注释节点</p><p>isCloned：是否是克隆节点</p><p>isOnce：是否有v-once 指令（如果有当前指令，会跳过编译）</p><p>_isComponent：是否是组件</p><p>…..</p><p>​    多用标志位，控制流程，替代多余的判断（直接判断标志位来确认身份，不用做太多的判断），减少开销</p><p>​    上面那些变量，大家没看源码，可能有些懵逼，没关系，就当先知道有这个东西就好了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://typora.pp.52react.cn/fuckb/image-202012121140537732020121211.png"                      alt="image-20201212114053773"                ></p><h2 id="Vue-源码分几步走"><a href="#Vue-源码分几步走" class="headerlink" title="Vue 源码分几步走"></a>Vue 源码分几步走</h2><p>我给自己定的任务是 分为两个部分</p><p><strong>Vue 的主体内容</strong></p><p>1、Vue初始化初始化原理</p><p>2、render渲染机制 </p><p>3、依赖收集 </p><p>4、依赖更新</p><p>5、Virtual DOM ，dom 节点 生成虚拟Vnode 节点</p><p>6、Diff、Patch， 节点比较更新</p><p>7、Compile， 模板编译</p><p>8、NextTick ，延迟执行回调</p><p>9、LifeCircle ，生命周期</p><p>10、Model ，双向绑定</p><p>11、Event ，事件机制</p><p><strong>Vue 组件选项</strong></p><p>1、computed</p><p>2、filter</p><p>3、mixin</p><p>4、directive</p><p>5、slot</p><p>6、props</p><p>7、watch</p><p>​    我就大约以这些为我的学习目标进行 源码阅读的，每一块都是一个非常大的内容，每一块内容都不是几天能看完的，有时候还需要一点灵感。当然还有很多内容，但是我的目标也并不是全部，一字不漏读完，我要的是他的精髓即可，或许等我掌握了这些，再去开发其他的内容，这样或许更简单</p><p>​    反正我始终提醒自己不要焦躁，因为这个东西真的是急不来，长期以往，不要妄想一步登天，一开始总会很难，但是久了也一样很难，哈哈哈哈哈</p><p>​    如果你有兴趣也读源码，我们可以一起讨论学习….</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://mmbiz.qpic.cn/mmbiz_jpg/HCyqJSXNAiaRKWRsWg3Muds9Z1oZORoMTy7z0N25rrNAbxhmqd6wpaicib4gtYUoN9hYxicxQlSzZyicMgDEDQaIppQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1"                      alt="img" style="zoom: 25%;"                 ></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、掌握-Vue-所有API&quot;&gt;&lt;a href=&quot;#1、掌握-Vue-所有API&quot; class=&quot;headerlink&quot; title=&quot;1、掌握 Vue 所有API&quot;&gt;&lt;/a&gt;1、掌握 Vue 所有API&lt;/h2&gt;&lt;p&gt;​    我把 Vue 的所有 API 都详细研究使用过了一遍，而且尽量在项目中都有使用，让自己有深一点的体会&lt;/p&gt;
&lt;p&gt;​    而且我对着官方文档，一个个做了详细的笔记，而且联想过了使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mariogogogo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mariogogogo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 http 升级 https</title>
    <link href="http://mariogogogo.github.io/2020/03/13/%E9%98%BF%E9%87%8C%E4%BA%91http%E5%8D%87%E7%BA%A7https/"/>
    <id>http://mariogogogo.github.io/2020/03/13/阿里云http升级https/</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-09-16T09:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p></blockquote><a id="more"></a><h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200313231641.png"                      alt=""                ></p><p>然后在 SSL 证书中下载申请来的证书</p><p>有 2 个：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200313231806.png"                      alt=""                ></p><h3 id="配置阿里云-nginx"><a href="#配置阿里云-nginx" class="headerlink" title="配置阿里云 nginx"></a>配置阿里云 nginx</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200313232143.png"                      alt=""                ></p><p>我的配置文件在<code>/ect/nginx</code>，现在把刚才的两个证书文件复制过来，待会直接配置使用就行了。nginx 的配置文件是<code>nginx.conf</code>，里面的配置内容有以下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #keepalive_timeout  <span class="number">0</span>;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    #gzip  on;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.xxx.cn;</span><br><span class="line"># 在这里，我做了https全加密处理，在访问http的时候自动跳转到https</span><br><span class="line">   rewrite ^(.*) https:<span class="comment">//$host$1 permanent;</span></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /home/chan/www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server 配置https就看这里啦</span><br><span class="line">    #</span><br><span class="line">     server &#123;</span><br><span class="line">        listen <span class="number">443</span>;</span><br><span class="line">        server_name www.xxx.cn;</span><br><span class="line">        ssl on;</span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root  /home/chan/www;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        ssl_certificate      cert/ssl.pem;</span><br><span class="line">        ssl_certificate_key  cert/ssl.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        #location / &#123;</span><br><span class="line">            #index index.html index.htm;</span><br><span class="line">           # proxy_pass http://127.0.0.1:8081;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>运行浏览器</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200313232516.png"                      alt=""                ></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="http://mariogogogo.github.io/categories/Web/"/>
    
    
      <category term="网络基础" scheme="http://mariogogogo.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GitFlow 工作流</title>
    <link href="http://mariogogogo.github.io/2020/02/25/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://mariogogogo.github.io/2020/02/25/GitFlow工作流/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-09-16T09:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p><a id="more"></a><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a class="link"   href="https://www.bilibili.com/video/av32573821/" >Git 工作流指南 - GitFlow 工作流<i class="fas fa-external-link-alt"></i></a></p><p><iframe src="//player.bilibili.com/player.html?aid=32573821&cid=56999550&page=1"  width="800px" height="550px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"><br> </iframe></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225120815.png"                      alt=""                ></p><p>GitFlow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。</p><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><p>GitFlow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到中央仓库中。</p><h3 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h3><p>相对使用仅有的一个 master 分支，GitFlow 工作流使用 2 个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130619.png"                      alt=""                ></p><p>剩下要说明的问题围绕着这 2 个分支的区别展开。</p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>每个新功能位于一个自己的分支，这样可以 push 到<code>中央仓库</code>以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130648.png"                      alt=""                ></p><p>注意，从各种含义和目的上来看，功能分支加上 develop 分支就是功能分支工作流的用法。但 GitFlow 工作流没有在这里止步。</p><h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130727.png"                      alt=""                ></p><p>一旦 develop 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 develop 分支上 fork 一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做 Bug 修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到 master 分支并分配一个版本号打好 Tag。另外，这些从新建发布分支以来的做的修改要合并回 develop 分支。</p><p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。</p><p>常用的分支约定：</p><ul><li>用于新建发布分支的分支: <code>develop</code></li><li>用于合并的分支: <code>master</code></li><li>分支命名: <code>release</code>-_ 或 release/_</li></ul><h3 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130815.png"                      alt=""                ></p><p>维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从 master 分支 fork 出来的分支。修复完成，修改应该马上合并回 master 分支和 develop 分支（当前的发布分支），master 分支应该用新的版本号打好 Tag。</p><p>为 Bug 修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在 master 分支上处理的临时发布。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个<code>中央仓库</code>。</p><h3 id="创建开发分支"><a href="#创建开发分支" class="headerlink" title="创建开发分支"></a>创建开发分支</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130837.png"                      alt=""                ></p><p>第一步为 master 分支配套一个 develop 分支。简单来做可以本地创建一个空的 develop 分支，push 到服务器上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> develop</span><br></pre></td></tr></table></figure><p>以后这个分支将会包含了项目的全部历史，而 master 分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好 develop 分支的跟踪分支：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh:<span class="regexp">//u</span>ser@host<span class="regexp">/path/</span>to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><p>现在每个开发都有了这些历史分支的本地拷贝。</p><h3 id="小红和小明开始开发新功能"><a href="#小红和小明开始开发新功能" class="headerlink" title="小红和小明开始开发新功能"></a>小红和小明开始开发新功能</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225130957.png"                      alt=""                ></p><p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于 master 分支，而是应该基于 <code>develop</code> 分支：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br></pre></td></tr></table></figure><p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git <span class="keyword">add</span></span><br><span class="line">git <span class="keyword">commit</span></span><br></pre></td></tr></table></figure><h3 id="小红完成功能开发"><a href="#小红完成功能开发" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225131037.png"                      alt=""                ></p><p>添加了提交后，小红觉得她的功能 OK 了。如果团队使用 Pull Requests，这时候可以发起一个用于合并到 develop 分支。否则她可以直接合并到她本地的 develop 分支后 push 到中央仓库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="built_in">origin</span> develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">push</span></span><br><span class="line">git branch -d <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>第一条命令在合并功能前确保 develop 分支是最新的。注意，功能决不应该直接合并到 master 分支。冲突解决方法和集中式工作流一样。</p><h2 id="小红开始准备发布"><a href="#小红开始准备发布" class="headerlink" title="小红开始准备发布"></a>小红开始准备发布</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225131059.png"                      alt=""                ></p><p>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout -b release-<span class="number">0</span>.<span class="number">1</span> develop</span><br></pre></td></tr></table></figure><p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p><p>只要小红创建这个分支并 push 到中央仓库，这个发布就是功能冻结的。任何不在 develop 分支中的新功能都推到下个发布循环中。</p><h3 id="小红完成发布"><a href="#小红完成发布" class="headerlink" title="小红完成发布"></a>小红完成发布</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225131203.png"                      alt=""                ></p><p>一旦准备好了对外发布，小红合并修改到 master 分支和 develop 分支上，删除发布分支。合并回 develop 分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。另外，如果小红的团队要求 Code Review，这是一个发起 Pull Request 的理想时机。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout master</span><br><span class="line"><span class="attribute">git</span> merge release-<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">git</span> push</span><br><span class="line"><span class="attribute">git</span> checkout develop</span><br><span class="line"><span class="attribute">git</span> merge release-<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">git</span> push</span><br><span class="line"><span class="attribute">git</span> branch -d release-<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>发布分支是作为功能开发（develop 分支）和对外发布（master 分支）间的缓冲。只要有合并到 master 分支，就应该打好 Tag 以方便跟踪。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">0.1</span> -m <span class="string">&quot;Initial public release&quot;</span> <span class="literal">master</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>Git 有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。可以配置一个勾子，在你 push 中央仓库的 master 分支时，自动构建好对外发布。</p><h3 id="最终用户发现-Bug"><a href="#最终用户发现-Bug" class="headerlink" title="最终用户发现 Bug"></a>最终用户发现 Bug</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="http://book.52react.cn/20200225131248.png"                      alt=""                ></p><p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个 <code>Issues</code> 抱怨当前版本的一个 Bug。为了处理 Bug，小红（或小明）从 master 分支上拉出了一个<code>维护分支</code>，提交修改以解决问题，然后直接合并回 master 分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br><span class="line"><span class="comment"># Fix the bug</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>就像发布分支，维护分支中新加这些重要修改需要包含到 develop 分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-<span class="meta">#001</span></span><br><span class="line">git <span class="keyword">push</span></span><br><span class="line">git branch -d issue-<span class="meta">#001</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到了这里， GitFlow 工作流已经感觉很舒适了。你应该也牢固的掌握了本地仓库的潜能，push/pull 模式和 Git 健壮的分支和合并模型。</p><p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用 Git 不可违逆的条例。所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让 Git 为你所用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://mariogogogo.github.io/categories/Web/"/>
    
    
      <category term="Git" scheme="http://mariogogogo.github.io/tags/Git/"/>
    
      <category term="技巧" scheme="http://mariogogogo.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
